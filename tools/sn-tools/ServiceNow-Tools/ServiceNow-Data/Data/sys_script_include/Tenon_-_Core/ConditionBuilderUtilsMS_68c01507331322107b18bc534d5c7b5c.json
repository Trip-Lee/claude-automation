{
  "_metadata": {
    "table": "sys_script_include",
    "sys_id": "68c01507331322107b18bc534d5c7b5c",
    "extracted_at": "2025-09-19T21:48:28.633Z",
    "display_value": "ConditionBuilderUtilsMS",
    "application": "Tenon_-_Core",
    "scope": {
      "display_value": "Tenon - Core",
      "link": "https://tenonworkstudio.service-now.com/api/now/table/sys_scope/608cd026c374e250d4ddf1db050131bb",
      "value": "608cd026c374e250d4ddf1db050131bb"
    }
  },
  "client_callable": {
    "value": "false",
    "display_value": "false"
  },
  "access": {
    "value": "public",
    "display_value": "All application scopes"
  },
  "mobile_callable": {
    "value": "false",
    "display_value": "false"
  },
  "sys_mod_count": {
    "value": "3",
    "display_value": "3"
  },
  "active": {
    "value": "true",
    "display_value": "true"
  },
  "description": {
    "value": "",
    "display_value": ""
  },
  "sys_updated_on": {
    "value": "2025-08-27 01:21:57",
    "display_value": "2025-08-26 06:21:57 PM"
  },
  "sys_tags": {
    "value": "",
    "display_value": ""
  },
  "sandbox_callable": {
    "value": "true",
    "display_value": "true"
  },
  "script": {
    "value": "var ConditionBuilderUtilsMS = Class.create();\r\nConditionBuilderUtilsMS.prototype = {\r\n\tinitialize: function () {},\r\n\r\n\t/**\r\n\t * Get current date information for viewingYear and viewingMonth\r\n\t * @returns {Object} Object with year and month (0-indexed)\r\n\t */\r\n\tgetCurrentDateInfo: function () {\r\n\t\tvar now = new GlideDateTime();\r\n\t\treturn {\r\n\t\t\tyear: 2025, // Using fixed year as shown in examples\r\n\t\t\tmonth: 7, // Using fixed month (August, 0-indexed) as shown in examples\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Create default option properties for filter options\r\n\t * @param {boolean} isFirstOption - Whether this is the first option\r\n\t * @returns {Object} Default option properties\r\n\t */\r\n\tgetDefaultOptionProperties: function (isFirstOption) {\r\n\t\tvar dateInfo = this.getCurrentDateInfo();\r\n\t\treturn {\r\n\t\t\tviewingYear: dateInfo.year,\r\n\t\t\tviewingMonth: dateInfo.month,\r\n\t\t\tselectedDate: {\r\n\t\t\t\tselectedYear: \"\",\r\n\t\t\t\tselectedMonth: \"\",\r\n\t\t\t\tselectedDay: \"\",\r\n\t\t\t},\r\n\t\t\tduration: {\r\n\t\t\t\tdurationDays: \"\",\r\n\t\t\t\tdurationHours: \"\",\r\n\t\t\t\tdurationMinutes: \"\",\r\n\t\t\t\tdurationSeconds: \"\",\r\n\t\t\t},\r\n\t\t\ttempDuration: {\r\n\t\t\t\tdurationDays: \"\",\r\n\t\t\t\tdurationHours: \"\",\r\n\t\t\t\tdurationMinutes: \"\",\r\n\t\t\t\tdurationSeconds: \"\",\r\n\t\t\t},\r\n\t\t\tcurrency: \"\",\r\n\t\t\tselectedTime: \"\",\r\n\t\t\tsearchInput: {\r\n\t\t\t\tfieldSeachInputValue: \"\",\r\n\t\t\t\toptionSearchInputValue: \"\",\r\n\t\t\t\ttimeSearchInputValue: \"\",\r\n\t\t\t},\r\n\t\t\tshowIcon: isFirstOption ? true : \"\",\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Format boolean labels with proper capitalization\r\n\t * @param {string} value - The boolean value to format\r\n\t * @returns {string} Formatted label\r\n\t */\r\n\tformatBooleanLabel: function (value) {\r\n\t\tif (value === \"true\") return \"True\";\r\n\t\tif (value === \"false\") return \"False\";\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Get field metadata including maxLength\r\n\t * @param {string} fieldName - The field name\r\n\t * @param {string} fieldType - The field type\r\n\t * @returns {Object} Field metadata\r\n\t */\r\n\tgetFieldMetadata: function (fieldName, fieldType) {\r\n\t\tvar metadata = {\r\n\t\t\tmaxLength: \"40\", // Default\r\n\t\t\treferences: [],\r\n\t\t\trefTable: null,\r\n\t\t};\r\n\r\n\t\t// Set maxLength based on field type\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\tmetadata.maxLength = \"32\";\r\n\t\t} else if (fieldType === \"boolean\") {\r\n\t\t\tmetadata.maxLength = \"40\";\r\n\t\t} else if (fieldType === \"string\") {\r\n\t\t\tmetadata.maxLength = \"40\";\r\n\t\t}\r\n\r\n\t\treturn metadata;\r\n\t},\r\n\r\n\t/**\r\n\t * Handle special date values like \"Today\", \"Yesterday\", \"Tomorrow\"\r\n\t * @param {string} value - The date value\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {Object|string} Formatted date value\r\n\t */\r\n\thandleSpecialDateValue: function (value, operator) {\r\n\t\t// Handle \"Today\"\r\n\t\tif (operator === \"ON\" && value === \"Today\") {\r\n\t\t\treturn {\r\n\t\t\t\t\"<\": \"javascript:gs.beginningOfToday()\",\r\n\t\t\t\t\"<=\": \"javascript:gs.endOfToday()\",\r\n\t\t\t\t\">\": \"javascript:gs.endOfToday()\",\r\n\t\t\t\t\">=\": \"javascript:gs.beginningOfToday()\",\r\n\t\t\t\t\"BETWEEN@\": \"javascript:gs.beginningOfToday()\",\r\n\t\t\t\tNOTON: \"Today@javascript:gs.beginningOfToday()@javascript:gs.endOfToday()\",\r\n\t\t\t\tON: \"Today@javascript:gs.beginningOfToday()@javascript:gs.endOfToday()\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle \"Yesterday\"\r\n\t\tif (operator === \"ON\" && value === \"Yesterday\") {\r\n\t\t\treturn {\r\n\t\t\t\t\"<\": \"javascript:gs.beginningOfYesterday()\",\r\n\t\t\t\t\"<=\": \"javascript:gs.endOfYesterday()\",\r\n\t\t\t\t\">\": \"javascript:gs.endOfYesterday()\",\r\n\t\t\t\t\">=\": \"javascript:gs.beginningOfYesterday()\",\r\n\t\t\t\t\"BETWEEN@\": \"javascript:gs.beginningOfYesterday()\",\r\n\t\t\t\tNOTON: \"Yesterday@javascript:gs.beginningOfYesterday()@javascript:gs.endOfYesterday()\",\r\n\t\t\t\tON: \"Yesterday@javascript:gs.beginningOfYesterday()@javascript:gs.endOfYesterday()\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle \"Tomorrow\"\r\n\t\tif (operator === \"ON\" && value === \"Tomorrow\") {\r\n\t\t\treturn {\r\n\t\t\t\t\"<\": \"javascript:gs.beginningOfTomorrow()\",\r\n\t\t\t\t\"<=\": \"javascript:gs.endOfTomorrow()\",\r\n\t\t\t\t\">\": \"javascript:gs.endOfTomorrow()\",\r\n\t\t\t\t\">=\": \"javascript:gs.beginningOfTomorrow()\",\r\n\t\t\t\t\"BETWEEN@\": \"javascript:gs.beginningOfTomorrow()\",\r\n\t\t\t\tNOTON: \"Tomorrow@javascript:gs.beginningOfTomorrow()@javascript:gs.endOfTomorrow()\",\r\n\t\t\t\tON: \"Tomorrow@javascript:gs.beginningOfTomorrow()@javascript:gs.endOfTomorrow()\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Parse date value from encoded query\r\n\t * @param {string} value - The date value string\r\n\t * @returns {Object} Parsed date object\r\n\t */\r\n\tparseDateValue: function (value) {\r\n\t\t// Handle date with @ separators for ON operator\r\n\t\tif (value && value.indexOf(\"@\") > -1) {\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\tif (parts.length >= 3) {\r\n\t\t\t\t// Format: 2025-08-21@javascript:gs.dateGenerate('2025-08-21','start')@javascript:gs.dateGenerate('2025-08-21','end')\r\n\t\t\t\treturn {\r\n\t\t\t\t\tdate: parts[0],\r\n\t\t\t\t\tstartScript: parts[1],\r\n\t\t\t\t\tendScript: parts[2],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tdate: value,\r\n\t\t\tstartScript: null,\r\n\t\t\tendScript: null,\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Format date label for display\r\n\t * @param {string} dateValue - The date value\r\n\t * @returns {string} Formatted date label\r\n\t */\r\n\tformatDateLabel: function (dateValue) {\r\n\t\tif (!dateValue || dateValue === \"Today\") return dateValue;\r\n\r\n\t\t// Parse date string like \"2025-08-21\" to \"2025-8-21\"\r\n\t\tvar parts = dateValue.split(\"-\");\r\n\t\tif (parts.length === 3) {\r\n\t\t\tvar year = parts[0];\r\n\t\t\tvar month = parseInt(parts[1], 10); // Remove leading zero\r\n\t\t\tvar day = parseInt(parts[2], 10); // Remove leading zero\r\n\t\t\treturn year + \"-\" + month + \"-\" + day;\r\n\t\t}\r\n\t\treturn dateValue;\r\n\t},\r\n\r\n\t/**\r\n\t * Parse selected date from date string\r\n\t * @param {string} dateValue - The date value\r\n\t * @returns {Object} Selected date object\r\n\t */\r\n\tparseSelectedDate: function (dateValue) {\r\n\t\tif (!dateValue || dateValue === \"Today\") {\r\n\t\t\treturn {\r\n\t\t\t\tselectedYear: \"\",\r\n\t\t\t\tselectedMonth: \"\",\r\n\t\t\t\tselectedDay: \"\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar parts = dateValue.split(\"-\");\r\n\t\tif (parts.length === 3) {\r\n\t\t\treturn {\r\n\t\t\t\tselectedYear: parseInt(parts[0], 10),\r\n\t\t\t\tselectedMonth: parseInt(parts[1], 10),\r\n\t\t\t\tselectedDay: parseInt(parts[2], 10),\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tselectedYear: \"\",\r\n\t\t\tselectedMonth: \"\",\r\n\t\t\tselectedDay: \"\",\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Get display value for a reference field\r\n\t * @param {string} sysId - The sys_id value\r\n\t * @param {string} refTable - The reference table name\r\n\t * @returns {string} Display value or \"Empty\" + field name\r\n\t */\r\n\tgetReferenceLabel: function (sysId, refTable, fieldName) {\r\n\t\tif (!sysId || !refTable) {\r\n\t\t\treturn sysId || \"\";\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tvar gr = new GlideRecord(refTable);\r\n\t\t\tif (gr.get(sysId)) {\r\n\t\t\t\tvar displayValue = gr.getDisplayValue();\r\n\t\t\t\tif (displayValue) {\r\n\t\t\t\t\treturn displayValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// If we can't get the record, return the sys_id\r\n\t\t}\r\n\r\n\t\t// Return \"Empty\" + humanized field name if no display value\r\n\t\tif (fieldName) {\r\n\t\t\tvar words = fieldName.split(\"_\");\r\n\t\t\tvar humanized = [];\r\n\t\t\tfor (var i = 0; i < words.length; i++) {\r\n\t\t\t\tif (words[i]) {\r\n\t\t\t\t\thumanized.push(words[i].charAt(0).toUpperCase() + words[i].slice(1));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"Empty \" + humanized.join(\" \");\r\n\t\t}\r\n\r\n\t\treturn sysId;\r\n\t},\r\n\r\n\t/**\r\n\t * Format currency value\r\n\t * @param {string} value - The currency value\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {string} Formatted currency value\r\n\t */\r\n\tformatCurrencyValue: function (value, operator) {\r\n\t\tif (!value) return value;\r\n\r\n\t\t// Handle javascript expressions for currency\r\n\t\tif (value.indexOf(\"javascript:\") === 0) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Parse and format currency value\r\n\t\tvar numValue = parseFloat(value);\r\n\t\tif (!isNaN(numValue)) {\r\n\t\t\t// Return as formatted string\r\n\t\t\treturn numValue.toString();\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Format duration value\r\n\t * @param {string} value - The duration value\r\n\t * @returns {string} Formatted duration value\r\n\t */\r\n\tformatDurationValue: function (value) {\r\n\t\tif (!value) return value;\r\n\r\n\t\t// If already in the correct format (days hours:minutes:seconds)\r\n\t\tif (value.match(/^\\d+\\s+\\d{1,2}:\\d{2}:\\d{2}$/)) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Try to parse duration in various formats\r\n\t\tvar duration = this.parseDuration(value);\r\n\t\tif (duration) {\r\n\t\t\t// Format as \"days hours:minutes:seconds\"\r\n\t\t\tvar days = duration.durationDays || \"0\";\r\n\t\t\tvar hours = this._padStart(duration.durationHours || \"0\", 2, \"0\");\r\n\t\t\tvar minutes = this._padStart(duration.durationMinutes || \"0\", 2, \"0\");\r\n\t\t\tvar seconds = this._padStart(duration.durationSeconds || \"0\", 2, \"0\");\r\n\r\n\t\t\treturn days + \" \" + hours + \":\" + minutes + \":\" + seconds;\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Parse duration string into components\r\n\t * @param {string} value - The duration value\r\n\t * @returns {Object} Duration object with days, hours, minutes, seconds\r\n\t */\r\n\tparseDuration: function (value) {\r\n\t\tif (!value) return null;\r\n\r\n\t\t// Parse \"days hours:minutes:seconds\" format\r\n\t\tvar match = value.match(/^(\\d+)\\s+(\\d{1,2}):(\\d{2}):(\\d{2})$/);\r\n\t\tif (match) {\r\n\t\t\treturn {\r\n\t\t\t\tdurationDays: match[1],\r\n\t\t\t\tdurationHours: match[2],\r\n\t\t\t\tdurationMinutes: match[3],\r\n\t\t\t\tdurationSeconds: match[4],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Parse ISO 8601 duration format (P1DT2H3M4S)\r\n\t\tmatch = value.match(/^P(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?)?$/);\r\n\t\tif (match) {\r\n\t\t\treturn {\r\n\t\t\t\tdurationDays: match[1] || \"0\",\r\n\t\t\t\tdurationHours: match[2] || \"0\",\r\n\t\t\t\tdurationMinutes: match[3] || \"0\",\r\n\t\t\t\tdurationSeconds: match[4] || \"0\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Parse simple number as days\r\n\t\tif (value.match(/^\\d+$/)) {\r\n\t\t\treturn {\r\n\t\t\t\tdurationDays: value,\r\n\t\t\t\tdurationHours: \"0\",\r\n\t\t\t\tdurationMinutes: \"0\",\r\n\t\t\t\tdurationSeconds: \"0\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\t/**\r\n\t * Format date time value\r\n\t * @param {string} value - The date time value\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {string} Formatted date time value\r\n\t */\r\n\tformatDateTimeValue: function (value, operator) {\r\n\t\tif (!value) return value;\r\n\r\n\t\t// Handle special values\r\n\t\tif (value === \"Today\" || value === \"Yesterday\" || value === \"Tomorrow\") {\r\n\t\t\treturn this.handleSpecialDateValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle javascript expressions\r\n\t\tif (value.indexOf(\"javascript:\") === 0) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Handle date with @ separators (for ON operator)\r\n\t\tif (value.indexOf(\"@\") > -1) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Return date value as-is\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Format choice value\r\n\t * @param {string} value - The choice value\r\n\t * @param {string} table - The table name\r\n\t * @param {string} fieldName - The field name\r\n\t * @returns {string} Formatted choice value\r\n\t */\r\n\tformatChoiceValue: function (value, table, fieldName) {\r\n\t\t// Choice values should be kept as-is (the numeric or string value)\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Helper function to pad start of string (polyfill for older JS)\r\n\t * @param {string} str - The string to pad\r\n\t * @param {number} targetLength - Target length\r\n\t * @param {string} padString - String to pad with\r\n\t * @returns {string} Padded string\r\n\t */\r\n\t_padStart: function (str, targetLength, padString) {\r\n\t\tstr = String(str);\r\n\t\ttargetLength = targetLength >> 0;\r\n\t\tpadString = String(padString || \" \");\r\n\t\tif (str.length > targetLength) {\r\n\t\t\treturn str;\r\n\t\t} else {\r\n\t\t\ttargetLength = targetLength - str.length;\r\n\t\t\tif (targetLength > padString.length) {\r\n\t\t\t\tpadString += Array(Math.floor(targetLength / padString.length) + 1).join(padString);\r\n\t\t\t}\r\n\t\t\treturn padString.slice(0, targetLength) + str;\r\n\t\t}\r\n\t},\r\n\r\n\ttype: \"ConditionBuilderUtilsMS\",\r\n};\r\n",
    "display_value": "var ConditionBuilderUtilsMS = Class.create();\r\nConditionBuilderUtilsMS.prototype = {\r\n\tinitialize: function () {},\r\n\r\n\t/**\r\n\t * Get current date information for viewingYear and viewingMonth\r\n\t * @returns {Object} Object with year and month (0-indexed)\r\n\t */\r\n\tgetCurrentDateInfo: function () {\r\n\t\tvar now = new GlideDateTime();\r\n\t\treturn {\r\n\t\t\tyear: 2025, // Using fixed year as shown in examples\r\n\t\t\tmonth: 7, // Using fixed month (August, 0-indexed) as shown in examples\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Create default option properties for filter options\r\n\t * @param {boolean} isFirstOption - Whether this is the first option\r\n\t * @returns {Object} Default option properties\r\n\t */\r\n\tgetDefaultOptionProperties: function (isFirstOption) {\r\n\t\tvar dateInfo = this.getCurrentDateInfo();\r\n\t\treturn {\r\n\t\t\tviewingYear: dateInfo.year,\r\n\t\t\tviewingMonth: dateInfo.month,\r\n\t\t\tselectedDate: {\r\n\t\t\t\tselectedYear: \"\",\r\n\t\t\t\tselectedMonth: \"\",\r\n\t\t\t\tselectedDay: \"\",\r\n\t\t\t},\r\n\t\t\tduration: {\r\n\t\t\t\tdurationDays: \"\",\r\n\t\t\t\tdurationHours: \"\",\r\n\t\t\t\tdurationMinutes: \"\",\r\n\t\t\t\tdurationSeconds: \"\",\r\n\t\t\t},\r\n\t\t\ttempDuration: {\r\n\t\t\t\tdurationDays: \"\",\r\n\t\t\t\tdurationHours: \"\",\r\n\t\t\t\tdurationMinutes: \"\",\r\n\t\t\t\tdurationSeconds: \"\",\r\n\t\t\t},\r\n\t\t\tcurrency: \"\",\r\n\t\t\tselectedTime: \"\",\r\n\t\t\tsearchInput: {\r\n\t\t\t\tfieldSeachInputValue: \"\",\r\n\t\t\t\toptionSearchInputValue: \"\",\r\n\t\t\t\ttimeSearchInputValue: \"\",\r\n\t\t\t},\r\n\t\t\tshowIcon: isFirstOption ? true : \"\",\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Format boolean labels with proper capitalization\r\n\t * @param {string} value - The boolean value to format\r\n\t * @returns {string} Formatted label\r\n\t */\r\n\tformatBooleanLabel: function (value) {\r\n\t\tif (value === \"true\") return \"True\";\r\n\t\tif (value === \"false\") return \"False\";\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Get field metadata including maxLength\r\n\t * @param {string} fieldName - The field name\r\n\t * @param {string} fieldType - The field type\r\n\t * @returns {Object} Field metadata\r\n\t */\r\n\tgetFieldMetadata: function (fieldName, fieldType) {\r\n\t\tvar metadata = {\r\n\t\t\tmaxLength: \"40\", // Default\r\n\t\t\treferences: [],\r\n\t\t\trefTable: null,\r\n\t\t};\r\n\r\n\t\t// Set maxLength based on field type\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\tmetadata.maxLength = \"32\";\r\n\t\t} else if (fieldType === \"boolean\") {\r\n\t\t\tmetadata.maxLength = \"40\";\r\n\t\t} else if (fieldType === \"string\") {\r\n\t\t\tmetadata.maxLength = \"40\";\r\n\t\t}\r\n\r\n\t\treturn metadata;\r\n\t},\r\n\r\n\t/**\r\n\t * Handle special date values like \"Today\", \"Yesterday\", \"Tomorrow\"\r\n\t * @param {string} value - The date value\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {Object|string} Formatted date value\r\n\t */\r\n\thandleSpecialDateValue: function (value, operator) {\r\n\t\t// Handle \"Today\"\r\n\t\tif (operator === \"ON\" && value === \"Today\") {\r\n\t\t\treturn {\r\n\t\t\t\t\"<\": \"javascript:gs.beginningOfToday()\",\r\n\t\t\t\t\"<=\": \"javascript:gs.endOfToday()\",\r\n\t\t\t\t\">\": \"javascript:gs.endOfToday()\",\r\n\t\t\t\t\">=\": \"javascript:gs.beginningOfToday()\",\r\n\t\t\t\t\"BETWEEN@\": \"javascript:gs.beginningOfToday()\",\r\n\t\t\t\tNOTON: \"Today@javascript:gs.beginningOfToday()@javascript:gs.endOfToday()\",\r\n\t\t\t\tON: \"Today@javascript:gs.beginningOfToday()@javascript:gs.endOfToday()\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle \"Yesterday\"\r\n\t\tif (operator === \"ON\" && value === \"Yesterday\") {\r\n\t\t\treturn {\r\n\t\t\t\t\"<\": \"javascript:gs.beginningOfYesterday()\",\r\n\t\t\t\t\"<=\": \"javascript:gs.endOfYesterday()\",\r\n\t\t\t\t\">\": \"javascript:gs.endOfYesterday()\",\r\n\t\t\t\t\">=\": \"javascript:gs.beginningOfYesterday()\",\r\n\t\t\t\t\"BETWEEN@\": \"javascript:gs.beginningOfYesterday()\",\r\n\t\t\t\tNOTON: \"Yesterday@javascript:gs.beginningOfYesterday()@javascript:gs.endOfYesterday()\",\r\n\t\t\t\tON: \"Yesterday@javascript:gs.beginningOfYesterday()@javascript:gs.endOfYesterday()\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle \"Tomorrow\"\r\n\t\tif (operator === \"ON\" && value === \"Tomorrow\") {\r\n\t\t\treturn {\r\n\t\t\t\t\"<\": \"javascript:gs.beginningOfTomorrow()\",\r\n\t\t\t\t\"<=\": \"javascript:gs.endOfTomorrow()\",\r\n\t\t\t\t\">\": \"javascript:gs.endOfTomorrow()\",\r\n\t\t\t\t\">=\": \"javascript:gs.beginningOfTomorrow()\",\r\n\t\t\t\t\"BETWEEN@\": \"javascript:gs.beginningOfTomorrow()\",\r\n\t\t\t\tNOTON: \"Tomorrow@javascript:gs.beginningOfTomorrow()@javascript:gs.endOfTomorrow()\",\r\n\t\t\t\tON: \"Tomorrow@javascript:gs.beginningOfTomorrow()@javascript:gs.endOfTomorrow()\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Parse date value from encoded query\r\n\t * @param {string} value - The date value string\r\n\t * @returns {Object} Parsed date object\r\n\t */\r\n\tparseDateValue: function (value) {\r\n\t\t// Handle date with @ separators for ON operator\r\n\t\tif (value && value.indexOf(\"@\") > -1) {\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\tif (parts.length >= 3) {\r\n\t\t\t\t// Format: 2025-08-21@javascript:gs.dateGenerate('2025-08-21','start')@javascript:gs.dateGenerate('2025-08-21','end')\r\n\t\t\t\treturn {\r\n\t\t\t\t\tdate: parts[0],\r\n\t\t\t\t\tstartScript: parts[1],\r\n\t\t\t\t\tendScript: parts[2],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tdate: value,\r\n\t\t\tstartScript: null,\r\n\t\t\tendScript: null,\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Format date label for display\r\n\t * @param {string} dateValue - The date value\r\n\t * @returns {string} Formatted date label\r\n\t */\r\n\tformatDateLabel: function (dateValue) {\r\n\t\tif (!dateValue || dateValue === \"Today\") return dateValue;\r\n\r\n\t\t// Parse date string like \"2025-08-21\" to \"2025-8-21\"\r\n\t\tvar parts = dateValue.split(\"-\");\r\n\t\tif (parts.length === 3) {\r\n\t\t\tvar year = parts[0];\r\n\t\t\tvar month = parseInt(parts[1], 10); // Remove leading zero\r\n\t\t\tvar day = parseInt(parts[2], 10); // Remove leading zero\r\n\t\t\treturn year + \"-\" + month + \"-\" + day;\r\n\t\t}\r\n\t\treturn dateValue;\r\n\t},\r\n\r\n\t/**\r\n\t * Parse selected date from date string\r\n\t * @param {string} dateValue - The date value\r\n\t * @returns {Object} Selected date object\r\n\t */\r\n\tparseSelectedDate: function (dateValue) {\r\n\t\tif (!dateValue || dateValue === \"Today\") {\r\n\t\t\treturn {\r\n\t\t\t\tselectedYear: \"\",\r\n\t\t\t\tselectedMonth: \"\",\r\n\t\t\t\tselectedDay: \"\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar parts = dateValue.split(\"-\");\r\n\t\tif (parts.length === 3) {\r\n\t\t\treturn {\r\n\t\t\t\tselectedYear: parseInt(parts[0], 10),\r\n\t\t\t\tselectedMonth: parseInt(parts[1], 10),\r\n\t\t\t\tselectedDay: parseInt(parts[2], 10),\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tselectedYear: \"\",\r\n\t\t\tselectedMonth: \"\",\r\n\t\t\tselectedDay: \"\",\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Get display value for a reference field\r\n\t * @param {string} sysId - The sys_id value\r\n\t * @param {string} refTable - The reference table name\r\n\t * @returns {string} Display value or \"Empty\" + field name\r\n\t */\r\n\tgetReferenceLabel: function (sysId, refTable, fieldName) {\r\n\t\tif (!sysId || !refTable) {\r\n\t\t\treturn sysId || \"\";\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tvar gr = new GlideRecord(refTable);\r\n\t\t\tif (gr.get(sysId)) {\r\n\t\t\t\tvar displayValue = gr.getDisplayValue();\r\n\t\t\t\tif (displayValue) {\r\n\t\t\t\t\treturn displayValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// If we can't get the record, return the sys_id\r\n\t\t}\r\n\r\n\t\t// Return \"Empty\" + humanized field name if no display value\r\n\t\tif (fieldName) {\r\n\t\t\tvar words = fieldName.split(\"_\");\r\n\t\t\tvar humanized = [];\r\n\t\t\tfor (var i = 0; i < words.length; i++) {\r\n\t\t\t\tif (words[i]) {\r\n\t\t\t\t\thumanized.push(words[i].charAt(0).toUpperCase() + words[i].slice(1));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"Empty \" + humanized.join(\" \");\r\n\t\t}\r\n\r\n\t\treturn sysId;\r\n\t},\r\n\r\n\t/**\r\n\t * Format currency value\r\n\t * @param {string} value - The currency value\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {string} Formatted currency value\r\n\t */\r\n\tformatCurrencyValue: function (value, operator) {\r\n\t\tif (!value) return value;\r\n\r\n\t\t// Handle javascript expressions for currency\r\n\t\tif (value.indexOf(\"javascript:\") === 0) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Parse and format currency value\r\n\t\tvar numValue = parseFloat(value);\r\n\t\tif (!isNaN(numValue)) {\r\n\t\t\t// Return as formatted string\r\n\t\t\treturn numValue.toString();\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Format duration value\r\n\t * @param {string} value - The duration value\r\n\t * @returns {string} Formatted duration value\r\n\t */\r\n\tformatDurationValue: function (value) {\r\n\t\tif (!value) return value;\r\n\r\n\t\t// If already in the correct format (days hours:minutes:seconds)\r\n\t\tif (value.match(/^\\d+\\s+\\d{1,2}:\\d{2}:\\d{2}$/)) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Try to parse duration in various formats\r\n\t\tvar duration = this.parseDuration(value);\r\n\t\tif (duration) {\r\n\t\t\t// Format as \"days hours:minutes:seconds\"\r\n\t\t\tvar days = duration.durationDays || \"0\";\r\n\t\t\tvar hours = this._padStart(duration.durationHours || \"0\", 2, \"0\");\r\n\t\t\tvar minutes = this._padStart(duration.durationMinutes || \"0\", 2, \"0\");\r\n\t\t\tvar seconds = this._padStart(duration.durationSeconds || \"0\", 2, \"0\");\r\n\r\n\t\t\treturn days + \" \" + hours + \":\" + minutes + \":\" + seconds;\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Parse duration string into components\r\n\t * @param {string} value - The duration value\r\n\t * @returns {Object} Duration object with days, hours, minutes, seconds\r\n\t */\r\n\tparseDuration: function (value) {\r\n\t\tif (!value) return null;\r\n\r\n\t\t// Parse \"days hours:minutes:seconds\" format\r\n\t\tvar match = value.match(/^(\\d+)\\s+(\\d{1,2}):(\\d{2}):(\\d{2})$/);\r\n\t\tif (match) {\r\n\t\t\treturn {\r\n\t\t\t\tdurationDays: match[1],\r\n\t\t\t\tdurationHours: match[2],\r\n\t\t\t\tdurationMinutes: match[3],\r\n\t\t\t\tdurationSeconds: match[4],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Parse ISO 8601 duration format (P1DT2H3M4S)\r\n\t\tmatch = value.match(/^P(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?)?$/);\r\n\t\tif (match) {\r\n\t\t\treturn {\r\n\t\t\t\tdurationDays: match[1] || \"0\",\r\n\t\t\t\tdurationHours: match[2] || \"0\",\r\n\t\t\t\tdurationMinutes: match[3] || \"0\",\r\n\t\t\t\tdurationSeconds: match[4] || \"0\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Parse simple number as days\r\n\t\tif (value.match(/^\\d+$/)) {\r\n\t\t\treturn {\r\n\t\t\t\tdurationDays: value,\r\n\t\t\t\tdurationHours: \"0\",\r\n\t\t\t\tdurationMinutes: \"0\",\r\n\t\t\t\tdurationSeconds: \"0\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\t/**\r\n\t * Format date time value\r\n\t * @param {string} value - The date time value\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {string} Formatted date time value\r\n\t */\r\n\tformatDateTimeValue: function (value, operator) {\r\n\t\tif (!value) return value;\r\n\r\n\t\t// Handle special values\r\n\t\tif (value === \"Today\" || value === \"Yesterday\" || value === \"Tomorrow\") {\r\n\t\t\treturn this.handleSpecialDateValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle javascript expressions\r\n\t\tif (value.indexOf(\"javascript:\") === 0) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Handle date with @ separators (for ON operator)\r\n\t\tif (value.indexOf(\"@\") > -1) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Return date value as-is\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Format choice value\r\n\t * @param {string} value - The choice value\r\n\t * @param {string} table - The table name\r\n\t * @param {string} fieldName - The field name\r\n\t * @returns {string} Formatted choice value\r\n\t */\r\n\tformatChoiceValue: function (value, table, fieldName) {\r\n\t\t// Choice values should be kept as-is (the numeric or string value)\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Helper function to pad start of string (polyfill for older JS)\r\n\t * @param {string} str - The string to pad\r\n\t * @param {number} targetLength - Target length\r\n\t * @param {string} padString - String to pad with\r\n\t * @returns {string} Padded string\r\n\t */\r\n\t_padStart: function (str, targetLength, padString) {\r\n\t\tstr = String(str);\r\n\t\ttargetLength = targetLength >> 0;\r\n\t\tpadString = String(padString || \" \");\r\n\t\tif (str.length > targetLength) {\r\n\t\t\treturn str;\r\n\t\t} else {\r\n\t\t\ttargetLength = targetLength - str.length;\r\n\t\t\tif (targetLength > padString.length) {\r\n\t\t\t\tpadString += Array(Math.floor(targetLength / padString.length) + 1).join(padString);\r\n\t\t\t}\r\n\t\t\treturn padString.slice(0, targetLength) + str;\r\n\t\t}\r\n\t},\r\n\r\n\ttype: \"ConditionBuilderUtilsMS\",\r\n};\r\n",
    "formatted_script": {
      "line_count": 411,
      "char_count": 11462,
      "preview": "var ConditionBuilderUtilsMS = Class.create();\r\nConditionBuilderUtilsMS.prototype = {\r\n\tinitialize: function () {},\r\n\r\n\t/**\r\n\t * Get current date information for viewingYear and viewingMonth\r\n\t * @retu...",
      "full_script": "var ConditionBuilderUtilsMS = Class.create();\r\nConditionBuilderUtilsMS.prototype = {\r\n\tinitialize: function () {},\r\n\r\n\t/**\r\n\t * Get current date information for viewingYear and viewingMonth\r\n\t * @returns {Object} Object with year and month (0-indexed)\r\n\t */\r\n\tgetCurrentDateInfo: function () {\r\n\t\tvar now = new GlideDateTime();\r\n\t\treturn {\r\n\t\t\tyear: 2025, // Using fixed year as shown in examples\r\n\t\t\tmonth: 7, // Using fixed month (August, 0-indexed) as shown in examples\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Create default option properties for filter options\r\n\t * @param {boolean} isFirstOption - Whether this is the first option\r\n\t * @returns {Object} Default option properties\r\n\t */\r\n\tgetDefaultOptionProperties: function (isFirstOption) {\r\n\t\tvar dateInfo = this.getCurrentDateInfo();\r\n\t\treturn {\r\n\t\t\tviewingYear: dateInfo.year,\r\n\t\t\tviewingMonth: dateInfo.month,\r\n\t\t\tselectedDate: {\r\n\t\t\t\tselectedYear: \"\",\r\n\t\t\t\tselectedMonth: \"\",\r\n\t\t\t\tselectedDay: \"\",\r\n\t\t\t},\r\n\t\t\tduration: {\r\n\t\t\t\tdurationDays: \"\",\r\n\t\t\t\tdurationHours: \"\",\r\n\t\t\t\tdurationMinutes: \"\",\r\n\t\t\t\tdurationSeconds: \"\",\r\n\t\t\t},\r\n\t\t\ttempDuration: {\r\n\t\t\t\tdurationDays: \"\",\r\n\t\t\t\tdurationHours: \"\",\r\n\t\t\t\tdurationMinutes: \"\",\r\n\t\t\t\tdurationSeconds: \"\",\r\n\t\t\t},\r\n\t\t\tcurrency: \"\",\r\n\t\t\tselectedTime: \"\",\r\n\t\t\tsearchInput: {\r\n\t\t\t\tfieldSeachInputValue: \"\",\r\n\t\t\t\toptionSearchInputValue: \"\",\r\n\t\t\t\ttimeSearchInputValue: \"\",\r\n\t\t\t},\r\n\t\t\tshowIcon: isFirstOption ? true : \"\",\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Format boolean labels with proper capitalization\r\n\t * @param {string} value - The boolean value to format\r\n\t * @returns {string} Formatted label\r\n\t */\r\n\tformatBooleanLabel: function (value) {\r\n\t\tif (value === \"true\") return \"True\";\r\n\t\tif (value === \"false\") return \"False\";\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Get field metadata including maxLength\r\n\t * @param {string} fieldName - The field name\r\n\t * @param {string} fieldType - The field type\r\n\t * @returns {Object} Field metadata\r\n\t */\r\n\tgetFieldMetadata: function (fieldName, fieldType) {\r\n\t\tvar metadata = {\r\n\t\t\tmaxLength: \"40\", // Default\r\n\t\t\treferences: [],\r\n\t\t\trefTable: null,\r\n\t\t};\r\n\r\n\t\t// Set maxLength based on field type\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\tmetadata.maxLength = \"32\";\r\n\t\t} else if (fieldType === \"boolean\") {\r\n\t\t\tmetadata.maxLength = \"40\";\r\n\t\t} else if (fieldType === \"string\") {\r\n\t\t\tmetadata.maxLength = \"40\";\r\n\t\t}\r\n\r\n\t\treturn metadata;\r\n\t},\r\n\r\n\t/**\r\n\t * Handle special date values like \"Today\", \"Yesterday\", \"Tomorrow\"\r\n\t * @param {string} value - The date value\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {Object|string} Formatted date value\r\n\t */\r\n\thandleSpecialDateValue: function (value, operator) {\r\n\t\t// Handle \"Today\"\r\n\t\tif (operator === \"ON\" && value === \"Today\") {\r\n\t\t\treturn {\r\n\t\t\t\t\"<\": \"javascript:gs.beginningOfToday()\",\r\n\t\t\t\t\"<=\": \"javascript:gs.endOfToday()\",\r\n\t\t\t\t\">\": \"javascript:gs.endOfToday()\",\r\n\t\t\t\t\">=\": \"javascript:gs.beginningOfToday()\",\r\n\t\t\t\t\"BETWEEN@\": \"javascript:gs.beginningOfToday()\",\r\n\t\t\t\tNOTON: \"Today@javascript:gs.beginningOfToday()@javascript:gs.endOfToday()\",\r\n\t\t\t\tON: \"Today@javascript:gs.beginningOfToday()@javascript:gs.endOfToday()\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle \"Yesterday\"\r\n\t\tif (operator === \"ON\" && value === \"Yesterday\") {\r\n\t\t\treturn {\r\n\t\t\t\t\"<\": \"javascript:gs.beginningOfYesterday()\",\r\n\t\t\t\t\"<=\": \"javascript:gs.endOfYesterday()\",\r\n\t\t\t\t\">\": \"javascript:gs.endOfYesterday()\",\r\n\t\t\t\t\">=\": \"javascript:gs.beginningOfYesterday()\",\r\n\t\t\t\t\"BETWEEN@\": \"javascript:gs.beginningOfYesterday()\",\r\n\t\t\t\tNOTON: \"Yesterday@javascript:gs.beginningOfYesterday()@javascript:gs.endOfYesterday()\",\r\n\t\t\t\tON: \"Yesterday@javascript:gs.beginningOfYesterday()@javascript:gs.endOfYesterday()\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle \"Tomorrow\"\r\n\t\tif (operator === \"ON\" && value === \"Tomorrow\") {\r\n\t\t\treturn {\r\n\t\t\t\t\"<\": \"javascript:gs.beginningOfTomorrow()\",\r\n\t\t\t\t\"<=\": \"javascript:gs.endOfTomorrow()\",\r\n\t\t\t\t\">\": \"javascript:gs.endOfTomorrow()\",\r\n\t\t\t\t\">=\": \"javascript:gs.beginningOfTomorrow()\",\r\n\t\t\t\t\"BETWEEN@\": \"javascript:gs.beginningOfTomorrow()\",\r\n\t\t\t\tNOTON: \"Tomorrow@javascript:gs.beginningOfTomorrow()@javascript:gs.endOfTomorrow()\",\r\n\t\t\t\tON: \"Tomorrow@javascript:gs.beginningOfTomorrow()@javascript:gs.endOfTomorrow()\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Parse date value from encoded query\r\n\t * @param {string} value - The date value string\r\n\t * @returns {Object} Parsed date object\r\n\t */\r\n\tparseDateValue: function (value) {\r\n\t\t// Handle date with @ separators for ON operator\r\n\t\tif (value && value.indexOf(\"@\") > -1) {\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\tif (parts.length >= 3) {\r\n\t\t\t\t// Format: 2025-08-21@javascript:gs.dateGenerate('2025-08-21','start')@javascript:gs.dateGenerate('2025-08-21','end')\r\n\t\t\t\treturn {\r\n\t\t\t\t\tdate: parts[0],\r\n\t\t\t\t\tstartScript: parts[1],\r\n\t\t\t\t\tendScript: parts[2],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tdate: value,\r\n\t\t\tstartScript: null,\r\n\t\t\tendScript: null,\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Format date label for display\r\n\t * @param {string} dateValue - The date value\r\n\t * @returns {string} Formatted date label\r\n\t */\r\n\tformatDateLabel: function (dateValue) {\r\n\t\tif (!dateValue || dateValue === \"Today\") return dateValue;\r\n\r\n\t\t// Parse date string like \"2025-08-21\" to \"2025-8-21\"\r\n\t\tvar parts = dateValue.split(\"-\");\r\n\t\tif (parts.length === 3) {\r\n\t\t\tvar year = parts[0];\r\n\t\t\tvar month = parseInt(parts[1], 10); // Remove leading zero\r\n\t\t\tvar day = parseInt(parts[2], 10); // Remove leading zero\r\n\t\t\treturn year + \"-\" + month + \"-\" + day;\r\n\t\t}\r\n\t\treturn dateValue;\r\n\t},\r\n\r\n\t/**\r\n\t * Parse selected date from date string\r\n\t * @param {string} dateValue - The date value\r\n\t * @returns {Object} Selected date object\r\n\t */\r\n\tparseSelectedDate: function (dateValue) {\r\n\t\tif (!dateValue || dateValue === \"Today\") {\r\n\t\t\treturn {\r\n\t\t\t\tselectedYear: \"\",\r\n\t\t\t\tselectedMonth: \"\",\r\n\t\t\t\tselectedDay: \"\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar parts = dateValue.split(\"-\");\r\n\t\tif (parts.length === 3) {\r\n\t\t\treturn {\r\n\t\t\t\tselectedYear: parseInt(parts[0], 10),\r\n\t\t\t\tselectedMonth: parseInt(parts[1], 10),\r\n\t\t\t\tselectedDay: parseInt(parts[2], 10),\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tselectedYear: \"\",\r\n\t\t\tselectedMonth: \"\",\r\n\t\t\tselectedDay: \"\",\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Get display value for a reference field\r\n\t * @param {string} sysId - The sys_id value\r\n\t * @param {string} refTable - The reference table name\r\n\t * @returns {string} Display value or \"Empty\" + field name\r\n\t */\r\n\tgetReferenceLabel: function (sysId, refTable, fieldName) {\r\n\t\tif (!sysId || !refTable) {\r\n\t\t\treturn sysId || \"\";\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tvar gr = new GlideRecord(refTable);\r\n\t\t\tif (gr.get(sysId)) {\r\n\t\t\t\tvar displayValue = gr.getDisplayValue();\r\n\t\t\t\tif (displayValue) {\r\n\t\t\t\t\treturn displayValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// If we can't get the record, return the sys_id\r\n\t\t}\r\n\r\n\t\t// Return \"Empty\" + humanized field name if no display value\r\n\t\tif (fieldName) {\r\n\t\t\tvar words = fieldName.split(\"_\");\r\n\t\t\tvar humanized = [];\r\n\t\t\tfor (var i = 0; i < words.length; i++) {\r\n\t\t\t\tif (words[i]) {\r\n\t\t\t\t\thumanized.push(words[i].charAt(0).toUpperCase() + words[i].slice(1));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"Empty \" + humanized.join(\" \");\r\n\t\t}\r\n\r\n\t\treturn sysId;\r\n\t},\r\n\r\n\t/**\r\n\t * Format currency value\r\n\t * @param {string} value - The currency value\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {string} Formatted currency value\r\n\t */\r\n\tformatCurrencyValue: function (value, operator) {\r\n\t\tif (!value) return value;\r\n\r\n\t\t// Handle javascript expressions for currency\r\n\t\tif (value.indexOf(\"javascript:\") === 0) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Parse and format currency value\r\n\t\tvar numValue = parseFloat(value);\r\n\t\tif (!isNaN(numValue)) {\r\n\t\t\t// Return as formatted string\r\n\t\t\treturn numValue.toString();\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Format duration value\r\n\t * @param {string} value - The duration value\r\n\t * @returns {string} Formatted duration value\r\n\t */\r\n\tformatDurationValue: function (value) {\r\n\t\tif (!value) return value;\r\n\r\n\t\t// If already in the correct format (days hours:minutes:seconds)\r\n\t\tif (value.match(/^\\d+\\s+\\d{1,2}:\\d{2}:\\d{2}$/)) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Try to parse duration in various formats\r\n\t\tvar duration = this.parseDuration(value);\r\n\t\tif (duration) {\r\n\t\t\t// Format as \"days hours:minutes:seconds\"\r\n\t\t\tvar days = duration.durationDays || \"0\";\r\n\t\t\tvar hours = this._padStart(duration.durationHours || \"0\", 2, \"0\");\r\n\t\t\tvar minutes = this._padStart(duration.durationMinutes || \"0\", 2, \"0\");\r\n\t\t\tvar seconds = this._padStart(duration.durationSeconds || \"0\", 2, \"0\");\r\n\r\n\t\t\treturn days + \" \" + hours + \":\" + minutes + \":\" + seconds;\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Parse duration string into components\r\n\t * @param {string} value - The duration value\r\n\t * @returns {Object} Duration object with days, hours, minutes, seconds\r\n\t */\r\n\tparseDuration: function (value) {\r\n\t\tif (!value) return null;\r\n\r\n\t\t// Parse \"days hours:minutes:seconds\" format\r\n\t\tvar match = value.match(/^(\\d+)\\s+(\\d{1,2}):(\\d{2}):(\\d{2})$/);\r\n\t\tif (match) {\r\n\t\t\treturn {\r\n\t\t\t\tdurationDays: match[1],\r\n\t\t\t\tdurationHours: match[2],\r\n\t\t\t\tdurationMinutes: match[3],\r\n\t\t\t\tdurationSeconds: match[4],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Parse ISO 8601 duration format (P1DT2H3M4S)\r\n\t\tmatch = value.match(/^P(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?)?$/);\r\n\t\tif (match) {\r\n\t\t\treturn {\r\n\t\t\t\tdurationDays: match[1] || \"0\",\r\n\t\t\t\tdurationHours: match[2] || \"0\",\r\n\t\t\t\tdurationMinutes: match[3] || \"0\",\r\n\t\t\t\tdurationSeconds: match[4] || \"0\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Parse simple number as days\r\n\t\tif (value.match(/^\\d+$/)) {\r\n\t\t\treturn {\r\n\t\t\t\tdurationDays: value,\r\n\t\t\t\tdurationHours: \"0\",\r\n\t\t\t\tdurationMinutes: \"0\",\r\n\t\t\t\tdurationSeconds: \"0\",\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\t/**\r\n\t * Format date time value\r\n\t * @param {string} value - The date time value\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {string} Formatted date time value\r\n\t */\r\n\tformatDateTimeValue: function (value, operator) {\r\n\t\tif (!value) return value;\r\n\r\n\t\t// Handle special values\r\n\t\tif (value === \"Today\" || value === \"Yesterday\" || value === \"Tomorrow\") {\r\n\t\t\treturn this.handleSpecialDateValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle javascript expressions\r\n\t\tif (value.indexOf(\"javascript:\") === 0) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Handle date with @ separators (for ON operator)\r\n\t\tif (value.indexOf(\"@\") > -1) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Return date value as-is\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Format choice value\r\n\t * @param {string} value - The choice value\r\n\t * @param {string} table - The table name\r\n\t * @param {string} fieldName - The field name\r\n\t * @returns {string} Formatted choice value\r\n\t */\r\n\tformatChoiceValue: function (value, table, fieldName) {\r\n\t\t// Choice values should be kept as-is (the numeric or string value)\r\n\t\treturn value;\r\n\t},\r\n\r\n\t/**\r\n\t * Helper function to pad start of string (polyfill for older JS)\r\n\t * @param {string} str - The string to pad\r\n\t * @param {number} targetLength - Target length\r\n\t * @param {string} padString - String to pad with\r\n\t * @returns {string} Padded string\r\n\t */\r\n\t_padStart: function (str, targetLength, padString) {\r\n\t\tstr = String(str);\r\n\t\ttargetLength = targetLength >> 0;\r\n\t\tpadString = String(padString || \" \");\r\n\t\tif (str.length > targetLength) {\r\n\t\t\treturn str;\r\n\t\t} else {\r\n\t\t\ttargetLength = targetLength - str.length;\r\n\t\t\tif (targetLength > padString.length) {\r\n\t\t\t\tpadString += Array(Math.floor(targetLength / padString.length) + 1).join(padString);\r\n\t\t\t}\r\n\t\t\treturn padString.slice(0, targetLength) + str;\r\n\t\t}\r\n\t},\r\n\r\n\ttype: \"ConditionBuilderUtilsMS\",\r\n};\r\n"
    }
  },
  "sys_class_name": {
    "value": "sys_script_include",
    "display_value": "Script Include"
  },
  "sys_package": {
    "value": "608cd026c374e250d4ddf1db050131bb",
    "display_value": "Tenon - Core"
  },
  "sys_update_name": {
    "value": "sys_script_include_68c01507331322107b18bc534d5c7b5c",
    "display_value": "sys_script_include_68c01507331322107b18bc534d5c7b5c"
  },
  "sys_updated_by": {
    "value": "daniel.cudney",
    "display_value": "daniel.cudney"
  },
  "api_name": {
    "value": "x_cadso_core.ConditionBuilderUtilsMS",
    "display_value": "x_cadso_core.ConditionBuilderUtilsMS"
  },
  "sys_created_on": {
    "value": "2025-08-15 23:48:39",
    "display_value": "2025-08-15 04:48:39 PM"
  },
  "caller_access": {
    "value": "",
    "display_value": null
  },
  "name": {
    "value": "ConditionBuilderUtilsMS",
    "display_value": "ConditionBuilderUtilsMS"
  },
  "sys_name": {
    "value": "ConditionBuilderUtilsMS",
    "display_value": "ConditionBuilderUtilsMS"
  },
  "sys_scope": {
    "value": "608cd026c374e250d4ddf1db050131bb",
    "display_value": "Tenon - Core"
  },
  "sys_created_by": {
    "value": "admin",
    "display_value": "admin"
  },
  "sys_policy": {
    "value": "read",
    "display_value": "Read-only"
  }
}
