{
  "_metadata": {
    "table": "sys_script_include",
    "sys_id": "6512c8efc353a210d4ddf1db0501316a",
    "extracted_at": "2025-09-19T21:48:28.621Z",
    "display_value": "TableMetaData",
    "application": "Tenon_-_Core",
    "scope": {
      "display_value": "Tenon - Core",
      "link": "https://tenonworkstudio.service-now.com/api/now/table/sys_scope/608cd026c374e250d4ddf1db050131bb",
      "value": "608cd026c374e250d4ddf1db050131bb"
    }
  },
  "client_callable": {
    "value": "false",
    "display_value": "false"
  },
  "access": {
    "value": "public",
    "display_value": "All application scopes"
  },
  "mobile_callable": {
    "value": "false",
    "display_value": "false"
  },
  "sys_mod_count": {
    "value": "4",
    "display_value": "4"
  },
  "active": {
    "value": "true",
    "display_value": "true"
  },
  "description": {
    "value": "",
    "display_value": ""
  },
  "sys_updated_on": {
    "value": "2025-08-27 01:22:13",
    "display_value": "2025-08-26 06:22:13 PM"
  },
  "sys_tags": {
    "value": "",
    "display_value": ""
  },
  "sandbox_callable": {
    "value": "true",
    "display_value": "true"
  },
  "script": {
    "value": "const TableMetaData = Class.create();\nTableMetaData.prototype = Object.extendsObject(x_cadso_core.TableMetaDataMS, {\n\tinitialize: function () {\n\t\tx_cadso_core.TableMetaDataMS.prototype.initialize.apply(this, arguments);\n\t\tthis.userAvatars = {};\n\t\tthis.colors = false;\n\t\tthis.language = gs.getSession().getLanguage();\n\t},\n\n\tgetColorsForField: function (field) {\n\t\tif (!this.colors) {\n\t\t\tconst api = new x_cadso_work.GetColorsForFields();\n\t\t\tthis.colors = api.fetch(this.table);\n\t\t}\n\t\treturn field === \"priority\" || field === \"state\";\n\t},\n\n\t/**\n\t * Main entry point for getting table metadata\n\t * @param {string} table - The table name to get metadata for\n\t * @param {boolean} isList - Whether this is for list view (true) or complex filter (false)\n\t * @returns {Array} Array of field metadata objects\n\t */\n\tgetData: function (table, isList) {\n\t\tthis.table = table;\n\t\tconst fields = [];\n\t\tthis.getColorsForField(\"\");\n\n\t\tconst query = this._buildBaseQuery(table);\n\t\tconst fieldChecker = new x_cadso_work.TenonListFIeldsToExclude();\n\n\t\tconst tableFieldsGR = new GlideRecord(\"sys_dictionary\");\n\t\ttableFieldsGR.addEncodedQuery(query);\n\t\ttableFieldsGR.orderBy(\"column_label\");\n\t\ttableFieldsGR.query();\n\n\t\twhile (tableFieldsGR.next()) {\n\t\t\tconst fieldData = this._processFieldData(tableFieldsGR, table, isList, fieldChecker);\n\t\t\tif (fieldData) {\n\t\t\t\tfields.push(fieldData);\n\t\t\t}\n\t\t}\n\n\t\treturn fields;\n\t},\n\n\t/**\n\t * Builds the base query for retrieving table fields\n\t * @private\n\t * @param {string} table - The table name\n\t * @returns {string} The encoded query string\n\t */\n\t_buildBaseQuery: function (table) {\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tif (specialTables.workTables.indexOf(table) > -1) {\n\t\t\treturn `name=${table}^ORname=task^internal_type!=collection^ORinternal_type=NULL^active=true`;\n\t\t} else if (table === \"customer_contact\") {\n\t\t\treturn `name=${table}^ORname=sys_user^internal_type!=collection^internal_type!=integer^ORinternal_type=NULL^active=true`;\n\t\t}\n\n\t\treturn `name=${table}^internal_type!=collection^ORinternal_type=NULL^active=true`;\n\t},\n\n\t/**\n\t * Centralized configuration for special table handling\n\t * @private\n\t * @returns {Object} Configuration object with special table lists\n\t */\n\t_getSpecialTableConfig: function () {\n\t\treturn {\n\t\t\tworkTables: [\n\t\t\t\t\"x_cadso_work_project\",\n\t\t\t\t\"x_cadso_work_campaign\",\n\t\t\t\t\"x_cadso_work_goal\",\n\t\t\t\t\"x_cadso_work_task\",\n\t\t\t\t\"x_cadso_work_sprint\",\n\t\t\t\t\"x_cadso_work_sprint_retro\",\n\t\t\t\t\"sn_customerservice_case\",\n\t\t\t],\n\t\t\tstatusTables: [\"x_cadso_work_status\", \"x_cadso_work_project\", \"x_cadso_work_campaign\"],\n\t\t};\n\t},\n\n\t/**\n\t * Main orchestration function for processing field data\n\t * @private\n\t * @param {GlideRecord} tableFieldsGR - The sys_dictionary GlideRecord\n\t * @param {string} table - The table name\n\t * @param {boolean} isList - Whether this is for list view\n\t * @param {Object} fieldChecker - Field checker utility instance\n\t * @returns {Object|null} Processed field data or null if field should be excluded\n\t */\n\t_processFieldData: function (tableFieldsGR, table, isList, fieldChecker) {\n\t\t// Extract basic field information\n\t\tconst fieldValue = tableFieldsGR.getValue(\"element\");\n\t\tconst fieldType = tableFieldsGR.getValue(\"internal_type\");\n\t\tconst maxLength = tableFieldsGR.getValue(\"max_length\");\n\t\tlet fieldName = tableFieldsGR.getValue(\"column_label\");\n\n\t\t// Get element for type determination\n\t\tconst tableOverridesGR = new GlideRecord(table);\n\t\ttableOverridesGR.orderBy(tableOverridesGR.getDisplayName());\n\t\ttableOverridesGR.setLimit(1);\n\t\tconst element = tableOverridesGR.getElement(fieldValue);\n\n\t\t// Apply field name overrides\n\t\tfieldName = this._processFieldOverrides(fieldName, table, fieldValue);\n\n\t\t// Check field inclusion for list view\n\t\tif (isList) {\n\t\t\tconst fieldValuesToInclude = fieldChecker.fieldValuesToIncludeFromList[table];\n\t\t\tif (!fieldChecker.checkField(fieldValuesToInclude, fieldValue)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Determine actual field type\n\t\tconst actualFieldType = this._determineFieldType(element, fieldType);\n\n\t\t// Parse field attributes\n\t\tconst attributes = this._parseFieldAttributes(tableFieldsGR.getValue(\"attributes\"));\n\n\t\t// Get reference qualifier if applicable\n\t\tconst referenceQualifier = this._getReferenceQualifier(table, fieldValue, fieldType);\n\n\t\t// Check if field can be cleared\n\t\tconst canClearFields = fieldChecker.fieldsThatCanNotBeCleared;\n\t\tconst canClear = !fieldChecker.checkField(canClearFields, fieldValue);\n\n\t\t// Check write permissions\n\t\tconst canWrite = isList ? tableOverridesGR[fieldValue].canWrite() : true; // Complex filter always allows write for filtering\n\n\t\t// Determine if colors should be fetched\n\t\tconst fetchColors = this.getColorsForField(fieldValue);\n\n\t\t// Build field object based on type\n\t\tif (actualFieldType.isChoice) {\n\t\t\treturn this.getChoice({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice: true,\n\t\t\t\tfieldChecker,\n\t\t\t\tfetchColors,\n\t\t\t\tchoices: [],\n\t\t\t\tcanWrite,\n\t\t\t\tcanClear,\n\t\t\t\tmaxLength,\n\t\t\t});\n\t\t} else if (fieldType === \"reference\" || fieldType === \"glide_list\") {\n\t\t\treturn this.getReference({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice: false,\n\t\t\t\tfieldChecker,\n\t\t\t\tfetchColors,\n\t\t\t\ttableReferance: tableFieldsGR.getValue(\"reference\"),\n\t\t\t\tcanWrite,\n\t\t\t\tcanClear,\n\t\t\t\tmaxLength,\n\t\t\t\treferences: [],\n\t\t\t\tchoices: [],\n\t\t\t\tattributesOrderBy: attributes.orderBy,\n\t\t\t\treferenceQualifier,\n\t\t\t\tgroupByField: \"\",\n\t\t\t});\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: fieldType,\n\t\t\t\tname: fieldName,\n\t\t\t\tvalue: fieldValue,\n\t\t\t\tisChoice: false,\n\t\t\t\tchoices: [],\n\t\t\t\tmaxLength,\n\t\t\t\tcanWrite,\n\t\t\t\tcanClear,\n\t\t\t};\n\t\t}\n\t},\n\n\t/**\n\t * Process field name overrides from sys_documentation\n\t * @private\n\t * @param {string} fieldName - Original field name\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @returns {string} Override field name or original\n\t */\n\t_processFieldOverrides: function (fieldName, table, fieldValue) {\n\t\tconst sysDocumentationGR = new GlideRecord(\"sys_documentation\");\n\t\tsysDocumentationGR.addQuery(\"name\", table);\n\t\tsysDocumentationGR.addQuery(\"element\", fieldValue);\n\t\tsysDocumentationGR.addQuery(\"language\", this.language || \"en\");\n\t\tsysDocumentationGR.query();\n\n\t\twhile (sysDocumentationGR.next()) {\n\t\t\tif (sysDocumentationGR.getValue(\"element\") === fieldValue) {\n\t\t\t\tconst overrideName = sysDocumentationGR.getValue(\"label\");\n\t\t\t\tif (fieldName !== overrideName) {\n\t\t\t\t\treturn overrideName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fieldName;\n\t},\n\n\t/**\n\t * Determine the actual field type including choice detection\n\t * @private\n\t * @param {Object} element - GlideElement object\n\t * @param {string} fieldType - Base field type from sys_dictionary\n\t * @returns {Object} Object with isChoice flag and type\n\t */\n\t_determineFieldType: function (element, fieldType) {\n\t\tlet isChoice = false;\n\n\t\tconst edCheck =\n\t\t\telement !== null &&\n\t\t\telement !== \"null\" &&\n\t\t\ttypeof element === \"object\" &&\n\t\t\telement.getED &&\n\t\t\ttypeof element.getED === \"function\";\n\n\t\tif (edCheck) {\n\t\t\tconst elmEd = element.getED();\n\t\t\tisChoice = elmEd.isChoiceTable();\n\t\t}\n\n\t\treturn {\n\t\t\tisChoice,\n\t\t\ttype: fieldType,\n\t\t};\n\t},\n\n\t/**\n\t * Parse field attributes for ordering information\n\t * @private\n\t * @param {string} attributesValuePairs - Comma-separated attribute pairs\n\t * @returns {Object} Parsed attributes object\n\t */\n\t_parseFieldAttributes: function (attributesValuePairs) {\n\t\tconst attributes = {\n\t\t\torderBy: \"\",\n\t\t\trefAcOrderBy: \"\",\n\t\t\trefSequence: \"\",\n\t\t};\n\n\t\tif (attributesValuePairs) {\n\t\t\tconst pairs = attributesValuePairs.split(\",\");\n\t\t\tpairs.forEach((pair) => {\n\t\t\t\tconst [key, value] = pair.split(\"=\");\n\t\t\t\tif (key === \"ref_ac_order_by\") {\n\t\t\t\t\tattributes.refAcOrderBy = value;\n\t\t\t\t} else if (key === \"ref_sequence\") {\n\t\t\t\t\tattributes.refSequence = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tattributes.orderBy =\n\t\t\t\tattributes.refAcOrderBy !== \"\"\n\t\t\t\t\t? attributes.refAcOrderBy\n\t\t\t\t\t: attributes.refSequence !== \"\"\n\t\t\t\t\t? attributes.refSequence\n\t\t\t\t\t: \"\";\n\t\t}\n\n\t\treturn attributes;\n\t},\n\n\t/**\n\t * Get reference qualifier for a field\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @param {string} fieldType - Field type\n\t * @returns {string} Reference qualifier query string\n\t */\n\t_getReferenceQualifier: function (table, fieldValue, fieldType) {\n\t\tif (fieldType !== \"reference\" && fieldType !== \"glide_list\") {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tconst refQualOverRideGR = new GlideRecord(\"sys_dictionary_override\");\n\t\trefQualOverRideGR.addEncodedQuery(`name=${table}^element=${fieldValue}`);\n\t\trefQualOverRideGR.query();\n\n\t\twhile (refQualOverRideGR.next()) {\n\t\t\tif (`${refQualOverRideGR.getValue(\"reference_qual_override\")}` === \"1\") {\n\t\t\t\tconst refQual = refQualOverRideGR.getValue(\"reference_qual\");\n\t\t\t\t// eslint-disable-next-line no-script-url\n\t\t\t\tif (refQual && !refQual.includes(\"javascript:\")) {\n\t\t\t\t\treturn refQual;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn \"\";\n\t},\n\n\tupdateReferenceFieldOptions: function (table, field, queryString, sysId, isList, isBulk, bulkSysIds) {\n\t\tlet bulkAssignedTo = false;\n\t\tif (isBulk && (field.value === \"assigned_to\" || field.value === \"additional_assignee_list\")) {\n\t\t\tbulkAssignedTo = true;\n\t\t}\n\n\t\tif (table) {\n\t\t\tconst query = this._buildReferenceQuery(table, field.value);\n\t\t\tlet referenceQualifier = \"\";\n\t\t\tlet attributesOrderBy = \"\";\n\t\t\tlet tableName = \"\";\n\n\t\t\tconst dictionaryGR = new GlideRecord(\"sys_dictionary\");\n\t\t\tdictionaryGR.addEncodedQuery(query);\n\t\t\tdictionaryGR.orderBy(\"column_label\");\n\t\t\tdictionaryGR.query();\n\n\t\t\twhile (dictionaryGR.next()) {\n\t\t\t\ttableName = dictionaryGR.getDisplayValue(\"column_label\");\n\n\t\t\t\tif (isList === true || (isBulk === true && bulkAssignedTo === false)) {\n\t\t\t\t\treferenceQualifier = this._getCompleteReferenceQualifier(table, field.value, sysId, dictionaryGR);\n\t\t\t\t}\n\n\t\t\t\tconst attributes = this._parseFieldAttributes(dictionaryGR.getValue(\"attributes\"));\n\t\t\t\tattributesOrderBy = attributes.orderBy;\n\t\t\t\tfield.sys_id = sysId;\n\t\t\t}\n\n\t\t\tif (bulkAssignedTo) {\n\t\t\t\treturn this._processBulkAssignedTo(table, field, queryString, bulkSysIds, tableName);\n\t\t\t}\n\n\t\t\treturn this._processReferenceRecords(field, queryString, sysId, referenceQualifier, attributesOrderBy);\n\t\t}\n\t},\n\n\t/**\n\t * Build reference query based on table type\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @returns {string} Encoded query string\n\t */\n\t_buildReferenceQuery: function (table, fieldValue) {\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tif (specialTables.workTables.indexOf(table) > -1 && table !== \"sn_customerservice_case\") {\n\t\t\treturn `name=${table}^ORname=task^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\t} else if (table === \"customer_contact\") {\n\t\t\treturn `name=${table}^ORname=sys_user^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\t}\n\n\t\treturn `name=${table}^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t},\n\n\t/**\n\t * Get complete reference qualifier including overrides and scripts\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @param {string} sysId - Record sys_id\n\t * @param {GlideRecord} dictionaryGR - Dictionary GlideRecord\n\t * @returns {string} Reference qualifier\n\t */\n\t_getCompleteReferenceQualifier: function (table, fieldValue, sysId, dictionaryGR) {\n\t\tconst refQualOverRideGR = new GlideRecord(\"sys_dictionary_override\");\n\t\trefQualOverRideGR.addEncodedQuery(`name=${table}^element=${fieldValue}`);\n\t\trefQualOverRideGR.query();\n\n\t\tif (refQualOverRideGR.next()) {\n\t\t\tif (`${refQualOverRideGR.getValue(\"reference_qual_override\")}` === \"1\") {\n\t\t\t\t// eslint-disable-next-line no-script-url\n\t\t\t\tif (refQualOverRideGR.getValue(\"reference_qual\").includes(\"javascript:\")) {\n\t\t\t\t\treturn this.getRefQualValue(table, fieldValue, sysId);\n\t\t\t\t} else {\n\t\t\t\t\treturn refQualOverRideGR.getValue(\"reference_qual\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dictionaryGR.getValue(\"use_reference_qualifier\") === \"simple\") {\n\t\t\tif (dictionaryGR.getValue(\"reference_qual_condition\")) {\n\t\t\t\treturn dictionaryGR.getValue(\"reference_qual_condition\");\n\t\t\t}\n\t\t} else {\n\t\t\treturn this.getRefQualValue(table, fieldValue, sysId);\n\t\t}\n\n\t\treturn \"\";\n\t},\n\n\t/**\n\t * Process bulk assigned to queries\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {Object} field - Field object\n\t * @param {string} queryString - Query string\n\t * @param {Array} bulkSysIds - Array of sys_ids\n\t * @param {string} tableName - Table display name\n\t * @returns {Object} Updated field object with references\n\t */\n\t_processBulkAssignedTo: function (table, field, queryString, bulkSysIds, tableName) {\n\t\tconst bulkQuery = bulkSysIds.join(\",\");\n\t\tconst groupsArray = [];\n\t\tconst returnUserArr = [];\n\n\t\t// Grab unique assignment groups with glide aggregate from the referring table\n\t\tconst assignmentGA = new GlideAggregate(table);\n\t\tassignmentGA.addAggregate(\"COUNT\");\n\t\tassignmentGA.groupBy(\"assignment_group\");\n\t\tassignmentGA.addQuery(\"sys_id\", \"IN\", bulkQuery);\n\t\tassignmentGA.query();\n\n\t\t// Push unique values to groups array\n\t\twhile (assignmentGA.next()) {\n\t\t\tgroupsArray.push(assignmentGA.getValue(\"assignment_group\"));\n\t\t}\n\n\t\tconst groupsQuery = groupsArray.join(\",\");\n\n\t\t// Query the group members table for assignment groups associated to bulk records\n\t\tconst groupGA = new GlideAggregate(\"sys_user_grmember\");\n\t\tgroupGA.addAggregate(\"COUNT\");\n\t\tgroupGA.groupBy(\"user\");\n\t\tgroupGA.addQuery(\"user.name\", \"CONTAINS\", queryString);\n\t\tgroupGA.addQuery(\"group\", \"IN\", groupsQuery);\n\t\tgroupGA.query();\n\n\t\twhile (groupGA.next()) {\n\t\t\t// Get the count of user records on the group members table\n\t\t\tconst userCount = groupGA.getAggregate(\"COUNT\");\n\n\t\t\t// If a users record count matches the length of unique assignment groups add to return array\n\t\t\tif (userCount >= groupsArray.length) {\n\t\t\t\treturnUserArr.push(groupGA.getValue(\"user\"));\n\t\t\t}\n\t\t}\n\n\t\tlet userQuery = \"\";\n\t\tif (returnUserArr.length > 0) {\n\t\t\tuserQuery = returnUserArr.join(\",\");\n\t\t}\n\n\t\tconst records = this._buildReferenceRecords(field, queryString, userQuery, \"\", \"\", tableName, true);\n\t\tfield.references = records;\n\n\t\treturn field;\n\t},\n\n\t/**\n\t * Process standard reference records\n\t * @private\n\t * @param {Object} field - Field object\n\t * @param {string} queryString - Query string\n\t * @param {string} sysId - Record sys_id\n\t * @param {string} referenceQualifier - Reference qualifier\n\t * @param {string} attributesOrderBy - Order by attribute\n\t * @returns {Object} Updated field object with references\n\t */\n\t_processReferenceRecords: function (field, queryString, sysId, referenceQualifier, attributesOrderBy) {\n\t\tconst records = this._buildReferenceRecords(\n\t\t\tfield,\n\t\t\tqueryString,\n\t\t\t\"\",\n\t\t\treferenceQualifier,\n\t\t\tattributesOrderBy,\n\t\t\t\"\",\n\t\t\tfalse,\n\t\t);\n\t\tfield.references = records;\n\t\treturn field;\n\t},\n\n\t/**\n\t * Build reference records array\n\t * @private\n\t * @param {Object} field - Field object\n\t * @param {string} queryString - Query string\n\t * @param {string} userQuery - User query for bulk operations\n\t * @param {string} referenceQualifier - Reference qualifier\n\t * @param {string} attributesOrderBy - Order by attribute\n\t * @param {string} tableName - Table display name\n\t * @param {boolean} isBulk - Whether this is a bulk operation\n\t * @returns {Array} Array of reference records\n\t */\n\t_buildReferenceRecords: function (\n\t\tfield,\n\t\tqueryString,\n\t\tuserQuery,\n\t\treferenceQualifier,\n\t\tattributesOrderBy,\n\t\ttableName,\n\t\tisBulk,\n\t) {\n\t\tconst records = [];\n\t\tthis.table = field.refTable;\n\t\tconst fetchColors = this.getColorsForField(field.value);\n\t\tconst referenceGR = new GlideRecordSecure(field.refTable);\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tif (isBulk && field.refTable === \"sys_user\") {\n\t\t\treferenceGR.addQuery(\"sys_id\", \"IN\", userQuery);\n\t\t} else if (field.value === \"parent_goals\") {\n\t\t\tconst parentGoalsQuery = this.getRefQualValue(\"x_cadso_work_goal\", field.value, field.referringRecordId);\n\t\t\treferenceGR.addEncodedQuery(parentGoalsQuery);\n\t\t} else {\n\t\t\treferenceGR.addEncodedQuery(`${referenceQualifier}^${referenceGR.getDisplayName()}LIKE${queryString}`);\n\t\t}\n\n\t\tif (attributesOrderBy) {\n\t\t\treferenceGR.orderBy(attributesOrderBy);\n\t\t} else {\n\t\t\treferenceGR.orderBy(referenceGR.getDisplayName());\n\t\t}\n\n\t\treferenceGR.setLimit(12);\n\t\treferenceGR.query();\n\n\t\twhile (referenceGR.next()) {\n\t\t\tconst record = this._createReferenceRecord(\n\t\t\t\treferenceGR,\n\t\t\t\tfield.refTable,\n\t\t\t\ttableName || field.name,\n\t\t\t\tfetchColors,\n\t\t\t\tspecialTables,\n\t\t\t);\n\t\t\trecords.push(record);\n\t\t}\n\n\t\treturn records;\n\t},\n\n\t/**\n\t * Create a single reference record object\n\t * @private\n\t * @param {GlideRecord} referenceGR - Reference GlideRecord\n\t * @param {string} refTable - Reference table name\n\t * @param {string} fieldName - Field display name\n\t * @param {boolean} fetchColors - Whether to fetch colors\n\t * @param {Object} specialTables - Special tables configuration\n\t * @returns {Object} Reference record object\n\t */\n\t_createReferenceRecord: function (referenceGR, refTable, fieldName, fetchColors, specialTables) {\n\t\tconst icon = this.colors.icons[refTable] || false;\n\t\tlet color = \"\";\n\t\tlet className = \"\";\n\n\t\tif (fetchColors) {\n\t\t\tconst colors = this.colors[refTable] && this.colors[refTable][referenceGR.getValue(\"value\")];\n\t\t\tcolor = colors ? colors.color : false;\n\t\t\tclassName = colors ? colors.className : false;\n\t\t}\n\n\t\tlet label = referenceGR.getDisplayValue();\n\t\tif (!label) {\n\t\t\tlabel = `Empty ${fieldName}`;\n\t\t}\n\n\t\tconst record = {\n\t\t\tlabel: label,\n\t\t\tvalue: referenceGR.getValue(\"sys_id\"),\n\t\t\trefTable: refTable,\n\t\t\ticon,\n\t\t\tcolor,\n\t\t\tclassName,\n\t\t};\n\n\t\tif (refTable === \"sys_user\") {\n\t\t\trecord.avatar = this._getCachedAvatar(referenceGR.getValue(\"sys_id\"));\n\t\t} else if (specialTables.statusTables.indexOf(refTable) > -1) {\n\t\t\tconst colorElement = refTable === \"x_cadso_work_status\" ? \"color\" : \"glyph_color\";\n\t\t\trecord.color = referenceGR.getValue(colorElement);\n\t\t}\n\n\t\treturn record;\n\t},\n\n\tgetRefQualValue: function (table, field, sysid) {\n\t\tconst refQualGR = new GlideRecord(\"x_cadso_work_ref_qual_scripts\");\n\t\trefQualGR.addEncodedQuery(`table=${table}^field_name=${field}`);\n\t\trefQualGR.query();\n\n\t\tif (refQualGR.next()) {\n\t\t\tif (refQualGR.record_dependent_fields) {\n\t\t\t\tconst recordFields = refQualGR.getValue(\"record_dependent_fields\");\n\t\t\t\tconst lookupFieldValue = new GlideRecord(table);\n\t\t\t\tlookupFieldValue.addQuery(\"sys_id\", sysid);\n\t\t\t\tlookupFieldValue.query();\n\n\t\t\t\tif (lookupFieldValue.next()) {\n\t\t\t\t\tconst scriptVariable = lookupFieldValue.getValue(recordFields);\n\t\t\t\t\tconst evaluator = new GlideScopedEvaluator();\n\t\t\t\t\tevaluator.putVariable(recordFields, scriptVariable);\n\t\t\t\t\treturn evaluator.evaluateScript(refQualGR, \"u_script\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst evaluator = new GlideScopedEvaluator();\n\t\t\t\treturn evaluator.evaluateScript(refQualGR, \"u_script\");\n\t\t\t}\n\t\t}\n\n\t\treturn \"\";\n\t},\n\n\t_getCachedAvatar: function (userSysId) {\n\t\tif (this.userAvatars[userSysId]) {\n\t\t\treturn this.userAvatars[userSysId];\n\t\t}\n\n\t\tconst sysUserGr = new GlideRecord(\"sys_user\");\n\n\t\tif (sysUserGr.get(userSysId)) {\n\t\t\tconst avatar = sysUserGr.getValue(\"avatar\") || \"\";\n\t\t\tconst photo = sysUserGr.getValue(\"photo\") || \"\";\n\t\t\tconst userAvatar = avatar || photo;\n\t\t\tthis.userAvatars[userSysId] = userAvatar ? `${userAvatar}.iix` : \"\";\n\t\t} else {\n\t\t\tthis.userAvatars[userSysId] = \"\";\n\t\t}\n\n\t\treturn this.userAvatars[userSysId];\n\t},\n\n\tgetChoice: function ({\n\t\tfieldName,\n\t\tfieldValue,\n\t\tfieldType,\n\t\ttable,\n\t\tisChoice,\n\t\tchoices,\n\t\tfetchColors,\n\t\tcanWrite,\n\t\tcanClear,\n\t\tmaxLength,\n\t\tlimitResults = false,\n\t}) {\n\t\tconst icon = this.colors.icons[fieldValue] || false;\n\t\tconst choiceGR = new GlideRecordSecure(\"sys_choice\");\n\t\tchoiceGR.addEncodedQuery(`element=${fieldValue}^name=${table}`);\n\t\tchoiceGR.addQuery(\"inactive=false\");\n\t\tchoiceGR.addQuery(\"language=en\"); // TODO: Allow for multiple languages\n\t\tchoiceGR.orderBy(\"sequence\");\n\t\tchoiceGR.orderBy(\"value\");\n\n\t\tif (limitResults) {\n\t\t\tchoiceGR.setLimit(12);\n\t\t}\n\n\t\tchoiceGR.query();\n\n\t\twhile (choiceGR.next()) {\n\t\t\tconst value = choiceGR.getValue(\"value\");\n\t\t\tlet color = \"\";\n\t\t\tlet className = \"\";\n\n\t\t\tif (fetchColors) {\n\t\t\t\tconst colors = this.colors[fieldValue][value];\n\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t}\n\n\t\t\tchoices.push({\n\t\t\t\tlabel: choiceGR.getValue(\"label\"),\n\t\t\t\tvalue,\n\t\t\t\tcolor,\n\t\t\t\tclassName,\n\t\t\t\ticon,\n\t\t\t});\n\t\t}\n\n\t\t// If no choices found, check task table\n\t\tif (!choices.length) {\n\t\t\tconst taskChoiceGR = new GlideRecordSecure(\"sys_choice\");\n\t\t\ttaskChoiceGR.addEncodedQuery(`element=${fieldValue}^name=task`);\n\t\t\ttaskChoiceGR.addQuery(\"inactive=false\");\n\t\t\ttaskChoiceGR.addQuery(\"language=en\"); // TODO: Allow for multiple languages\n\t\t\ttaskChoiceGR.orderBy(\"sequence\");\n\t\t\ttaskChoiceGR.orderBy(\"value\");\n\t\t\ttaskChoiceGR.query();\n\n\t\t\twhile (taskChoiceGR.next()) {\n\t\t\t\tconst value = taskChoiceGR.getValue(\"value\");\n\t\t\t\tlet color = \"\";\n\t\t\t\tlet className = \"\";\n\n\t\t\t\tif (fetchColors) {\n\t\t\t\t\tconst colors = this.colors[fieldValue][value];\n\t\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t\t}\n\n\t\t\t\tchoices.push({\n\t\t\t\t\tlabel: taskChoiceGR.getValue(\"label\"),\n\t\t\t\t\tvalue,\n\t\t\t\t\tcolor,\n\t\t\t\t\tclassName,\n\t\t\t\t\ticon,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttype: fieldType,\n\t\t\tname: fieldName,\n\t\t\tvalue: fieldValue,\n\t\t\tchoices,\n\t\t\tisChoice,\n\t\t\tmaxLength,\n\t\t\tcanWrite,\n\t\t\tcanClear,\n\t\t};\n\t},\n\n\tgetReference: function ({\n\t\tfieldName,\n\t\tfieldValue,\n\t\tfieldType,\n\t\tisChoice,\n\t\tfetchColors,\n\t\ttableReferance,\n\t\tcanWrite,\n\t\tcanClear,\n\t\tmaxLength,\n\t\treferences,\n\t\tchoices,\n\t\tattributesOrderBy,\n\t\tadditionalFilterQuery = \"\",\n\t\treferenceQualifier = \"\",\n\t\tlimitResults = true,\n\t\tgroupByField = \"\",\n\t}) {\n\t\tconst referenceGR = new GlideRecordSecure(tableReferance);\n\t\tif (limitResults) {\n\t\t\treferenceGR.setLimit(12);\n\t\t}\n\t\tif (referenceQualifier) {\n\t\t\treferenceGR.addEncodedQuery(referenceQualifier);\n\t\t}\n\t\tif (additionalFilterQuery) {\n\t\t\treferenceGR.addEncodedQuery(additionalFilterQuery);\n\t\t}\n\t\tif (attributesOrderBy) {\n\t\t\treferenceGR.orderBy(attributesOrderBy);\n\t\t} else {\n\t\t\treferenceGR.orderBy(referenceGR.getDisplayName());\n\t\t}\n\t\treferenceGR.query();\n\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\twhile (referenceGR.next()) {\n\t\t\tlet data = {};\n\t\t\tlet tempGroupField = {};\n\n\t\t\tif (groupByField) {\n\t\t\t\ttempGroupField.value = referenceGR.getValue(groupByField);\n\t\t\t\ttempGroupField.displayValue = referenceGR.getDisplayValue(groupByField);\n\t\t\t\tif (tempGroupField.value === null || tempGroupField.value === \"null\") {\n\t\t\t\t\ttempGroupField.value = \"\";\n\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t} else if (\n\t\t\t\t\ttempGroupField.displayValue === undefined ||\n\t\t\t\t\ttempGroupField.displayValue === \"\" ||\n\t\t\t\t\ttempGroupField.displayValue === \"undefined\"\n\t\t\t\t) {\n\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst icon = this.colors.icons[tableReferance] || false;\n\t\t\tlet color = \"\";\n\t\t\tlet className = \"\";\n\n\t\t\tif (fetchColors) {\n\t\t\t\tconst colors = this.colors[tableReferance] && this.colors[tableReferance][referenceGR.getValue(\"value\")];\n\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t}\n\n\t\t\tlet label = referenceGR.getDisplayValue();\n\t\t\tif (!label) {\n\t\t\t\tlabel = `Empty ${fieldName}`;\n\t\t\t}\n\n\t\t\tdata = {\n\t\t\t\tlabel: label,\n\t\t\t\tvalue: referenceGR.getValue(\"sys_id\"),\n\t\t\t\trefTable: tableReferance,\n\t\t\t\ticon,\n\t\t\t\tcolor,\n\t\t\t\tclassName,\n\t\t\t};\n\n\t\t\tif (tableReferance === \"sys_user\") {\n\t\t\t\tdata.avatar = this._getCachedAvatar(referenceGR.getValue(\"sys_id\"));\n\t\t\t} else if (specialTables.statusTables.indexOf(tableReferance) > -1) {\n\t\t\t\tconst colorElement = tableReferance === \"x_cadso_work_status\" ? \"color\" : \"glyph_color\";\n\t\t\t\tdata.color = referenceGR.getValue(colorElement);\n\t\t\t}\n\n\t\t\tif (groupByField) {\n\t\t\t\tdata.groupBy = tempGroupField;\n\t\t\t}\n\n\t\t\treferences.push(data);\n\t\t}\n\n\t\treturn {\n\t\t\ttype: fieldType,\n\t\t\tname: fieldName,\n\t\t\tvalue: fieldValue,\n\t\t\treferences,\n\t\t\trefTable: tableReferance,\n\t\t\tisChoice,\n\t\t\tchoices,\n\t\t\tmaxLength,\n\t\t\tcanWrite,\n\t\t\tcanClear,\n\t\t};\n\t},\n\n\tgetAdditionalFilterData: function (additionalFilter) {\n\t\tconst table = additionalFilter.filterTable;\n\t\tthis.table = table;\n\t\tlet fieldValue = additionalFilter.additionalFilterField;\n\t\tlet additionalFilterQuery = \"\";\n\n\t\tif (additionalFilter.customFilterOptions && additionalFilter.customFilterOptions.length) {\n\t\t\tadditionalFilterQuery = additionalFilter.customFilterOptions[0].query;\n\t\t}\n\n\t\tconst groupByField = additionalFilter.groupBy;\n\t\tthis.getColorsForField(\"\");\n\n\t\tconst fieldChecker = new x_cadso_work.TenonListFIeldsToExclude();\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tlet query = `name=${table}^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\tif (specialTables.workTables.indexOf(table) > -1 && table !== \"sn_customerservice_case\") {\n\t\t\tquery = `name=${table}^ORname=task^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\t}\n\n\t\tlet referenceQualifier = \"\";\n\t\tlet attributesOrderBy = \"\";\n\t\tconst choices = [];\n\t\tconst references = [];\n\t\tlet fieldName = \"\";\n\t\tlet fieldType = \"\";\n\t\tlet maxLength = \"\";\n\t\tlet element = \"\";\n\t\tlet tableReferance = \"\";\n\t\tlet isChoice = false;\n\n\t\tconst fetchColors = this.getColorsForField(fieldValue);\n\t\tconst tableOverridesGR = new GlideRecord(table);\n\t\ttableOverridesGR.orderBy(tableOverridesGR.getDisplayName());\n\t\ttableOverridesGR.setLimit(1);\n\t\ttableOverridesGR.query();\n\n\t\twhile (tableOverridesGR.next()) {\n\t\t\tconst tableFieldsGR = new GlideRecord(\"sys_dictionary\");\n\t\t\ttableFieldsGR.addEncodedQuery(query);\n\t\t\ttableFieldsGR.orderBy(\"column_label\");\n\t\t\ttableFieldsGR.query();\n\n\t\t\twhile (tableFieldsGR.next()) {\n\t\t\t\tfieldName = tableFieldsGR.getValue(\"column_label\");\n\t\t\t\tfieldType = tableFieldsGR.getValue(\"internal_type\");\n\t\t\t\tmaxLength = tableFieldsGR.getValue(\"max_length\");\n\t\t\t\telement = tableOverridesGR.getElement(fieldValue);\n\t\t\t\ttableReferance = tableFieldsGR.getValue(\"reference\");\n\n\t\t\t\t// Check the overrides for the refQual\n\t\t\t\treferenceQualifier = this._getReferenceQualifier(table, fieldValue, \"reference\");\n\n\t\t\t\t// Parse attributes\n\t\t\t\tconst attributes = this._parseFieldAttributes(tableFieldsGR.getValue(\"attributes\"));\n\t\t\t\tattributesOrderBy = attributes.orderBy;\n\n\t\t\t\tlet fieldOverrideLabel = fieldName;\n\t\t\t\tif (element) {\n\t\t\t\t\tfieldOverrideLabel = element.getLabel();\n\t\t\t\t}\n\t\t\t\tfieldName = fieldOverrideLabel;\n\n\t\t\t\t// Determine field type\n\t\t\t\tconst fieldTypeInfo = this._determineFieldType(element, fieldType);\n\t\t\t\tisChoice = fieldTypeInfo.isChoice;\n\t\t\t}\n\t\t}\n\n\t\tif (fieldType !== \"reference\" && fieldType !== \"choice\") {\n\t\t\tconst additionalFilterGR = new GlideRecord(table);\n\t\t\tif (fieldValue) {\n\t\t\t\tadditionalFilterGR.orderBy(fieldValue);\n\t\t\t}\n\t\t\tadditionalFilterGR.query();\n\n\t\t\twhile (additionalFilterGR.next()) {\n\t\t\t\tif (!fieldValue) {\n\t\t\t\t\tfieldValue = additionalFilterGR.getDisplayName();\n\t\t\t\t}\n\n\t\t\t\tlet label = additionalFilterGR.getDisplayValue();\n\t\t\t\tif (!label) {\n\t\t\t\t\tlabel = `Empty ${fieldName}`;\n\t\t\t\t}\n\n\t\t\t\tconst icon = this.colors.icons[tableReferance] || false;\n\t\t\t\tlet color = \"\";\n\t\t\t\tlet className = \"\";\n\n\t\t\t\tif (fetchColors) {\n\t\t\t\t\tconst colors = this.colors[fieldValue] && this.colors[fieldValue][additionalFilterGR.getValue(\"value\")];\n\t\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t\t}\n\n\t\t\t\tconst data = {\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tvalue: additionalFilterGR.getValue(\"sys_id\"),\n\t\t\t\t\ticon,\n\t\t\t\t\tcolor,\n\t\t\t\t\tclassName,\n\t\t\t\t};\n\n\t\t\t\tif (groupByField) {\n\t\t\t\t\tconst tempGroupField = {};\n\t\t\t\t\ttempGroupField.value = additionalFilterGR.getValue(groupByField);\n\t\t\t\t\ttempGroupField.displayValue = additionalFilterGR.getDisplayValue(groupByField);\n\n\t\t\t\t\tif (tempGroupField.value === null || tempGroupField.value === \"null\") {\n\t\t\t\t\t\ttempGroupField.value = \"\";\n\t\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t\t} else if (\n\t\t\t\t\t\ttempGroupField.displayValue === undefined ||\n\t\t\t\t\t\ttempGroupField.displayValue === \"\" ||\n\t\t\t\t\t\ttempGroupField.displayValue === \"undefined\"\n\t\t\t\t\t) {\n\t\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t\t}\n\t\t\t\t\tdata.groupBy = tempGroupField;\n\t\t\t\t}\n\t\t\t\treferences.push(data);\n\t\t\t}\n\n\t\t\tadditionalFilter.fieldData = {\n\t\t\t\ttype: fieldType,\n\t\t\t\tname: fieldName,\n\t\t\t\tvalue: fieldValue,\n\t\t\t\treferences,\n\t\t\t\trefTable: tableReferance,\n\t\t\t\tisChoice,\n\t\t\t\tchoices,\n\t\t\t\tmaxLength,\n\t\t\t\tcanWrite: false,\n\t\t\t\tcanClear: false,\n\t\t\t};\n\t\t} else if (fieldType === \"reference\") {\n\t\t\tadditionalFilter.fieldData = this.getReference({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice,\n\t\t\t\tfieldChecker,\n\t\t\t\tfetchColors,\n\t\t\t\ttableReferance,\n\t\t\t\tcanWrite: tableOverridesGR[fieldValue].canWrite(),\n\t\t\t\tcanClear: false,\n\t\t\t\tmaxLength,\n\t\t\t\treferences,\n\t\t\t\tchoices,\n\t\t\t\tattributesOrderBy,\n\t\t\t\treferenceQualifier,\n\t\t\t\tlimitResults: false,\n\t\t\t\tgroupByField,\n\t\t\t\tadditionalFilterQuery,\n\t\t\t});\n\t\t} else if (fieldType === \"choice\") {\n\t\t\tadditionalFilter.fieldData = this.getChoice({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice,\n\t\t\t\tfetchColors,\n\t\t\t\tchoices,\n\t\t\t\tcanWrite: tableOverridesGR[fieldValue].canWrite(),\n\t\t\t\tcanClear: false,\n\t\t\t\tmaxLength,\n\t\t\t\tlimitResults: false,\n\t\t\t});\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn additionalFilter;\n\t},\n\n\ttype: \"TableMetaData\",\n});\n",
    "display_value": "const TableMetaData = Class.create();\nTableMetaData.prototype = Object.extendsObject(x_cadso_core.TableMetaDataMS, {\n\tinitialize: function () {\n\t\tx_cadso_core.TableMetaDataMS.prototype.initialize.apply(this, arguments);\n\t\tthis.userAvatars = {};\n\t\tthis.colors = false;\n\t\tthis.language = gs.getSession().getLanguage();\n\t},\n\n\tgetColorsForField: function (field) {\n\t\tif (!this.colors) {\n\t\t\tconst api = new x_cadso_work.GetColorsForFields();\n\t\t\tthis.colors = api.fetch(this.table);\n\t\t}\n\t\treturn field === \"priority\" || field === \"state\";\n\t},\n\n\t/**\n\t * Main entry point for getting table metadata\n\t * @param {string} table - The table name to get metadata for\n\t * @param {boolean} isList - Whether this is for list view (true) or complex filter (false)\n\t * @returns {Array} Array of field metadata objects\n\t */\n\tgetData: function (table, isList) {\n\t\tthis.table = table;\n\t\tconst fields = [];\n\t\tthis.getColorsForField(\"\");\n\n\t\tconst query = this._buildBaseQuery(table);\n\t\tconst fieldChecker = new x_cadso_work.TenonListFIeldsToExclude();\n\n\t\tconst tableFieldsGR = new GlideRecord(\"sys_dictionary\");\n\t\ttableFieldsGR.addEncodedQuery(query);\n\t\ttableFieldsGR.orderBy(\"column_label\");\n\t\ttableFieldsGR.query();\n\n\t\twhile (tableFieldsGR.next()) {\n\t\t\tconst fieldData = this._processFieldData(tableFieldsGR, table, isList, fieldChecker);\n\t\t\tif (fieldData) {\n\t\t\t\tfields.push(fieldData);\n\t\t\t}\n\t\t}\n\n\t\treturn fields;\n\t},\n\n\t/**\n\t * Builds the base query for retrieving table fields\n\t * @private\n\t * @param {string} table - The table name\n\t * @returns {string} The encoded query string\n\t */\n\t_buildBaseQuery: function (table) {\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tif (specialTables.workTables.indexOf(table) > -1) {\n\t\t\treturn `name=${table}^ORname=task^internal_type!=collection^ORinternal_type=NULL^active=true`;\n\t\t} else if (table === \"customer_contact\") {\n\t\t\treturn `name=${table}^ORname=sys_user^internal_type!=collection^internal_type!=integer^ORinternal_type=NULL^active=true`;\n\t\t}\n\n\t\treturn `name=${table}^internal_type!=collection^ORinternal_type=NULL^active=true`;\n\t},\n\n\t/**\n\t * Centralized configuration for special table handling\n\t * @private\n\t * @returns {Object} Configuration object with special table lists\n\t */\n\t_getSpecialTableConfig: function () {\n\t\treturn {\n\t\t\tworkTables: [\n\t\t\t\t\"x_cadso_work_project\",\n\t\t\t\t\"x_cadso_work_campaign\",\n\t\t\t\t\"x_cadso_work_goal\",\n\t\t\t\t\"x_cadso_work_task\",\n\t\t\t\t\"x_cadso_work_sprint\",\n\t\t\t\t\"x_cadso_work_sprint_retro\",\n\t\t\t\t\"sn_customerservice_case\",\n\t\t\t],\n\t\t\tstatusTables: [\"x_cadso_work_status\", \"x_cadso_work_project\", \"x_cadso_work_campaign\"],\n\t\t};\n\t},\n\n\t/**\n\t * Main orchestration function for processing field data\n\t * @private\n\t * @param {GlideRecord} tableFieldsGR - The sys_dictionary GlideRecord\n\t * @param {string} table - The table name\n\t * @param {boolean} isList - Whether this is for list view\n\t * @param {Object} fieldChecker - Field checker utility instance\n\t * @returns {Object|null} Processed field data or null if field should be excluded\n\t */\n\t_processFieldData: function (tableFieldsGR, table, isList, fieldChecker) {\n\t\t// Extract basic field information\n\t\tconst fieldValue = tableFieldsGR.getValue(\"element\");\n\t\tconst fieldType = tableFieldsGR.getValue(\"internal_type\");\n\t\tconst maxLength = tableFieldsGR.getValue(\"max_length\");\n\t\tlet fieldName = tableFieldsGR.getValue(\"column_label\");\n\n\t\t// Get element for type determination\n\t\tconst tableOverridesGR = new GlideRecord(table);\n\t\ttableOverridesGR.orderBy(tableOverridesGR.getDisplayName());\n\t\ttableOverridesGR.setLimit(1);\n\t\tconst element = tableOverridesGR.getElement(fieldValue);\n\n\t\t// Apply field name overrides\n\t\tfieldName = this._processFieldOverrides(fieldName, table, fieldValue);\n\n\t\t// Check field inclusion for list view\n\t\tif (isList) {\n\t\t\tconst fieldValuesToInclude = fieldChecker.fieldValuesToIncludeFromList[table];\n\t\t\tif (!fieldChecker.checkField(fieldValuesToInclude, fieldValue)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Determine actual field type\n\t\tconst actualFieldType = this._determineFieldType(element, fieldType);\n\n\t\t// Parse field attributes\n\t\tconst attributes = this._parseFieldAttributes(tableFieldsGR.getValue(\"attributes\"));\n\n\t\t// Get reference qualifier if applicable\n\t\tconst referenceQualifier = this._getReferenceQualifier(table, fieldValue, fieldType);\n\n\t\t// Check if field can be cleared\n\t\tconst canClearFields = fieldChecker.fieldsThatCanNotBeCleared;\n\t\tconst canClear = !fieldChecker.checkField(canClearFields, fieldValue);\n\n\t\t// Check write permissions\n\t\tconst canWrite = isList ? tableOverridesGR[fieldValue].canWrite() : true; // Complex filter always allows write for filtering\n\n\t\t// Determine if colors should be fetched\n\t\tconst fetchColors = this.getColorsForField(fieldValue);\n\n\t\t// Build field object based on type\n\t\tif (actualFieldType.isChoice) {\n\t\t\treturn this.getChoice({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice: true,\n\t\t\t\tfieldChecker,\n\t\t\t\tfetchColors,\n\t\t\t\tchoices: [],\n\t\t\t\tcanWrite,\n\t\t\t\tcanClear,\n\t\t\t\tmaxLength,\n\t\t\t});\n\t\t} else if (fieldType === \"reference\" || fieldType === \"glide_list\") {\n\t\t\treturn this.getReference({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice: false,\n\t\t\t\tfieldChecker,\n\t\t\t\tfetchColors,\n\t\t\t\ttableReferance: tableFieldsGR.getValue(\"reference\"),\n\t\t\t\tcanWrite,\n\t\t\t\tcanClear,\n\t\t\t\tmaxLength,\n\t\t\t\treferences: [],\n\t\t\t\tchoices: [],\n\t\t\t\tattributesOrderBy: attributes.orderBy,\n\t\t\t\treferenceQualifier,\n\t\t\t\tgroupByField: \"\",\n\t\t\t});\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: fieldType,\n\t\t\t\tname: fieldName,\n\t\t\t\tvalue: fieldValue,\n\t\t\t\tisChoice: false,\n\t\t\t\tchoices: [],\n\t\t\t\tmaxLength,\n\t\t\t\tcanWrite,\n\t\t\t\tcanClear,\n\t\t\t};\n\t\t}\n\t},\n\n\t/**\n\t * Process field name overrides from sys_documentation\n\t * @private\n\t * @param {string} fieldName - Original field name\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @returns {string} Override field name or original\n\t */\n\t_processFieldOverrides: function (fieldName, table, fieldValue) {\n\t\tconst sysDocumentationGR = new GlideRecord(\"sys_documentation\");\n\t\tsysDocumentationGR.addQuery(\"name\", table);\n\t\tsysDocumentationGR.addQuery(\"element\", fieldValue);\n\t\tsysDocumentationGR.addQuery(\"language\", this.language || \"en\");\n\t\tsysDocumentationGR.query();\n\n\t\twhile (sysDocumentationGR.next()) {\n\t\t\tif (sysDocumentationGR.getValue(\"element\") === fieldValue) {\n\t\t\t\tconst overrideName = sysDocumentationGR.getValue(\"label\");\n\t\t\t\tif (fieldName !== overrideName) {\n\t\t\t\t\treturn overrideName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fieldName;\n\t},\n\n\t/**\n\t * Determine the actual field type including choice detection\n\t * @private\n\t * @param {Object} element - GlideElement object\n\t * @param {string} fieldType - Base field type from sys_dictionary\n\t * @returns {Object} Object with isChoice flag and type\n\t */\n\t_determineFieldType: function (element, fieldType) {\n\t\tlet isChoice = false;\n\n\t\tconst edCheck =\n\t\t\telement !== null &&\n\t\t\telement !== \"null\" &&\n\t\t\ttypeof element === \"object\" &&\n\t\t\telement.getED &&\n\t\t\ttypeof element.getED === \"function\";\n\n\t\tif (edCheck) {\n\t\t\tconst elmEd = element.getED();\n\t\t\tisChoice = elmEd.isChoiceTable();\n\t\t}\n\n\t\treturn {\n\t\t\tisChoice,\n\t\t\ttype: fieldType,\n\t\t};\n\t},\n\n\t/**\n\t * Parse field attributes for ordering information\n\t * @private\n\t * @param {string} attributesValuePairs - Comma-separated attribute pairs\n\t * @returns {Object} Parsed attributes object\n\t */\n\t_parseFieldAttributes: function (attributesValuePairs) {\n\t\tconst attributes = {\n\t\t\torderBy: \"\",\n\t\t\trefAcOrderBy: \"\",\n\t\t\trefSequence: \"\",\n\t\t};\n\n\t\tif (attributesValuePairs) {\n\t\t\tconst pairs = attributesValuePairs.split(\",\");\n\t\t\tpairs.forEach((pair) => {\n\t\t\t\tconst [key, value] = pair.split(\"=\");\n\t\t\t\tif (key === \"ref_ac_order_by\") {\n\t\t\t\t\tattributes.refAcOrderBy = value;\n\t\t\t\t} else if (key === \"ref_sequence\") {\n\t\t\t\t\tattributes.refSequence = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tattributes.orderBy =\n\t\t\t\tattributes.refAcOrderBy !== \"\"\n\t\t\t\t\t? attributes.refAcOrderBy\n\t\t\t\t\t: attributes.refSequence !== \"\"\n\t\t\t\t\t? attributes.refSequence\n\t\t\t\t\t: \"\";\n\t\t}\n\n\t\treturn attributes;\n\t},\n\n\t/**\n\t * Get reference qualifier for a field\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @param {string} fieldType - Field type\n\t * @returns {string} Reference qualifier query string\n\t */\n\t_getReferenceQualifier: function (table, fieldValue, fieldType) {\n\t\tif (fieldType !== \"reference\" && fieldType !== \"glide_list\") {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tconst refQualOverRideGR = new GlideRecord(\"sys_dictionary_override\");\n\t\trefQualOverRideGR.addEncodedQuery(`name=${table}^element=${fieldValue}`);\n\t\trefQualOverRideGR.query();\n\n\t\twhile (refQualOverRideGR.next()) {\n\t\t\tif (`${refQualOverRideGR.getValue(\"reference_qual_override\")}` === \"1\") {\n\t\t\t\tconst refQual = refQualOverRideGR.getValue(\"reference_qual\");\n\t\t\t\t// eslint-disable-next-line no-script-url\n\t\t\t\tif (refQual && !refQual.includes(\"javascript:\")) {\n\t\t\t\t\treturn refQual;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn \"\";\n\t},\n\n\tupdateReferenceFieldOptions: function (table, field, queryString, sysId, isList, isBulk, bulkSysIds) {\n\t\tlet bulkAssignedTo = false;\n\t\tif (isBulk && (field.value === \"assigned_to\" || field.value === \"additional_assignee_list\")) {\n\t\t\tbulkAssignedTo = true;\n\t\t}\n\n\t\tif (table) {\n\t\t\tconst query = this._buildReferenceQuery(table, field.value);\n\t\t\tlet referenceQualifier = \"\";\n\t\t\tlet attributesOrderBy = \"\";\n\t\t\tlet tableName = \"\";\n\n\t\t\tconst dictionaryGR = new GlideRecord(\"sys_dictionary\");\n\t\t\tdictionaryGR.addEncodedQuery(query);\n\t\t\tdictionaryGR.orderBy(\"column_label\");\n\t\t\tdictionaryGR.query();\n\n\t\t\twhile (dictionaryGR.next()) {\n\t\t\t\ttableName = dictionaryGR.getDisplayValue(\"column_label\");\n\n\t\t\t\tif (isList === true || (isBulk === true && bulkAssignedTo === false)) {\n\t\t\t\t\treferenceQualifier = this._getCompleteReferenceQualifier(table, field.value, sysId, dictionaryGR);\n\t\t\t\t}\n\n\t\t\t\tconst attributes = this._parseFieldAttributes(dictionaryGR.getValue(\"attributes\"));\n\t\t\t\tattributesOrderBy = attributes.orderBy;\n\t\t\t\tfield.sys_id = sysId;\n\t\t\t}\n\n\t\t\tif (bulkAssignedTo) {\n\t\t\t\treturn this._processBulkAssignedTo(table, field, queryString, bulkSysIds, tableName);\n\t\t\t}\n\n\t\t\treturn this._processReferenceRecords(field, queryString, sysId, referenceQualifier, attributesOrderBy);\n\t\t}\n\t},\n\n\t/**\n\t * Build reference query based on table type\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @returns {string} Encoded query string\n\t */\n\t_buildReferenceQuery: function (table, fieldValue) {\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tif (specialTables.workTables.indexOf(table) > -1 && table !== \"sn_customerservice_case\") {\n\t\t\treturn `name=${table}^ORname=task^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\t} else if (table === \"customer_contact\") {\n\t\t\treturn `name=${table}^ORname=sys_user^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\t}\n\n\t\treturn `name=${table}^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t},\n\n\t/**\n\t * Get complete reference qualifier including overrides and scripts\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @param {string} sysId - Record sys_id\n\t * @param {GlideRecord} dictionaryGR - Dictionary GlideRecord\n\t * @returns {string} Reference qualifier\n\t */\n\t_getCompleteReferenceQualifier: function (table, fieldValue, sysId, dictionaryGR) {\n\t\tconst refQualOverRideGR = new GlideRecord(\"sys_dictionary_override\");\n\t\trefQualOverRideGR.addEncodedQuery(`name=${table}^element=${fieldValue}`);\n\t\trefQualOverRideGR.query();\n\n\t\tif (refQualOverRideGR.next()) {\n\t\t\tif (`${refQualOverRideGR.getValue(\"reference_qual_override\")}` === \"1\") {\n\t\t\t\t// eslint-disable-next-line no-script-url\n\t\t\t\tif (refQualOverRideGR.getValue(\"reference_qual\").includes(\"javascript:\")) {\n\t\t\t\t\treturn this.getRefQualValue(table, fieldValue, sysId);\n\t\t\t\t} else {\n\t\t\t\t\treturn refQualOverRideGR.getValue(\"reference_qual\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dictionaryGR.getValue(\"use_reference_qualifier\") === \"simple\") {\n\t\t\tif (dictionaryGR.getValue(\"reference_qual_condition\")) {\n\t\t\t\treturn dictionaryGR.getValue(\"reference_qual_condition\");\n\t\t\t}\n\t\t} else {\n\t\t\treturn this.getRefQualValue(table, fieldValue, sysId);\n\t\t}\n\n\t\treturn \"\";\n\t},\n\n\t/**\n\t * Process bulk assigned to queries\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {Object} field - Field object\n\t * @param {string} queryString - Query string\n\t * @param {Array} bulkSysIds - Array of sys_ids\n\t * @param {string} tableName - Table display name\n\t * @returns {Object} Updated field object with references\n\t */\n\t_processBulkAssignedTo: function (table, field, queryString, bulkSysIds, tableName) {\n\t\tconst bulkQuery = bulkSysIds.join(\",\");\n\t\tconst groupsArray = [];\n\t\tconst returnUserArr = [];\n\n\t\t// Grab unique assignment groups with glide aggregate from the referring table\n\t\tconst assignmentGA = new GlideAggregate(table);\n\t\tassignmentGA.addAggregate(\"COUNT\");\n\t\tassignmentGA.groupBy(\"assignment_group\");\n\t\tassignmentGA.addQuery(\"sys_id\", \"IN\", bulkQuery);\n\t\tassignmentGA.query();\n\n\t\t// Push unique values to groups array\n\t\twhile (assignmentGA.next()) {\n\t\t\tgroupsArray.push(assignmentGA.getValue(\"assignment_group\"));\n\t\t}\n\n\t\tconst groupsQuery = groupsArray.join(\",\");\n\n\t\t// Query the group members table for assignment groups associated to bulk records\n\t\tconst groupGA = new GlideAggregate(\"sys_user_grmember\");\n\t\tgroupGA.addAggregate(\"COUNT\");\n\t\tgroupGA.groupBy(\"user\");\n\t\tgroupGA.addQuery(\"user.name\", \"CONTAINS\", queryString);\n\t\tgroupGA.addQuery(\"group\", \"IN\", groupsQuery);\n\t\tgroupGA.query();\n\n\t\twhile (groupGA.next()) {\n\t\t\t// Get the count of user records on the group members table\n\t\t\tconst userCount = groupGA.getAggregate(\"COUNT\");\n\n\t\t\t// If a users record count matches the length of unique assignment groups add to return array\n\t\t\tif (userCount >= groupsArray.length) {\n\t\t\t\treturnUserArr.push(groupGA.getValue(\"user\"));\n\t\t\t}\n\t\t}\n\n\t\tlet userQuery = \"\";\n\t\tif (returnUserArr.length > 0) {\n\t\t\tuserQuery = returnUserArr.join(\",\");\n\t\t}\n\n\t\tconst records = this._buildReferenceRecords(field, queryString, userQuery, \"\", \"\", tableName, true);\n\t\tfield.references = records;\n\n\t\treturn field;\n\t},\n\n\t/**\n\t * Process standard reference records\n\t * @private\n\t * @param {Object} field - Field object\n\t * @param {string} queryString - Query string\n\t * @param {string} sysId - Record sys_id\n\t * @param {string} referenceQualifier - Reference qualifier\n\t * @param {string} attributesOrderBy - Order by attribute\n\t * @returns {Object} Updated field object with references\n\t */\n\t_processReferenceRecords: function (field, queryString, sysId, referenceQualifier, attributesOrderBy) {\n\t\tconst records = this._buildReferenceRecords(\n\t\t\tfield,\n\t\t\tqueryString,\n\t\t\t\"\",\n\t\t\treferenceQualifier,\n\t\t\tattributesOrderBy,\n\t\t\t\"\",\n\t\t\tfalse,\n\t\t);\n\t\tfield.references = records;\n\t\treturn field;\n\t},\n\n\t/**\n\t * Build reference records array\n\t * @private\n\t * @param {Object} field - Field object\n\t * @param {string} queryString - Query string\n\t * @param {string} userQuery - User query for bulk operations\n\t * @param {string} referenceQualifier - Reference qualifier\n\t * @param {string} attributesOrderBy - Order by attribute\n\t * @param {string} tableName - Table display name\n\t * @param {boolean} isBulk - Whether this is a bulk operation\n\t * @returns {Array} Array of reference records\n\t */\n\t_buildReferenceRecords: function (\n\t\tfield,\n\t\tqueryString,\n\t\tuserQuery,\n\t\treferenceQualifier,\n\t\tattributesOrderBy,\n\t\ttableName,\n\t\tisBulk,\n\t) {\n\t\tconst records = [];\n\t\tthis.table = field.refTable;\n\t\tconst fetchColors = this.getColorsForField(field.value);\n\t\tconst referenceGR = new GlideRecordSecure(field.refTable);\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tif (isBulk && field.refTable === \"sys_user\") {\n\t\t\treferenceGR.addQuery(\"sys_id\", \"IN\", userQuery);\n\t\t} else if (field.value === \"parent_goals\") {\n\t\t\tconst parentGoalsQuery = this.getRefQualValue(\"x_cadso_work_goal\", field.value, field.referringRecordId);\n\t\t\treferenceGR.addEncodedQuery(parentGoalsQuery);\n\t\t} else {\n\t\t\treferenceGR.addEncodedQuery(`${referenceQualifier}^${referenceGR.getDisplayName()}LIKE${queryString}`);\n\t\t}\n\n\t\tif (attributesOrderBy) {\n\t\t\treferenceGR.orderBy(attributesOrderBy);\n\t\t} else {\n\t\t\treferenceGR.orderBy(referenceGR.getDisplayName());\n\t\t}\n\n\t\treferenceGR.setLimit(12);\n\t\treferenceGR.query();\n\n\t\twhile (referenceGR.next()) {\n\t\t\tconst record = this._createReferenceRecord(\n\t\t\t\treferenceGR,\n\t\t\t\tfield.refTable,\n\t\t\t\ttableName || field.name,\n\t\t\t\tfetchColors,\n\t\t\t\tspecialTables,\n\t\t\t);\n\t\t\trecords.push(record);\n\t\t}\n\n\t\treturn records;\n\t},\n\n\t/**\n\t * Create a single reference record object\n\t * @private\n\t * @param {GlideRecord} referenceGR - Reference GlideRecord\n\t * @param {string} refTable - Reference table name\n\t * @param {string} fieldName - Field display name\n\t * @param {boolean} fetchColors - Whether to fetch colors\n\t * @param {Object} specialTables - Special tables configuration\n\t * @returns {Object} Reference record object\n\t */\n\t_createReferenceRecord: function (referenceGR, refTable, fieldName, fetchColors, specialTables) {\n\t\tconst icon = this.colors.icons[refTable] || false;\n\t\tlet color = \"\";\n\t\tlet className = \"\";\n\n\t\tif (fetchColors) {\n\t\t\tconst colors = this.colors[refTable] && this.colors[refTable][referenceGR.getValue(\"value\")];\n\t\t\tcolor = colors ? colors.color : false;\n\t\t\tclassName = colors ? colors.className : false;\n\t\t}\n\n\t\tlet label = referenceGR.getDisplayValue();\n\t\tif (!label) {\n\t\t\tlabel = `Empty ${fieldName}`;\n\t\t}\n\n\t\tconst record = {\n\t\t\tlabel: label,\n\t\t\tvalue: referenceGR.getValue(\"sys_id\"),\n\t\t\trefTable: refTable,\n\t\t\ticon,\n\t\t\tcolor,\n\t\t\tclassName,\n\t\t};\n\n\t\tif (refTable === \"sys_user\") {\n\t\t\trecord.avatar = this._getCachedAvatar(referenceGR.getValue(\"sys_id\"));\n\t\t} else if (specialTables.statusTables.indexOf(refTable) > -1) {\n\t\t\tconst colorElement = refTable === \"x_cadso_work_status\" ? \"color\" : \"glyph_color\";\n\t\t\trecord.color = referenceGR.getValue(colorElement);\n\t\t}\n\n\t\treturn record;\n\t},\n\n\tgetRefQualValue: function (table, field, sysid) {\n\t\tconst refQualGR = new GlideRecord(\"x_cadso_work_ref_qual_scripts\");\n\t\trefQualGR.addEncodedQuery(`table=${table}^field_name=${field}`);\n\t\trefQualGR.query();\n\n\t\tif (refQualGR.next()) {\n\t\t\tif (refQualGR.record_dependent_fields) {\n\t\t\t\tconst recordFields = refQualGR.getValue(\"record_dependent_fields\");\n\t\t\t\tconst lookupFieldValue = new GlideRecord(table);\n\t\t\t\tlookupFieldValue.addQuery(\"sys_id\", sysid);\n\t\t\t\tlookupFieldValue.query();\n\n\t\t\t\tif (lookupFieldValue.next()) {\n\t\t\t\t\tconst scriptVariable = lookupFieldValue.getValue(recordFields);\n\t\t\t\t\tconst evaluator = new GlideScopedEvaluator();\n\t\t\t\t\tevaluator.putVariable(recordFields, scriptVariable);\n\t\t\t\t\treturn evaluator.evaluateScript(refQualGR, \"u_script\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst evaluator = new GlideScopedEvaluator();\n\t\t\t\treturn evaluator.evaluateScript(refQualGR, \"u_script\");\n\t\t\t}\n\t\t}\n\n\t\treturn \"\";\n\t},\n\n\t_getCachedAvatar: function (userSysId) {\n\t\tif (this.userAvatars[userSysId]) {\n\t\t\treturn this.userAvatars[userSysId];\n\t\t}\n\n\t\tconst sysUserGr = new GlideRecord(\"sys_user\");\n\n\t\tif (sysUserGr.get(userSysId)) {\n\t\t\tconst avatar = sysUserGr.getValue(\"avatar\") || \"\";\n\t\t\tconst photo = sysUserGr.getValue(\"photo\") || \"\";\n\t\t\tconst userAvatar = avatar || photo;\n\t\t\tthis.userAvatars[userSysId] = userAvatar ? `${userAvatar}.iix` : \"\";\n\t\t} else {\n\t\t\tthis.userAvatars[userSysId] = \"\";\n\t\t}\n\n\t\treturn this.userAvatars[userSysId];\n\t},\n\n\tgetChoice: function ({\n\t\tfieldName,\n\t\tfieldValue,\n\t\tfieldType,\n\t\ttable,\n\t\tisChoice,\n\t\tchoices,\n\t\tfetchColors,\n\t\tcanWrite,\n\t\tcanClear,\n\t\tmaxLength,\n\t\tlimitResults = false,\n\t}) {\n\t\tconst icon = this.colors.icons[fieldValue] || false;\n\t\tconst choiceGR = new GlideRecordSecure(\"sys_choice\");\n\t\tchoiceGR.addEncodedQuery(`element=${fieldValue}^name=${table}`);\n\t\tchoiceGR.addQuery(\"inactive=false\");\n\t\tchoiceGR.addQuery(\"language=en\"); // TODO: Allow for multiple languages\n\t\tchoiceGR.orderBy(\"sequence\");\n\t\tchoiceGR.orderBy(\"value\");\n\n\t\tif (limitResults) {\n\t\t\tchoiceGR.setLimit(12);\n\t\t}\n\n\t\tchoiceGR.query();\n\n\t\twhile (choiceGR.next()) {\n\t\t\tconst value = choiceGR.getValue(\"value\");\n\t\t\tlet color = \"\";\n\t\t\tlet className = \"\";\n\n\t\t\tif (fetchColors) {\n\t\t\t\tconst colors = this.colors[fieldValue][value];\n\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t}\n\n\t\t\tchoices.push({\n\t\t\t\tlabel: choiceGR.getValue(\"label\"),\n\t\t\t\tvalue,\n\t\t\t\tcolor,\n\t\t\t\tclassName,\n\t\t\t\ticon,\n\t\t\t});\n\t\t}\n\n\t\t// If no choices found, check task table\n\t\tif (!choices.length) {\n\t\t\tconst taskChoiceGR = new GlideRecordSecure(\"sys_choice\");\n\t\t\ttaskChoiceGR.addEncodedQuery(`element=${fieldValue}^name=task`);\n\t\t\ttaskChoiceGR.addQuery(\"inactive=false\");\n\t\t\ttaskChoiceGR.addQuery(\"language=en\"); // TODO: Allow for multiple languages\n\t\t\ttaskChoiceGR.orderBy(\"sequence\");\n\t\t\ttaskChoiceGR.orderBy(\"value\");\n\t\t\ttaskChoiceGR.query();\n\n\t\t\twhile (taskChoiceGR.next()) {\n\t\t\t\tconst value = taskChoiceGR.getValue(\"value\");\n\t\t\t\tlet color = \"\";\n\t\t\t\tlet className = \"\";\n\n\t\t\t\tif (fetchColors) {\n\t\t\t\t\tconst colors = this.colors[fieldValue][value];\n\t\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t\t}\n\n\t\t\t\tchoices.push({\n\t\t\t\t\tlabel: taskChoiceGR.getValue(\"label\"),\n\t\t\t\t\tvalue,\n\t\t\t\t\tcolor,\n\t\t\t\t\tclassName,\n\t\t\t\t\ticon,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttype: fieldType,\n\t\t\tname: fieldName,\n\t\t\tvalue: fieldValue,\n\t\t\tchoices,\n\t\t\tisChoice,\n\t\t\tmaxLength,\n\t\t\tcanWrite,\n\t\t\tcanClear,\n\t\t};\n\t},\n\n\tgetReference: function ({\n\t\tfieldName,\n\t\tfieldValue,\n\t\tfieldType,\n\t\tisChoice,\n\t\tfetchColors,\n\t\ttableReferance,\n\t\tcanWrite,\n\t\tcanClear,\n\t\tmaxLength,\n\t\treferences,\n\t\tchoices,\n\t\tattributesOrderBy,\n\t\tadditionalFilterQuery = \"\",\n\t\treferenceQualifier = \"\",\n\t\tlimitResults = true,\n\t\tgroupByField = \"\",\n\t}) {\n\t\tconst referenceGR = new GlideRecordSecure(tableReferance);\n\t\tif (limitResults) {\n\t\t\treferenceGR.setLimit(12);\n\t\t}\n\t\tif (referenceQualifier) {\n\t\t\treferenceGR.addEncodedQuery(referenceQualifier);\n\t\t}\n\t\tif (additionalFilterQuery) {\n\t\t\treferenceGR.addEncodedQuery(additionalFilterQuery);\n\t\t}\n\t\tif (attributesOrderBy) {\n\t\t\treferenceGR.orderBy(attributesOrderBy);\n\t\t} else {\n\t\t\treferenceGR.orderBy(referenceGR.getDisplayName());\n\t\t}\n\t\treferenceGR.query();\n\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\twhile (referenceGR.next()) {\n\t\t\tlet data = {};\n\t\t\tlet tempGroupField = {};\n\n\t\t\tif (groupByField) {\n\t\t\t\ttempGroupField.value = referenceGR.getValue(groupByField);\n\t\t\t\ttempGroupField.displayValue = referenceGR.getDisplayValue(groupByField);\n\t\t\t\tif (tempGroupField.value === null || tempGroupField.value === \"null\") {\n\t\t\t\t\ttempGroupField.value = \"\";\n\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t} else if (\n\t\t\t\t\ttempGroupField.displayValue === undefined ||\n\t\t\t\t\ttempGroupField.displayValue === \"\" ||\n\t\t\t\t\ttempGroupField.displayValue === \"undefined\"\n\t\t\t\t) {\n\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst icon = this.colors.icons[tableReferance] || false;\n\t\t\tlet color = \"\";\n\t\t\tlet className = \"\";\n\n\t\t\tif (fetchColors) {\n\t\t\t\tconst colors = this.colors[tableReferance] && this.colors[tableReferance][referenceGR.getValue(\"value\")];\n\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t}\n\n\t\t\tlet label = referenceGR.getDisplayValue();\n\t\t\tif (!label) {\n\t\t\t\tlabel = `Empty ${fieldName}`;\n\t\t\t}\n\n\t\t\tdata = {\n\t\t\t\tlabel: label,\n\t\t\t\tvalue: referenceGR.getValue(\"sys_id\"),\n\t\t\t\trefTable: tableReferance,\n\t\t\t\ticon,\n\t\t\t\tcolor,\n\t\t\t\tclassName,\n\t\t\t};\n\n\t\t\tif (tableReferance === \"sys_user\") {\n\t\t\t\tdata.avatar = this._getCachedAvatar(referenceGR.getValue(\"sys_id\"));\n\t\t\t} else if (specialTables.statusTables.indexOf(tableReferance) > -1) {\n\t\t\t\tconst colorElement = tableReferance === \"x_cadso_work_status\" ? \"color\" : \"glyph_color\";\n\t\t\t\tdata.color = referenceGR.getValue(colorElement);\n\t\t\t}\n\n\t\t\tif (groupByField) {\n\t\t\t\tdata.groupBy = tempGroupField;\n\t\t\t}\n\n\t\t\treferences.push(data);\n\t\t}\n\n\t\treturn {\n\t\t\ttype: fieldType,\n\t\t\tname: fieldName,\n\t\t\tvalue: fieldValue,\n\t\t\treferences,\n\t\t\trefTable: tableReferance,\n\t\t\tisChoice,\n\t\t\tchoices,\n\t\t\tmaxLength,\n\t\t\tcanWrite,\n\t\t\tcanClear,\n\t\t};\n\t},\n\n\tgetAdditionalFilterData: function (additionalFilter) {\n\t\tconst table = additionalFilter.filterTable;\n\t\tthis.table = table;\n\t\tlet fieldValue = additionalFilter.additionalFilterField;\n\t\tlet additionalFilterQuery = \"\";\n\n\t\tif (additionalFilter.customFilterOptions && additionalFilter.customFilterOptions.length) {\n\t\t\tadditionalFilterQuery = additionalFilter.customFilterOptions[0].query;\n\t\t}\n\n\t\tconst groupByField = additionalFilter.groupBy;\n\t\tthis.getColorsForField(\"\");\n\n\t\tconst fieldChecker = new x_cadso_work.TenonListFIeldsToExclude();\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tlet query = `name=${table}^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\tif (specialTables.workTables.indexOf(table) > -1 && table !== \"sn_customerservice_case\") {\n\t\t\tquery = `name=${table}^ORname=task^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\t}\n\n\t\tlet referenceQualifier = \"\";\n\t\tlet attributesOrderBy = \"\";\n\t\tconst choices = [];\n\t\tconst references = [];\n\t\tlet fieldName = \"\";\n\t\tlet fieldType = \"\";\n\t\tlet maxLength = \"\";\n\t\tlet element = \"\";\n\t\tlet tableReferance = \"\";\n\t\tlet isChoice = false;\n\n\t\tconst fetchColors = this.getColorsForField(fieldValue);\n\t\tconst tableOverridesGR = new GlideRecord(table);\n\t\ttableOverridesGR.orderBy(tableOverridesGR.getDisplayName());\n\t\ttableOverridesGR.setLimit(1);\n\t\ttableOverridesGR.query();\n\n\t\twhile (tableOverridesGR.next()) {\n\t\t\tconst tableFieldsGR = new GlideRecord(\"sys_dictionary\");\n\t\t\ttableFieldsGR.addEncodedQuery(query);\n\t\t\ttableFieldsGR.orderBy(\"column_label\");\n\t\t\ttableFieldsGR.query();\n\n\t\t\twhile (tableFieldsGR.next()) {\n\t\t\t\tfieldName = tableFieldsGR.getValue(\"column_label\");\n\t\t\t\tfieldType = tableFieldsGR.getValue(\"internal_type\");\n\t\t\t\tmaxLength = tableFieldsGR.getValue(\"max_length\");\n\t\t\t\telement = tableOverridesGR.getElement(fieldValue);\n\t\t\t\ttableReferance = tableFieldsGR.getValue(\"reference\");\n\n\t\t\t\t// Check the overrides for the refQual\n\t\t\t\treferenceQualifier = this._getReferenceQualifier(table, fieldValue, \"reference\");\n\n\t\t\t\t// Parse attributes\n\t\t\t\tconst attributes = this._parseFieldAttributes(tableFieldsGR.getValue(\"attributes\"));\n\t\t\t\tattributesOrderBy = attributes.orderBy;\n\n\t\t\t\tlet fieldOverrideLabel = fieldName;\n\t\t\t\tif (element) {\n\t\t\t\t\tfieldOverrideLabel = element.getLabel();\n\t\t\t\t}\n\t\t\t\tfieldName = fieldOverrideLabel;\n\n\t\t\t\t// Determine field type\n\t\t\t\tconst fieldTypeInfo = this._determineFieldType(element, fieldType);\n\t\t\t\tisChoice = fieldTypeInfo.isChoice;\n\t\t\t}\n\t\t}\n\n\t\tif (fieldType !== \"reference\" && fieldType !== \"choice\") {\n\t\t\tconst additionalFilterGR = new GlideRecord(table);\n\t\t\tif (fieldValue) {\n\t\t\t\tadditionalFilterGR.orderBy(fieldValue);\n\t\t\t}\n\t\t\tadditionalFilterGR.query();\n\n\t\t\twhile (additionalFilterGR.next()) {\n\t\t\t\tif (!fieldValue) {\n\t\t\t\t\tfieldValue = additionalFilterGR.getDisplayName();\n\t\t\t\t}\n\n\t\t\t\tlet label = additionalFilterGR.getDisplayValue();\n\t\t\t\tif (!label) {\n\t\t\t\t\tlabel = `Empty ${fieldName}`;\n\t\t\t\t}\n\n\t\t\t\tconst icon = this.colors.icons[tableReferance] || false;\n\t\t\t\tlet color = \"\";\n\t\t\t\tlet className = \"\";\n\n\t\t\t\tif (fetchColors) {\n\t\t\t\t\tconst colors = this.colors[fieldValue] && this.colors[fieldValue][additionalFilterGR.getValue(\"value\")];\n\t\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t\t}\n\n\t\t\t\tconst data = {\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tvalue: additionalFilterGR.getValue(\"sys_id\"),\n\t\t\t\t\ticon,\n\t\t\t\t\tcolor,\n\t\t\t\t\tclassName,\n\t\t\t\t};\n\n\t\t\t\tif (groupByField) {\n\t\t\t\t\tconst tempGroupField = {};\n\t\t\t\t\ttempGroupField.value = additionalFilterGR.getValue(groupByField);\n\t\t\t\t\ttempGroupField.displayValue = additionalFilterGR.getDisplayValue(groupByField);\n\n\t\t\t\t\tif (tempGroupField.value === null || tempGroupField.value === \"null\") {\n\t\t\t\t\t\ttempGroupField.value = \"\";\n\t\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t\t} else if (\n\t\t\t\t\t\ttempGroupField.displayValue === undefined ||\n\t\t\t\t\t\ttempGroupField.displayValue === \"\" ||\n\t\t\t\t\t\ttempGroupField.displayValue === \"undefined\"\n\t\t\t\t\t) {\n\t\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t\t}\n\t\t\t\t\tdata.groupBy = tempGroupField;\n\t\t\t\t}\n\t\t\t\treferences.push(data);\n\t\t\t}\n\n\t\t\tadditionalFilter.fieldData = {\n\t\t\t\ttype: fieldType,\n\t\t\t\tname: fieldName,\n\t\t\t\tvalue: fieldValue,\n\t\t\t\treferences,\n\t\t\t\trefTable: tableReferance,\n\t\t\t\tisChoice,\n\t\t\t\tchoices,\n\t\t\t\tmaxLength,\n\t\t\t\tcanWrite: false,\n\t\t\t\tcanClear: false,\n\t\t\t};\n\t\t} else if (fieldType === \"reference\") {\n\t\t\tadditionalFilter.fieldData = this.getReference({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice,\n\t\t\t\tfieldChecker,\n\t\t\t\tfetchColors,\n\t\t\t\ttableReferance,\n\t\t\t\tcanWrite: tableOverridesGR[fieldValue].canWrite(),\n\t\t\t\tcanClear: false,\n\t\t\t\tmaxLength,\n\t\t\t\treferences,\n\t\t\t\tchoices,\n\t\t\t\tattributesOrderBy,\n\t\t\t\treferenceQualifier,\n\t\t\t\tlimitResults: false,\n\t\t\t\tgroupByField,\n\t\t\t\tadditionalFilterQuery,\n\t\t\t});\n\t\t} else if (fieldType === \"choice\") {\n\t\t\tadditionalFilter.fieldData = this.getChoice({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice,\n\t\t\t\tfetchColors,\n\t\t\t\tchoices,\n\t\t\t\tcanWrite: tableOverridesGR[fieldValue].canWrite(),\n\t\t\t\tcanClear: false,\n\t\t\t\tmaxLength,\n\t\t\t\tlimitResults: false,\n\t\t\t});\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn additionalFilter;\n\t},\n\n\ttype: \"TableMetaData\",\n});\n",
    "formatted_script": {
      "line_count": 1006,
      "char_count": 29307,
      "preview": "const TableMetaData = Class.create();\nTableMetaData.prototype = Object.extendsObject(x_cadso_core.TableMetaDataMS, {\n\tinitialize: function () {\n\t\tx_cadso_core.TableMetaDataMS.prototype.initialize.appl...",
      "full_script": "const TableMetaData = Class.create();\nTableMetaData.prototype = Object.extendsObject(x_cadso_core.TableMetaDataMS, {\n\tinitialize: function () {\n\t\tx_cadso_core.TableMetaDataMS.prototype.initialize.apply(this, arguments);\n\t\tthis.userAvatars = {};\n\t\tthis.colors = false;\n\t\tthis.language = gs.getSession().getLanguage();\n\t},\n\n\tgetColorsForField: function (field) {\n\t\tif (!this.colors) {\n\t\t\tconst api = new x_cadso_work.GetColorsForFields();\n\t\t\tthis.colors = api.fetch(this.table);\n\t\t}\n\t\treturn field === \"priority\" || field === \"state\";\n\t},\n\n\t/**\n\t * Main entry point for getting table metadata\n\t * @param {string} table - The table name to get metadata for\n\t * @param {boolean} isList - Whether this is for list view (true) or complex filter (false)\n\t * @returns {Array} Array of field metadata objects\n\t */\n\tgetData: function (table, isList) {\n\t\tthis.table = table;\n\t\tconst fields = [];\n\t\tthis.getColorsForField(\"\");\n\n\t\tconst query = this._buildBaseQuery(table);\n\t\tconst fieldChecker = new x_cadso_work.TenonListFIeldsToExclude();\n\n\t\tconst tableFieldsGR = new GlideRecord(\"sys_dictionary\");\n\t\ttableFieldsGR.addEncodedQuery(query);\n\t\ttableFieldsGR.orderBy(\"column_label\");\n\t\ttableFieldsGR.query();\n\n\t\twhile (tableFieldsGR.next()) {\n\t\t\tconst fieldData = this._processFieldData(tableFieldsGR, table, isList, fieldChecker);\n\t\t\tif (fieldData) {\n\t\t\t\tfields.push(fieldData);\n\t\t\t}\n\t\t}\n\n\t\treturn fields;\n\t},\n\n\t/**\n\t * Builds the base query for retrieving table fields\n\t * @private\n\t * @param {string} table - The table name\n\t * @returns {string} The encoded query string\n\t */\n\t_buildBaseQuery: function (table) {\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tif (specialTables.workTables.indexOf(table) > -1) {\n\t\t\treturn `name=${table}^ORname=task^internal_type!=collection^ORinternal_type=NULL^active=true`;\n\t\t} else if (table === \"customer_contact\") {\n\t\t\treturn `name=${table}^ORname=sys_user^internal_type!=collection^internal_type!=integer^ORinternal_type=NULL^active=true`;\n\t\t}\n\n\t\treturn `name=${table}^internal_type!=collection^ORinternal_type=NULL^active=true`;\n\t},\n\n\t/**\n\t * Centralized configuration for special table handling\n\t * @private\n\t * @returns {Object} Configuration object with special table lists\n\t */\n\t_getSpecialTableConfig: function () {\n\t\treturn {\n\t\t\tworkTables: [\n\t\t\t\t\"x_cadso_work_project\",\n\t\t\t\t\"x_cadso_work_campaign\",\n\t\t\t\t\"x_cadso_work_goal\",\n\t\t\t\t\"x_cadso_work_task\",\n\t\t\t\t\"x_cadso_work_sprint\",\n\t\t\t\t\"x_cadso_work_sprint_retro\",\n\t\t\t\t\"sn_customerservice_case\",\n\t\t\t],\n\t\t\tstatusTables: [\"x_cadso_work_status\", \"x_cadso_work_project\", \"x_cadso_work_campaign\"],\n\t\t};\n\t},\n\n\t/**\n\t * Main orchestration function for processing field data\n\t * @private\n\t * @param {GlideRecord} tableFieldsGR - The sys_dictionary GlideRecord\n\t * @param {string} table - The table name\n\t * @param {boolean} isList - Whether this is for list view\n\t * @param {Object} fieldChecker - Field checker utility instance\n\t * @returns {Object|null} Processed field data or null if field should be excluded\n\t */\n\t_processFieldData: function (tableFieldsGR, table, isList, fieldChecker) {\n\t\t// Extract basic field information\n\t\tconst fieldValue = tableFieldsGR.getValue(\"element\");\n\t\tconst fieldType = tableFieldsGR.getValue(\"internal_type\");\n\t\tconst maxLength = tableFieldsGR.getValue(\"max_length\");\n\t\tlet fieldName = tableFieldsGR.getValue(\"column_label\");\n\n\t\t// Get element for type determination\n\t\tconst tableOverridesGR = new GlideRecord(table);\n\t\ttableOverridesGR.orderBy(tableOverridesGR.getDisplayName());\n\t\ttableOverridesGR.setLimit(1);\n\t\tconst element = tableOverridesGR.getElement(fieldValue);\n\n\t\t// Apply field name overrides\n\t\tfieldName = this._processFieldOverrides(fieldName, table, fieldValue);\n\n\t\t// Check field inclusion for list view\n\t\tif (isList) {\n\t\t\tconst fieldValuesToInclude = fieldChecker.fieldValuesToIncludeFromList[table];\n\t\t\tif (!fieldChecker.checkField(fieldValuesToInclude, fieldValue)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Determine actual field type\n\t\tconst actualFieldType = this._determineFieldType(element, fieldType);\n\n\t\t// Parse field attributes\n\t\tconst attributes = this._parseFieldAttributes(tableFieldsGR.getValue(\"attributes\"));\n\n\t\t// Get reference qualifier if applicable\n\t\tconst referenceQualifier = this._getReferenceQualifier(table, fieldValue, fieldType);\n\n\t\t// Check if field can be cleared\n\t\tconst canClearFields = fieldChecker.fieldsThatCanNotBeCleared;\n\t\tconst canClear = !fieldChecker.checkField(canClearFields, fieldValue);\n\n\t\t// Check write permissions\n\t\tconst canWrite = isList ? tableOverridesGR[fieldValue].canWrite() : true; // Complex filter always allows write for filtering\n\n\t\t// Determine if colors should be fetched\n\t\tconst fetchColors = this.getColorsForField(fieldValue);\n\n\t\t// Build field object based on type\n\t\tif (actualFieldType.isChoice) {\n\t\t\treturn this.getChoice({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice: true,\n\t\t\t\tfieldChecker,\n\t\t\t\tfetchColors,\n\t\t\t\tchoices: [],\n\t\t\t\tcanWrite,\n\t\t\t\tcanClear,\n\t\t\t\tmaxLength,\n\t\t\t});\n\t\t} else if (fieldType === \"reference\" || fieldType === \"glide_list\") {\n\t\t\treturn this.getReference({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice: false,\n\t\t\t\tfieldChecker,\n\t\t\t\tfetchColors,\n\t\t\t\ttableReferance: tableFieldsGR.getValue(\"reference\"),\n\t\t\t\tcanWrite,\n\t\t\t\tcanClear,\n\t\t\t\tmaxLength,\n\t\t\t\treferences: [],\n\t\t\t\tchoices: [],\n\t\t\t\tattributesOrderBy: attributes.orderBy,\n\t\t\t\treferenceQualifier,\n\t\t\t\tgroupByField: \"\",\n\t\t\t});\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: fieldType,\n\t\t\t\tname: fieldName,\n\t\t\t\tvalue: fieldValue,\n\t\t\t\tisChoice: false,\n\t\t\t\tchoices: [],\n\t\t\t\tmaxLength,\n\t\t\t\tcanWrite,\n\t\t\t\tcanClear,\n\t\t\t};\n\t\t}\n\t},\n\n\t/**\n\t * Process field name overrides from sys_documentation\n\t * @private\n\t * @param {string} fieldName - Original field name\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @returns {string} Override field name or original\n\t */\n\t_processFieldOverrides: function (fieldName, table, fieldValue) {\n\t\tconst sysDocumentationGR = new GlideRecord(\"sys_documentation\");\n\t\tsysDocumentationGR.addQuery(\"name\", table);\n\t\tsysDocumentationGR.addQuery(\"element\", fieldValue);\n\t\tsysDocumentationGR.addQuery(\"language\", this.language || \"en\");\n\t\tsysDocumentationGR.query();\n\n\t\twhile (sysDocumentationGR.next()) {\n\t\t\tif (sysDocumentationGR.getValue(\"element\") === fieldValue) {\n\t\t\t\tconst overrideName = sysDocumentationGR.getValue(\"label\");\n\t\t\t\tif (fieldName !== overrideName) {\n\t\t\t\t\treturn overrideName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fieldName;\n\t},\n\n\t/**\n\t * Determine the actual field type including choice detection\n\t * @private\n\t * @param {Object} element - GlideElement object\n\t * @param {string} fieldType - Base field type from sys_dictionary\n\t * @returns {Object} Object with isChoice flag and type\n\t */\n\t_determineFieldType: function (element, fieldType) {\n\t\tlet isChoice = false;\n\n\t\tconst edCheck =\n\t\t\telement !== null &&\n\t\t\telement !== \"null\" &&\n\t\t\ttypeof element === \"object\" &&\n\t\t\telement.getED &&\n\t\t\ttypeof element.getED === \"function\";\n\n\t\tif (edCheck) {\n\t\t\tconst elmEd = element.getED();\n\t\t\tisChoice = elmEd.isChoiceTable();\n\t\t}\n\n\t\treturn {\n\t\t\tisChoice,\n\t\t\ttype: fieldType,\n\t\t};\n\t},\n\n\t/**\n\t * Parse field attributes for ordering information\n\t * @private\n\t * @param {string} attributesValuePairs - Comma-separated attribute pairs\n\t * @returns {Object} Parsed attributes object\n\t */\n\t_parseFieldAttributes: function (attributesValuePairs) {\n\t\tconst attributes = {\n\t\t\torderBy: \"\",\n\t\t\trefAcOrderBy: \"\",\n\t\t\trefSequence: \"\",\n\t\t};\n\n\t\tif (attributesValuePairs) {\n\t\t\tconst pairs = attributesValuePairs.split(\",\");\n\t\t\tpairs.forEach((pair) => {\n\t\t\t\tconst [key, value] = pair.split(\"=\");\n\t\t\t\tif (key === \"ref_ac_order_by\") {\n\t\t\t\t\tattributes.refAcOrderBy = value;\n\t\t\t\t} else if (key === \"ref_sequence\") {\n\t\t\t\t\tattributes.refSequence = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tattributes.orderBy =\n\t\t\t\tattributes.refAcOrderBy !== \"\"\n\t\t\t\t\t? attributes.refAcOrderBy\n\t\t\t\t\t: attributes.refSequence !== \"\"\n\t\t\t\t\t? attributes.refSequence\n\t\t\t\t\t: \"\";\n\t\t}\n\n\t\treturn attributes;\n\t},\n\n\t/**\n\t * Get reference qualifier for a field\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @param {string} fieldType - Field type\n\t * @returns {string} Reference qualifier query string\n\t */\n\t_getReferenceQualifier: function (table, fieldValue, fieldType) {\n\t\tif (fieldType !== \"reference\" && fieldType !== \"glide_list\") {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tconst refQualOverRideGR = new GlideRecord(\"sys_dictionary_override\");\n\t\trefQualOverRideGR.addEncodedQuery(`name=${table}^element=${fieldValue}`);\n\t\trefQualOverRideGR.query();\n\n\t\twhile (refQualOverRideGR.next()) {\n\t\t\tif (`${refQualOverRideGR.getValue(\"reference_qual_override\")}` === \"1\") {\n\t\t\t\tconst refQual = refQualOverRideGR.getValue(\"reference_qual\");\n\t\t\t\t// eslint-disable-next-line no-script-url\n\t\t\t\tif (refQual && !refQual.includes(\"javascript:\")) {\n\t\t\t\t\treturn refQual;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn \"\";\n\t},\n\n\tupdateReferenceFieldOptions: function (table, field, queryString, sysId, isList, isBulk, bulkSysIds) {\n\t\tlet bulkAssignedTo = false;\n\t\tif (isBulk && (field.value === \"assigned_to\" || field.value === \"additional_assignee_list\")) {\n\t\t\tbulkAssignedTo = true;\n\t\t}\n\n\t\tif (table) {\n\t\t\tconst query = this._buildReferenceQuery(table, field.value);\n\t\t\tlet referenceQualifier = \"\";\n\t\t\tlet attributesOrderBy = \"\";\n\t\t\tlet tableName = \"\";\n\n\t\t\tconst dictionaryGR = new GlideRecord(\"sys_dictionary\");\n\t\t\tdictionaryGR.addEncodedQuery(query);\n\t\t\tdictionaryGR.orderBy(\"column_label\");\n\t\t\tdictionaryGR.query();\n\n\t\t\twhile (dictionaryGR.next()) {\n\t\t\t\ttableName = dictionaryGR.getDisplayValue(\"column_label\");\n\n\t\t\t\tif (isList === true || (isBulk === true && bulkAssignedTo === false)) {\n\t\t\t\t\treferenceQualifier = this._getCompleteReferenceQualifier(table, field.value, sysId, dictionaryGR);\n\t\t\t\t}\n\n\t\t\t\tconst attributes = this._parseFieldAttributes(dictionaryGR.getValue(\"attributes\"));\n\t\t\t\tattributesOrderBy = attributes.orderBy;\n\t\t\t\tfield.sys_id = sysId;\n\t\t\t}\n\n\t\t\tif (bulkAssignedTo) {\n\t\t\t\treturn this._processBulkAssignedTo(table, field, queryString, bulkSysIds, tableName);\n\t\t\t}\n\n\t\t\treturn this._processReferenceRecords(field, queryString, sysId, referenceQualifier, attributesOrderBy);\n\t\t}\n\t},\n\n\t/**\n\t * Build reference query based on table type\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @returns {string} Encoded query string\n\t */\n\t_buildReferenceQuery: function (table, fieldValue) {\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tif (specialTables.workTables.indexOf(table) > -1 && table !== \"sn_customerservice_case\") {\n\t\t\treturn `name=${table}^ORname=task^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\t} else if (table === \"customer_contact\") {\n\t\t\treturn `name=${table}^ORname=sys_user^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\t}\n\n\t\treturn `name=${table}^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t},\n\n\t/**\n\t * Get complete reference qualifier including overrides and scripts\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {string} fieldValue - Field element name\n\t * @param {string} sysId - Record sys_id\n\t * @param {GlideRecord} dictionaryGR - Dictionary GlideRecord\n\t * @returns {string} Reference qualifier\n\t */\n\t_getCompleteReferenceQualifier: function (table, fieldValue, sysId, dictionaryGR) {\n\t\tconst refQualOverRideGR = new GlideRecord(\"sys_dictionary_override\");\n\t\trefQualOverRideGR.addEncodedQuery(`name=${table}^element=${fieldValue}`);\n\t\trefQualOverRideGR.query();\n\n\t\tif (refQualOverRideGR.next()) {\n\t\t\tif (`${refQualOverRideGR.getValue(\"reference_qual_override\")}` === \"1\") {\n\t\t\t\t// eslint-disable-next-line no-script-url\n\t\t\t\tif (refQualOverRideGR.getValue(\"reference_qual\").includes(\"javascript:\")) {\n\t\t\t\t\treturn this.getRefQualValue(table, fieldValue, sysId);\n\t\t\t\t} else {\n\t\t\t\t\treturn refQualOverRideGR.getValue(\"reference_qual\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dictionaryGR.getValue(\"use_reference_qualifier\") === \"simple\") {\n\t\t\tif (dictionaryGR.getValue(\"reference_qual_condition\")) {\n\t\t\t\treturn dictionaryGR.getValue(\"reference_qual_condition\");\n\t\t\t}\n\t\t} else {\n\t\t\treturn this.getRefQualValue(table, fieldValue, sysId);\n\t\t}\n\n\t\treturn \"\";\n\t},\n\n\t/**\n\t * Process bulk assigned to queries\n\t * @private\n\t * @param {string} table - Table name\n\t * @param {Object} field - Field object\n\t * @param {string} queryString - Query string\n\t * @param {Array} bulkSysIds - Array of sys_ids\n\t * @param {string} tableName - Table display name\n\t * @returns {Object} Updated field object with references\n\t */\n\t_processBulkAssignedTo: function (table, field, queryString, bulkSysIds, tableName) {\n\t\tconst bulkQuery = bulkSysIds.join(\",\");\n\t\tconst groupsArray = [];\n\t\tconst returnUserArr = [];\n\n\t\t// Grab unique assignment groups with glide aggregate from the referring table\n\t\tconst assignmentGA = new GlideAggregate(table);\n\t\tassignmentGA.addAggregate(\"COUNT\");\n\t\tassignmentGA.groupBy(\"assignment_group\");\n\t\tassignmentGA.addQuery(\"sys_id\", \"IN\", bulkQuery);\n\t\tassignmentGA.query();\n\n\t\t// Push unique values to groups array\n\t\twhile (assignmentGA.next()) {\n\t\t\tgroupsArray.push(assignmentGA.getValue(\"assignment_group\"));\n\t\t}\n\n\t\tconst groupsQuery = groupsArray.join(\",\");\n\n\t\t// Query the group members table for assignment groups associated to bulk records\n\t\tconst groupGA = new GlideAggregate(\"sys_user_grmember\");\n\t\tgroupGA.addAggregate(\"COUNT\");\n\t\tgroupGA.groupBy(\"user\");\n\t\tgroupGA.addQuery(\"user.name\", \"CONTAINS\", queryString);\n\t\tgroupGA.addQuery(\"group\", \"IN\", groupsQuery);\n\t\tgroupGA.query();\n\n\t\twhile (groupGA.next()) {\n\t\t\t// Get the count of user records on the group members table\n\t\t\tconst userCount = groupGA.getAggregate(\"COUNT\");\n\n\t\t\t// If a users record count matches the length of unique assignment groups add to return array\n\t\t\tif (userCount >= groupsArray.length) {\n\t\t\t\treturnUserArr.push(groupGA.getValue(\"user\"));\n\t\t\t}\n\t\t}\n\n\t\tlet userQuery = \"\";\n\t\tif (returnUserArr.length > 0) {\n\t\t\tuserQuery = returnUserArr.join(\",\");\n\t\t}\n\n\t\tconst records = this._buildReferenceRecords(field, queryString, userQuery, \"\", \"\", tableName, true);\n\t\tfield.references = records;\n\n\t\treturn field;\n\t},\n\n\t/**\n\t * Process standard reference records\n\t * @private\n\t * @param {Object} field - Field object\n\t * @param {string} queryString - Query string\n\t * @param {string} sysId - Record sys_id\n\t * @param {string} referenceQualifier - Reference qualifier\n\t * @param {string} attributesOrderBy - Order by attribute\n\t * @returns {Object} Updated field object with references\n\t */\n\t_processReferenceRecords: function (field, queryString, sysId, referenceQualifier, attributesOrderBy) {\n\t\tconst records = this._buildReferenceRecords(\n\t\t\tfield,\n\t\t\tqueryString,\n\t\t\t\"\",\n\t\t\treferenceQualifier,\n\t\t\tattributesOrderBy,\n\t\t\t\"\",\n\t\t\tfalse,\n\t\t);\n\t\tfield.references = records;\n\t\treturn field;\n\t},\n\n\t/**\n\t * Build reference records array\n\t * @private\n\t * @param {Object} field - Field object\n\t * @param {string} queryString - Query string\n\t * @param {string} userQuery - User query for bulk operations\n\t * @param {string} referenceQualifier - Reference qualifier\n\t * @param {string} attributesOrderBy - Order by attribute\n\t * @param {string} tableName - Table display name\n\t * @param {boolean} isBulk - Whether this is a bulk operation\n\t * @returns {Array} Array of reference records\n\t */\n\t_buildReferenceRecords: function (\n\t\tfield,\n\t\tqueryString,\n\t\tuserQuery,\n\t\treferenceQualifier,\n\t\tattributesOrderBy,\n\t\ttableName,\n\t\tisBulk,\n\t) {\n\t\tconst records = [];\n\t\tthis.table = field.refTable;\n\t\tconst fetchColors = this.getColorsForField(field.value);\n\t\tconst referenceGR = new GlideRecordSecure(field.refTable);\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tif (isBulk && field.refTable === \"sys_user\") {\n\t\t\treferenceGR.addQuery(\"sys_id\", \"IN\", userQuery);\n\t\t} else if (field.value === \"parent_goals\") {\n\t\t\tconst parentGoalsQuery = this.getRefQualValue(\"x_cadso_work_goal\", field.value, field.referringRecordId);\n\t\t\treferenceGR.addEncodedQuery(parentGoalsQuery);\n\t\t} else {\n\t\t\treferenceGR.addEncodedQuery(`${referenceQualifier}^${referenceGR.getDisplayName()}LIKE${queryString}`);\n\t\t}\n\n\t\tif (attributesOrderBy) {\n\t\t\treferenceGR.orderBy(attributesOrderBy);\n\t\t} else {\n\t\t\treferenceGR.orderBy(referenceGR.getDisplayName());\n\t\t}\n\n\t\treferenceGR.setLimit(12);\n\t\treferenceGR.query();\n\n\t\twhile (referenceGR.next()) {\n\t\t\tconst record = this._createReferenceRecord(\n\t\t\t\treferenceGR,\n\t\t\t\tfield.refTable,\n\t\t\t\ttableName || field.name,\n\t\t\t\tfetchColors,\n\t\t\t\tspecialTables,\n\t\t\t);\n\t\t\trecords.push(record);\n\t\t}\n\n\t\treturn records;\n\t},\n\n\t/**\n\t * Create a single reference record object\n\t * @private\n\t * @param {GlideRecord} referenceGR - Reference GlideRecord\n\t * @param {string} refTable - Reference table name\n\t * @param {string} fieldName - Field display name\n\t * @param {boolean} fetchColors - Whether to fetch colors\n\t * @param {Object} specialTables - Special tables configuration\n\t * @returns {Object} Reference record object\n\t */\n\t_createReferenceRecord: function (referenceGR, refTable, fieldName, fetchColors, specialTables) {\n\t\tconst icon = this.colors.icons[refTable] || false;\n\t\tlet color = \"\";\n\t\tlet className = \"\";\n\n\t\tif (fetchColors) {\n\t\t\tconst colors = this.colors[refTable] && this.colors[refTable][referenceGR.getValue(\"value\")];\n\t\t\tcolor = colors ? colors.color : false;\n\t\t\tclassName = colors ? colors.className : false;\n\t\t}\n\n\t\tlet label = referenceGR.getDisplayValue();\n\t\tif (!label) {\n\t\t\tlabel = `Empty ${fieldName}`;\n\t\t}\n\n\t\tconst record = {\n\t\t\tlabel: label,\n\t\t\tvalue: referenceGR.getValue(\"sys_id\"),\n\t\t\trefTable: refTable,\n\t\t\ticon,\n\t\t\tcolor,\n\t\t\tclassName,\n\t\t};\n\n\t\tif (refTable === \"sys_user\") {\n\t\t\trecord.avatar = this._getCachedAvatar(referenceGR.getValue(\"sys_id\"));\n\t\t} else if (specialTables.statusTables.indexOf(refTable) > -1) {\n\t\t\tconst colorElement = refTable === \"x_cadso_work_status\" ? \"color\" : \"glyph_color\";\n\t\t\trecord.color = referenceGR.getValue(colorElement);\n\t\t}\n\n\t\treturn record;\n\t},\n\n\tgetRefQualValue: function (table, field, sysid) {\n\t\tconst refQualGR = new GlideRecord(\"x_cadso_work_ref_qual_scripts\");\n\t\trefQualGR.addEncodedQuery(`table=${table}^field_name=${field}`);\n\t\trefQualGR.query();\n\n\t\tif (refQualGR.next()) {\n\t\t\tif (refQualGR.record_dependent_fields) {\n\t\t\t\tconst recordFields = refQualGR.getValue(\"record_dependent_fields\");\n\t\t\t\tconst lookupFieldValue = new GlideRecord(table);\n\t\t\t\tlookupFieldValue.addQuery(\"sys_id\", sysid);\n\t\t\t\tlookupFieldValue.query();\n\n\t\t\t\tif (lookupFieldValue.next()) {\n\t\t\t\t\tconst scriptVariable = lookupFieldValue.getValue(recordFields);\n\t\t\t\t\tconst evaluator = new GlideScopedEvaluator();\n\t\t\t\t\tevaluator.putVariable(recordFields, scriptVariable);\n\t\t\t\t\treturn evaluator.evaluateScript(refQualGR, \"u_script\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst evaluator = new GlideScopedEvaluator();\n\t\t\t\treturn evaluator.evaluateScript(refQualGR, \"u_script\");\n\t\t\t}\n\t\t}\n\n\t\treturn \"\";\n\t},\n\n\t_getCachedAvatar: function (userSysId) {\n\t\tif (this.userAvatars[userSysId]) {\n\t\t\treturn this.userAvatars[userSysId];\n\t\t}\n\n\t\tconst sysUserGr = new GlideRecord(\"sys_user\");\n\n\t\tif (sysUserGr.get(userSysId)) {\n\t\t\tconst avatar = sysUserGr.getValue(\"avatar\") || \"\";\n\t\t\tconst photo = sysUserGr.getValue(\"photo\") || \"\";\n\t\t\tconst userAvatar = avatar || photo;\n\t\t\tthis.userAvatars[userSysId] = userAvatar ? `${userAvatar}.iix` : \"\";\n\t\t} else {\n\t\t\tthis.userAvatars[userSysId] = \"\";\n\t\t}\n\n\t\treturn this.userAvatars[userSysId];\n\t},\n\n\tgetChoice: function ({\n\t\tfieldName,\n\t\tfieldValue,\n\t\tfieldType,\n\t\ttable,\n\t\tisChoice,\n\t\tchoices,\n\t\tfetchColors,\n\t\tcanWrite,\n\t\tcanClear,\n\t\tmaxLength,\n\t\tlimitResults = false,\n\t}) {\n\t\tconst icon = this.colors.icons[fieldValue] || false;\n\t\tconst choiceGR = new GlideRecordSecure(\"sys_choice\");\n\t\tchoiceGR.addEncodedQuery(`element=${fieldValue}^name=${table}`);\n\t\tchoiceGR.addQuery(\"inactive=false\");\n\t\tchoiceGR.addQuery(\"language=en\"); // TODO: Allow for multiple languages\n\t\tchoiceGR.orderBy(\"sequence\");\n\t\tchoiceGR.orderBy(\"value\");\n\n\t\tif (limitResults) {\n\t\t\tchoiceGR.setLimit(12);\n\t\t}\n\n\t\tchoiceGR.query();\n\n\t\twhile (choiceGR.next()) {\n\t\t\tconst value = choiceGR.getValue(\"value\");\n\t\t\tlet color = \"\";\n\t\t\tlet className = \"\";\n\n\t\t\tif (fetchColors) {\n\t\t\t\tconst colors = this.colors[fieldValue][value];\n\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t}\n\n\t\t\tchoices.push({\n\t\t\t\tlabel: choiceGR.getValue(\"label\"),\n\t\t\t\tvalue,\n\t\t\t\tcolor,\n\t\t\t\tclassName,\n\t\t\t\ticon,\n\t\t\t});\n\t\t}\n\n\t\t// If no choices found, check task table\n\t\tif (!choices.length) {\n\t\t\tconst taskChoiceGR = new GlideRecordSecure(\"sys_choice\");\n\t\t\ttaskChoiceGR.addEncodedQuery(`element=${fieldValue}^name=task`);\n\t\t\ttaskChoiceGR.addQuery(\"inactive=false\");\n\t\t\ttaskChoiceGR.addQuery(\"language=en\"); // TODO: Allow for multiple languages\n\t\t\ttaskChoiceGR.orderBy(\"sequence\");\n\t\t\ttaskChoiceGR.orderBy(\"value\");\n\t\t\ttaskChoiceGR.query();\n\n\t\t\twhile (taskChoiceGR.next()) {\n\t\t\t\tconst value = taskChoiceGR.getValue(\"value\");\n\t\t\t\tlet color = \"\";\n\t\t\t\tlet className = \"\";\n\n\t\t\t\tif (fetchColors) {\n\t\t\t\t\tconst colors = this.colors[fieldValue][value];\n\t\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t\t}\n\n\t\t\t\tchoices.push({\n\t\t\t\t\tlabel: taskChoiceGR.getValue(\"label\"),\n\t\t\t\t\tvalue,\n\t\t\t\t\tcolor,\n\t\t\t\t\tclassName,\n\t\t\t\t\ticon,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttype: fieldType,\n\t\t\tname: fieldName,\n\t\t\tvalue: fieldValue,\n\t\t\tchoices,\n\t\t\tisChoice,\n\t\t\tmaxLength,\n\t\t\tcanWrite,\n\t\t\tcanClear,\n\t\t};\n\t},\n\n\tgetReference: function ({\n\t\tfieldName,\n\t\tfieldValue,\n\t\tfieldType,\n\t\tisChoice,\n\t\tfetchColors,\n\t\ttableReferance,\n\t\tcanWrite,\n\t\tcanClear,\n\t\tmaxLength,\n\t\treferences,\n\t\tchoices,\n\t\tattributesOrderBy,\n\t\tadditionalFilterQuery = \"\",\n\t\treferenceQualifier = \"\",\n\t\tlimitResults = true,\n\t\tgroupByField = \"\",\n\t}) {\n\t\tconst referenceGR = new GlideRecordSecure(tableReferance);\n\t\tif (limitResults) {\n\t\t\treferenceGR.setLimit(12);\n\t\t}\n\t\tif (referenceQualifier) {\n\t\t\treferenceGR.addEncodedQuery(referenceQualifier);\n\t\t}\n\t\tif (additionalFilterQuery) {\n\t\t\treferenceGR.addEncodedQuery(additionalFilterQuery);\n\t\t}\n\t\tif (attributesOrderBy) {\n\t\t\treferenceGR.orderBy(attributesOrderBy);\n\t\t} else {\n\t\t\treferenceGR.orderBy(referenceGR.getDisplayName());\n\t\t}\n\t\treferenceGR.query();\n\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\twhile (referenceGR.next()) {\n\t\t\tlet data = {};\n\t\t\tlet tempGroupField = {};\n\n\t\t\tif (groupByField) {\n\t\t\t\ttempGroupField.value = referenceGR.getValue(groupByField);\n\t\t\t\ttempGroupField.displayValue = referenceGR.getDisplayValue(groupByField);\n\t\t\t\tif (tempGroupField.value === null || tempGroupField.value === \"null\") {\n\t\t\t\t\ttempGroupField.value = \"\";\n\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t} else if (\n\t\t\t\t\ttempGroupField.displayValue === undefined ||\n\t\t\t\t\ttempGroupField.displayValue === \"\" ||\n\t\t\t\t\ttempGroupField.displayValue === \"undefined\"\n\t\t\t\t) {\n\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst icon = this.colors.icons[tableReferance] || false;\n\t\t\tlet color = \"\";\n\t\t\tlet className = \"\";\n\n\t\t\tif (fetchColors) {\n\t\t\t\tconst colors = this.colors[tableReferance] && this.colors[tableReferance][referenceGR.getValue(\"value\")];\n\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t}\n\n\t\t\tlet label = referenceGR.getDisplayValue();\n\t\t\tif (!label) {\n\t\t\t\tlabel = `Empty ${fieldName}`;\n\t\t\t}\n\n\t\t\tdata = {\n\t\t\t\tlabel: label,\n\t\t\t\tvalue: referenceGR.getValue(\"sys_id\"),\n\t\t\t\trefTable: tableReferance,\n\t\t\t\ticon,\n\t\t\t\tcolor,\n\t\t\t\tclassName,\n\t\t\t};\n\n\t\t\tif (tableReferance === \"sys_user\") {\n\t\t\t\tdata.avatar = this._getCachedAvatar(referenceGR.getValue(\"sys_id\"));\n\t\t\t} else if (specialTables.statusTables.indexOf(tableReferance) > -1) {\n\t\t\t\tconst colorElement = tableReferance === \"x_cadso_work_status\" ? \"color\" : \"glyph_color\";\n\t\t\t\tdata.color = referenceGR.getValue(colorElement);\n\t\t\t}\n\n\t\t\tif (groupByField) {\n\t\t\t\tdata.groupBy = tempGroupField;\n\t\t\t}\n\n\t\t\treferences.push(data);\n\t\t}\n\n\t\treturn {\n\t\t\ttype: fieldType,\n\t\t\tname: fieldName,\n\t\t\tvalue: fieldValue,\n\t\t\treferences,\n\t\t\trefTable: tableReferance,\n\t\t\tisChoice,\n\t\t\tchoices,\n\t\t\tmaxLength,\n\t\t\tcanWrite,\n\t\t\tcanClear,\n\t\t};\n\t},\n\n\tgetAdditionalFilterData: function (additionalFilter) {\n\t\tconst table = additionalFilter.filterTable;\n\t\tthis.table = table;\n\t\tlet fieldValue = additionalFilter.additionalFilterField;\n\t\tlet additionalFilterQuery = \"\";\n\n\t\tif (additionalFilter.customFilterOptions && additionalFilter.customFilterOptions.length) {\n\t\t\tadditionalFilterQuery = additionalFilter.customFilterOptions[0].query;\n\t\t}\n\n\t\tconst groupByField = additionalFilter.groupBy;\n\t\tthis.getColorsForField(\"\");\n\n\t\tconst fieldChecker = new x_cadso_work.TenonListFIeldsToExclude();\n\t\tconst specialTables = this._getSpecialTableConfig();\n\n\t\tlet query = `name=${table}^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\tif (specialTables.workTables.indexOf(table) > -1 && table !== \"sn_customerservice_case\") {\n\t\t\tquery = `name=${table}^ORname=task^internal_type!=collection^ORinternal_type=NULL^active=true^element=${fieldValue}`;\n\t\t}\n\n\t\tlet referenceQualifier = \"\";\n\t\tlet attributesOrderBy = \"\";\n\t\tconst choices = [];\n\t\tconst references = [];\n\t\tlet fieldName = \"\";\n\t\tlet fieldType = \"\";\n\t\tlet maxLength = \"\";\n\t\tlet element = \"\";\n\t\tlet tableReferance = \"\";\n\t\tlet isChoice = false;\n\n\t\tconst fetchColors = this.getColorsForField(fieldValue);\n\t\tconst tableOverridesGR = new GlideRecord(table);\n\t\ttableOverridesGR.orderBy(tableOverridesGR.getDisplayName());\n\t\ttableOverridesGR.setLimit(1);\n\t\ttableOverridesGR.query();\n\n\t\twhile (tableOverridesGR.next()) {\n\t\t\tconst tableFieldsGR = new GlideRecord(\"sys_dictionary\");\n\t\t\ttableFieldsGR.addEncodedQuery(query);\n\t\t\ttableFieldsGR.orderBy(\"column_label\");\n\t\t\ttableFieldsGR.query();\n\n\t\t\twhile (tableFieldsGR.next()) {\n\t\t\t\tfieldName = tableFieldsGR.getValue(\"column_label\");\n\t\t\t\tfieldType = tableFieldsGR.getValue(\"internal_type\");\n\t\t\t\tmaxLength = tableFieldsGR.getValue(\"max_length\");\n\t\t\t\telement = tableOverridesGR.getElement(fieldValue);\n\t\t\t\ttableReferance = tableFieldsGR.getValue(\"reference\");\n\n\t\t\t\t// Check the overrides for the refQual\n\t\t\t\treferenceQualifier = this._getReferenceQualifier(table, fieldValue, \"reference\");\n\n\t\t\t\t// Parse attributes\n\t\t\t\tconst attributes = this._parseFieldAttributes(tableFieldsGR.getValue(\"attributes\"));\n\t\t\t\tattributesOrderBy = attributes.orderBy;\n\n\t\t\t\tlet fieldOverrideLabel = fieldName;\n\t\t\t\tif (element) {\n\t\t\t\t\tfieldOverrideLabel = element.getLabel();\n\t\t\t\t}\n\t\t\t\tfieldName = fieldOverrideLabel;\n\n\t\t\t\t// Determine field type\n\t\t\t\tconst fieldTypeInfo = this._determineFieldType(element, fieldType);\n\t\t\t\tisChoice = fieldTypeInfo.isChoice;\n\t\t\t}\n\t\t}\n\n\t\tif (fieldType !== \"reference\" && fieldType !== \"choice\") {\n\t\t\tconst additionalFilterGR = new GlideRecord(table);\n\t\t\tif (fieldValue) {\n\t\t\t\tadditionalFilterGR.orderBy(fieldValue);\n\t\t\t}\n\t\t\tadditionalFilterGR.query();\n\n\t\t\twhile (additionalFilterGR.next()) {\n\t\t\t\tif (!fieldValue) {\n\t\t\t\t\tfieldValue = additionalFilterGR.getDisplayName();\n\t\t\t\t}\n\n\t\t\t\tlet label = additionalFilterGR.getDisplayValue();\n\t\t\t\tif (!label) {\n\t\t\t\t\tlabel = `Empty ${fieldName}`;\n\t\t\t\t}\n\n\t\t\t\tconst icon = this.colors.icons[tableReferance] || false;\n\t\t\t\tlet color = \"\";\n\t\t\t\tlet className = \"\";\n\n\t\t\t\tif (fetchColors) {\n\t\t\t\t\tconst colors = this.colors[fieldValue] && this.colors[fieldValue][additionalFilterGR.getValue(\"value\")];\n\t\t\t\t\tcolor = colors ? colors.color : false;\n\t\t\t\t\tclassName = colors ? colors.className : false;\n\t\t\t\t}\n\n\t\t\t\tconst data = {\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tvalue: additionalFilterGR.getValue(\"sys_id\"),\n\t\t\t\t\ticon,\n\t\t\t\t\tcolor,\n\t\t\t\t\tclassName,\n\t\t\t\t};\n\n\t\t\t\tif (groupByField) {\n\t\t\t\t\tconst tempGroupField = {};\n\t\t\t\t\ttempGroupField.value = additionalFilterGR.getValue(groupByField);\n\t\t\t\t\ttempGroupField.displayValue = additionalFilterGR.getDisplayValue(groupByField);\n\n\t\t\t\t\tif (tempGroupField.value === null || tempGroupField.value === \"null\") {\n\t\t\t\t\t\ttempGroupField.value = \"\";\n\t\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t\t} else if (\n\t\t\t\t\t\ttempGroupField.displayValue === undefined ||\n\t\t\t\t\t\ttempGroupField.displayValue === \"\" ||\n\t\t\t\t\t\ttempGroupField.displayValue === \"undefined\"\n\t\t\t\t\t) {\n\t\t\t\t\t\ttempGroupField.displayValue = \"Empty\";\n\t\t\t\t\t}\n\t\t\t\t\tdata.groupBy = tempGroupField;\n\t\t\t\t}\n\t\t\t\treferences.push(data);\n\t\t\t}\n\n\t\t\tadditionalFilter.fieldData = {\n\t\t\t\ttype: fieldType,\n\t\t\t\tname: fieldName,\n\t\t\t\tvalue: fieldValue,\n\t\t\t\treferences,\n\t\t\t\trefTable: tableReferance,\n\t\t\t\tisChoice,\n\t\t\t\tchoices,\n\t\t\t\tmaxLength,\n\t\t\t\tcanWrite: false,\n\t\t\t\tcanClear: false,\n\t\t\t};\n\t\t} else if (fieldType === \"reference\") {\n\t\t\tadditionalFilter.fieldData = this.getReference({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice,\n\t\t\t\tfieldChecker,\n\t\t\t\tfetchColors,\n\t\t\t\ttableReferance,\n\t\t\t\tcanWrite: tableOverridesGR[fieldValue].canWrite(),\n\t\t\t\tcanClear: false,\n\t\t\t\tmaxLength,\n\t\t\t\treferences,\n\t\t\t\tchoices,\n\t\t\t\tattributesOrderBy,\n\t\t\t\treferenceQualifier,\n\t\t\t\tlimitResults: false,\n\t\t\t\tgroupByField,\n\t\t\t\tadditionalFilterQuery,\n\t\t\t});\n\t\t} else if (fieldType === \"choice\") {\n\t\t\tadditionalFilter.fieldData = this.getChoice({\n\t\t\t\tfieldName,\n\t\t\t\tfieldValue,\n\t\t\t\tfieldType,\n\t\t\t\ttable,\n\t\t\t\tisChoice,\n\t\t\t\tfetchColors,\n\t\t\t\tchoices,\n\t\t\t\tcanWrite: tableOverridesGR[fieldValue].canWrite(),\n\t\t\t\tcanClear: false,\n\t\t\t\tmaxLength,\n\t\t\t\tlimitResults: false,\n\t\t\t});\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn additionalFilter;\n\t},\n\n\ttype: \"TableMetaData\",\n});\n"
    }
  },
  "sys_class_name": {
    "value": "sys_script_include",
    "display_value": "Script Include"
  },
  "sys_package": {
    "value": "608cd026c374e250d4ddf1db050131bb",
    "display_value": "Tenon - Core"
  },
  "sys_update_name": {
    "value": "sys_script_include_6512c8efc353a210d4ddf1db0501316a",
    "display_value": "sys_script_include_6512c8efc353a210d4ddf1db0501316a"
  },
  "sys_updated_by": {
    "value": "daniel.cudney",
    "display_value": "daniel.cudney"
  },
  "api_name": {
    "value": "x_cadso_core.TableMetaData",
    "display_value": "x_cadso_core.TableMetaData"
  },
  "sys_created_on": {
    "value": "2025-08-17 07:21:54",
    "display_value": "2025-08-17 12:21:54 AM"
  },
  "caller_access": {
    "value": "",
    "display_value": null
  },
  "name": {
    "value": "TableMetaData",
    "display_value": "TableMetaData"
  },
  "sys_name": {
    "value": "TableMetaData",
    "display_value": "TableMetaData"
  },
  "sys_scope": {
    "value": "608cd026c374e250d4ddf1db050131bb",
    "display_value": "Tenon - Core"
  },
  "sys_created_by": {
    "value": "admin",
    "display_value": "admin"
  },
  "sys_policy": {
    "value": "",
    "display_value": null
  }
}
