{
  "_metadata": {
    "table": "sys_script_include",
    "sys_id": "4a950c0bc3132210d4ddf1db05013160",
    "extracted_at": "2025-09-19T21:48:28.654Z",
    "display_value": "ConditionBuilderMS",
    "application": "Tenon_-_Core",
    "scope": {
      "display_value": "Tenon - Core",
      "link": "https://tenonworkstudio.service-now.com/api/now/table/sys_scope/608cd026c374e250d4ddf1db050131bb",
      "value": "608cd026c374e250d4ddf1db050131bb"
    }
  },
  "client_callable": {
    "value": "false",
    "display_value": "false"
  },
  "access": {
    "value": "public",
    "display_value": "All application scopes"
  },
  "mobile_callable": {
    "value": "false",
    "display_value": "false"
  },
  "sys_mod_count": {
    "value": "21",
    "display_value": "21"
  },
  "active": {
    "value": "true",
    "display_value": "true"
  },
  "description": {
    "value": "",
    "display_value": ""
  },
  "sys_updated_on": {
    "value": "2025-08-27 01:21:49",
    "display_value": "2025-08-26 06:21:49 PM"
  },
  "sys_tags": {
    "value": "",
    "display_value": ""
  },
  "sandbox_callable": {
    "value": "true",
    "display_value": "true"
  },
  "script": {
    "value": "/**\r\n * ConditionBuilderMS - Converts ServiceNow encoded queries to FilterGroup array\r\n *\r\n * Returns FilterGroup[] structure:\r\n * {\r\n *   filterGroupDisplayValue: string,  // Display name for the filter group\r\n *   filterGroupIndex: number,          // Index position of the group\r\n *   filters: FilterCondition[],        // Array of filter conditions\r\n *   collapsed: boolean                 // UI state for group collapse\r\n * }\r\n *\r\n * The ^NQ separator creates separate FilterGroups.\r\n * Queries without ^NQ return a single FilterGroup containing all conditions.\r\n *\r\n * @example\r\n * // Single group (no NQ)\r\n * convert(\"priority=1^state=2\") returns:\r\n * [{\r\n *   filterGroupDisplayValue: \"Filter Group 1\",\r\n *   filterGroupIndex: 0,\r\n *   filters: [condition1, condition2],\r\n *   collapsed: false\r\n * }]\r\n *\r\n * @example\r\n * // Multiple groups (with NQ)\r\n * convert(\"priority=1^NQstate=2\") returns:\r\n * [{\r\n *   filterGroupDisplayValue: \"Filter Group 1\",\r\n *   filterGroupIndex: 0,\r\n *   filters: [condition1],\r\n *   collapsed: false\r\n * }, {\r\n *   filterGroupDisplayValue: \"Filter Group 2\",\r\n *   filterGroupIndex: 1,\r\n *   filters: [condition2],\r\n *   collapsed: false\r\n * }]\r\n */\r\nvar ConditionBuilderMS = Class.create();\r\nConditionBuilderMS.prototype = {\r\n\tinitialize: function () {\r\n\t\tthis.Utils = new x_cadso_core.ConditionBuilderUtilsMS();\r\n\t\tthis.GetTableDropdownsData = new x_cadso_work.GetTableDropdownsData();\r\n\t\tthis.fieldMetadataCache = {};\r\n\t\tthis.language = gs.getSession().getLanguage();\r\n\t\t// ServiceNow operators mapping\r\n\t\tvar CF_Tables = new x_cadso_work.TenonComplexFilterTables();\r\n\t\tthis.tableMap = {\r\n\t\t\troutes: CF_Tables.routes,\r\n\t\t\toperations: CF_Tables.operations,\r\n\t\t\toperationTable: CF_Tables.operationTable,\r\n\t\t\toperators: CF_Tables.operators,\r\n\t\t\tbooleanTable: CF_Tables.booleanTable,\r\n\t\t\tglideDateTimeTable: CF_Tables.glideDateTimeTable,\r\n\t\t\tcurrencyTable: CF_Tables.currencyTable,\r\n\t\t};\r\n\t\tthis.operators = {\r\n\t\t\t// Equality operators\r\n\t\t\t\"=\": { type: \"equals\", label: \"is\", needsValue: true },\r\n\t\t\t\"!=\": { type: \"not_equals\", label: \"is not\", needsValue: true },\r\n\r\n\t\t\t// Comparison operators\r\n\t\t\t\">\": { type: \"greater_than\", label: \">\", needsValue: true },\r\n\t\t\t\">=\": { type: \"greater_than_or_equal\", label: \">=\", needsValue: true },\r\n\t\t\t\"<\": { type: \"less_than\", label: \"<\", needsValue: true },\r\n\t\t\t\"<=\": { type: \"less_than_or_equal\", label: \"<=\", needsValue: true },\r\n\r\n\t\t\t// String operators\r\n\t\t\tCONTAINS: { type: \"contains\", label: \"contains\", needsValue: true },\r\n\t\t\t\"DOES NOT CONTAIN\": { type: \"does_not_contain\", label: \"does not contain\", needsValue: true },\r\n\t\t\tSTARTSWITH: { type: \"starts_with\", label: \"starts with\", needsValue: true },\r\n\t\t\tENDSWITH: { type: \"ends_with\", label: \"ends with\", needsValue: true },\r\n\t\t\tLIKE: { type: \"like\", label: \"contains\", needsValue: true },\r\n\t\t\t\"NOT LIKE\": { type: \"not_like\", label: \"does not contain\", needsValue: true },\r\n\r\n\t\t\t// List operators\r\n\t\t\tIN: { type: \"in\", label: \"is one of\", needsValue: true, multiValue: true },\r\n\t\t\t\"NOT IN\": { type: \"not_in\", label: \"is not one of\", needsValue: true, multiValue: true },\r\n\r\n\t\t\t// Empty/null operators\r\n\t\t\tISEMPTY: { type: \"is_empty\", label: \"is empty\", needsValue: false },\r\n\t\t\tISNOTEMPTY: { type: \"is_not_empty\", label: \"is not empty\", needsValue: false },\r\n\t\t\tANYTHING: { type: \"anything\", label: \"is anything\", needsValue: false },\r\n\t\t\tEMPTYSTRING: { type: \"empty_string\", label: \"is empty string\", needsValue: false },\r\n\r\n\t\t\t// Date operators\r\n\t\t\tON: { type: \"on\", label: \"on\", needsValue: true, dateOperator: true },\r\n\t\t\tBETWEEN: {\r\n\t\t\t\ttype: \"between\",\r\n\t\t\t\tlabel: \"between\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tmultiValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVE: { type: \"relative\", label: \"relative\", needsValue: true, dateOperator: true },\r\n\t\t\tRELATIVEGT: {\r\n\t\t\t\ttype: \"relative_gt\",\r\n\t\t\t\tlabel: \"relative >\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVELT: {\r\n\t\t\t\ttype: \"relative_lt\",\r\n\t\t\t\tlabel: \"relative <\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVEGE: {\r\n\t\t\t\ttype: \"relative_ge\",\r\n\t\t\t\tlabel: \"relative >=\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVELE: {\r\n\t\t\t\ttype: \"relative_le\",\r\n\t\t\t\tlabel: \"relative <=\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tDATEPART: {\r\n\t\t\t\ttype: \"date_part\",\r\n\t\t\t\tlabel: \"date part\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tmultiValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tSAMEAS: { type: \"same_as\", label: \"same as\", needsValue: true, dateOperator: true },\r\n\t\t\tNSAMEAS: { type: \"not_same_as\", label: \"not same as\", needsValue: true, dateOperator: true },\r\n\t\t\tMORETHAN: { type: \"more_than\", label: \"more than\", needsValue: true, dateOperator: true },\r\n\t\t\tLESSTHAN: {\r\n\t\t\t\ttype: \"less_than_duration\",\r\n\t\t\t\tlabel: \"less than\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\r\n\t\t\t// JavaScript operators\r\n\t\t\tDYNAMIC: { type: \"dynamic\", label: \"dynamic\", needsValue: true },\r\n\t\t\tSCRIPT: { type: \"script\", label: \"script\", needsValue: true },\r\n\r\n\t\t\t// Currency operators\r\n\t\t\tVALCHANGES: { type: \"value_changes\", label: \"changes\", needsValue: false },\r\n\t\t\tVALCHANGESTO: { type: \"value_changes_to\", label: \"changes to\", needsValue: true },\r\n\t\t\tVALCHANGESFROM: { type: \"value_changes_from\", label: \"changes from\", needsValue: true },\r\n\r\n\t\t\t// Reference operators\r\n\t\t\tINSTANCEOF: { type: \"instance_of\", label: \"is a\", needsValue: true },\r\n\t\t\t\"NOT INSTANCEOF\": { type: \"not_instance_of\", label: \"is not a\", needsValue: true },\r\n\r\n\t\t\t// Duration operators\r\n\t\t\tDURATION: { type: \"duration\", label: \"duration\", needsValue: true },\r\n\t\t};\r\n\t},\r\n\r\n\tconvert: function (condition, table) {\r\n\t\tif (!condition || typeof condition !== \"string\") {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\t// Store table for metadata lookups\r\n\t\tthis.currentTable = table || null;\r\n\r\n\t\t// Clear metadata cache for new conversion\r\n\t\tthis.fieldMetadataCache = {};\r\n\r\n\t\ttry {\r\n\t\t\t// Split by ^NQ to get separate condition groups\r\n\t\t\tvar queryGroups = this._splitByNQ(condition);\r\n\t\t\tvar filterGroups = [];\r\n\t\t\tvar conditionId = 0;\r\n\r\n\t\t\tfor (var groupIndex = 0; groupIndex < queryGroups.length; groupIndex++) {\r\n\t\t\t\tvar isFirstGroup = groupIndex === 0;\r\n\t\t\t\tvar groupConditions = this._parseConditionGroup(queryGroups[groupIndex], conditionId, isFirstGroup);\r\n\r\n\t\t\t\t// Create a FilterGroup for this set of conditions\r\n\t\t\t\tif (groupConditions.length > 0) {\r\n\t\t\t\t\tvar filterGroup = {\r\n\t\t\t\t\t\tfilterGroupDisplayValue: \"Filter Group \" + (groupIndex + 1),\r\n\t\t\t\t\t\tfilterGroupIndex: groupIndex,\r\n\t\t\t\t\t\tfilters: groupConditions,\r\n\t\t\t\t\t\tcollapsed: false,\r\n\t\t\t\t\t};\r\n\t\t\t\t\tfilterGroups.push(filterGroup);\r\n\t\t\t\t\tconditionId += groupConditions.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Reverse the filter groups array to match expected order\r\n\t\t\tfilterGroups.reverse();\r\n\r\n\t\t\t// Update the display values and indices after reversing\r\n\t\t\tfor (var i = 0; i < filterGroups.length; i++) {\r\n\t\t\t\tfilterGroups[i].filterGroupDisplayValue = \"Filter Group \" + (i + 1);\r\n\t\t\t\tfilterGroups[i].filterGroupIndex = i;\r\n\t\t\t}\r\n\r\n\t\t\treturn filterGroups;\r\n\t\t} catch (error) {\r\n\t\t\tgs.error(\"Error converting encoded query: \" + error);\r\n\t\t\treturn [];\r\n\t\t}\r\n\t},\r\n\r\n\t_splitByNQ: function (query) {\r\n\t\tvar parts = query.split(\"^NQ\");\r\n\t\tvar result = [];\r\n\t\tfor (var i = 0; i < parts.length; i++) {\r\n\t\t\tif (parts[i].trim().length > 0) {\r\n\t\t\t\tresult.push(parts[i].trim());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.length > 0 ? result : [query];\r\n\t},\r\n\r\n\t_parseConditionGroup: function (groupQuery, startId, isFirstGroup) {\r\n\t\tvar conditions = [];\r\n\t\tvar currentId = startId || 0;\r\n\r\n\t\t// Check if query contains OR\r\n\t\tvar hasOR = groupQuery.indexOf(\"^OR\") > -1;\r\n\r\n\t\tif (!hasOR) {\r\n\t\t\t// No OR conditions, just parse as regular AND conditions\r\n\t\t\tvar andConditions = this._parseAndConditions(groupQuery, currentId, isFirstGroup);\r\n\t\t\tconditions = conditions.concat(andConditions);\r\n\t\t} else {\r\n\t\t\t// Split by ^OR to handle OR conditions\r\n\t\t\tvar orGroups = this._splitByOR(groupQuery);\r\n\r\n\t\t\tfor (var i = 0; i < orGroups.length; i++) {\r\n\t\t\t\tif (orGroups[i].trim()) {\r\n\t\t\t\t\tvar groupConditions = this._parseAndConditions(orGroups[i], currentId, isFirstGroup && i === 0);\r\n\r\n\t\t\t\t\t// Set operator for conditions\r\n\t\t\t\t\tfor (var j = 0; j < groupConditions.length; j++) {\r\n\t\t\t\t\t\tif (j === 0 && i === 0 && isFirstGroup) {\r\n\t\t\t\t\t\t\tgroupConditions[j].operator = \"\"; // First condition of first group has no operator\r\n\t\t\t\t\t\t} else if (i > 0 && j === 0) {\r\n\t\t\t\t\t\t\tgroupConditions[j].operator = { value: \"OR\", label: \"OR\" }; // First condition of OR group\r\n\t\t\t\t\t\t} else if (j > 0) {\r\n\t\t\t\t\t\t\tgroupConditions[j].operator = { value: \"AND\", label: \"AND\" }; // Subsequent conditions in same group\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcurrentId++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconditions = conditions.concat(groupConditions);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn conditions;\r\n\t},\r\n\r\n\t_splitByOR: function (query) {\r\n\t\tvar parts = [];\r\n\t\tvar currentPart = \"\";\r\n\t\tvar i = 0;\r\n\r\n\t\twhile (i < query.length) {\r\n\t\t\tif (query.substring(i, i + 3) === \"^OR\") {\r\n\t\t\t\tif (currentPart.trim()) {\r\n\t\t\t\t\tparts.push(currentPart.trim());\r\n\t\t\t\t}\r\n\t\t\t\tcurrentPart = \"\";\r\n\t\t\t\ti += 3;\r\n\t\t\t} else {\r\n\t\t\t\tcurrentPart += query.charAt(i);\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (currentPart.trim()) {\r\n\t\t\tparts.push(currentPart.trim());\r\n\t\t}\r\n\r\n\t\treturn parts.length > 0 ? parts : [query];\r\n\t},\r\n\r\n\t_parseAndConditions: function (groupQuery, startId, isFirstInGroup) {\r\n\t\tvar conditionStrings = this._splitByAND(groupQuery);\r\n\t\tvar conditions = [];\r\n\r\n\t\tfor (var i = 0; i < conditionStrings.length; i++) {\r\n\t\t\tvar condition = this._parseIndividualCondition(conditionStrings[i].trim(), startId + i);\r\n\t\t\tif (condition) {\r\n\t\t\t\t// Set operator based on position\r\n\t\t\t\tif (i === 0 && isFirstInGroup) {\r\n\t\t\t\t\tcondition.operator = \"\"; // First condition of first group has no operator\r\n\t\t\t\t} else if (i > 0) {\r\n\t\t\t\t\tcondition.operator = { value: \"AND\", label: \"AND\" }; // Subsequent conditions use AND\r\n\t\t\t\t}\r\n\t\t\t\t// Note: operator will be overridden by _parseConditionGroup for OR conditions\r\n\t\t\t\tconditions.push(condition);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn conditions;\r\n\t},\r\n\r\n\t_splitByAND: function (query) {\r\n\t\tvar parts = [];\r\n\t\tvar currentPart = \"\";\r\n\t\tvar i = 0;\r\n\r\n\t\twhile (i < query.length) {\r\n\t\t\tif (query.charAt(i) === \"^\") {\r\n\t\t\t\t// Check if this is a standalone AND operator\r\n\t\t\t\tif (this._isStandaloneAND(query, i)) {\r\n\t\t\t\t\tif (currentPart.trim()) {\r\n\t\t\t\t\t\tparts.push(currentPart.trim());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurrentPart = \"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentPart += query.charAt(i);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcurrentPart += query.charAt(i);\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\tif (currentPart.trim()) {\r\n\t\t\tparts.push(currentPart.trim());\r\n\t\t}\r\n\r\n\t\treturn parts.length > 0 ? parts : [query];\r\n\t},\r\n\r\n\t_isStandaloneAND: function (query, position) {\r\n\t\t// Look ahead to see if this is ^OR or ^NQ\r\n\t\tif (position + 2 < query.length) {\r\n\t\t\tvar next2 = query.substring(position, position + 3);\r\n\t\t\tif (next2 === \"^OR\" || next2 === \"^NQ\") {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Look behind to see if this is part of an operator\r\n\t\tif (position > 0) {\r\n\t\t\tvar prev = query.charAt(position - 1);\r\n\t\t\tif (prev === \"=\" || prev === \"!\" || prev === \">\" || prev === \"<\") {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_parseIndividualCondition: function (conditionStr, id) {\r\n\t\t// Find the operator in the condition string\r\n\t\tvar operatorMatch = this._findOperatorInCondition(conditionStr);\r\n\r\n\t\tif (!operatorMatch) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar operator = operatorMatch.operator;\r\n\t\tvar operatorKey = operatorMatch.operatorKey;\r\n\t\tvar startPos = operatorMatch.startPos;\r\n\t\tvar endPos = operatorMatch.endPos;\r\n\r\n\t\t// Extract field and value\r\n\t\tvar field = conditionStr.substring(0, startPos).trim();\r\n\t\tvar value = conditionStr.substring(endPos).trim();\r\n\r\n\t\t// Validate field\r\n\t\tif (!field) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Parse the value based on operator type\r\n\t\tvar parsedValues = this._parseValue(value, operator);\r\n\r\n\t\t// Create FilterCondition object\r\n\t\treturn this._createFilterCondition(id, field, operatorKey, operator, parsedValues);\r\n\t},\r\n\r\n\t_findOperatorInCondition: function (conditionStr) {\r\n\t\t// Sort operators by length (longest first) to match multi-character operators first\r\n\t\tvar sortedOperators = [];\r\n\t\tfor (var key in this.operators) {\r\n\t\t\tsortedOperators.push(key);\r\n\t\t}\r\n\t\tsortedOperators.sort(function (a, b) {\r\n\t\t\treturn b.length - a.length;\r\n\t\t});\r\n\r\n\t\tfor (var i = 0; i < sortedOperators.length; i++) {\r\n\t\t\tvar operatorKey = sortedOperators[i];\r\n\t\t\tvar index = conditionStr.indexOf(operatorKey);\r\n\t\t\tif (index > 0) {\r\n\t\t\t\t// Must have field before operator\r\n\t\t\t\treturn {\r\n\t\t\t\t\toperator: this.operators[operatorKey],\r\n\t\t\t\t\toperatorKey: operatorKey,\r\n\t\t\t\t\tstartPos: index,\r\n\t\t\t\t\tendPos: index + operatorKey.length,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\t_parseValue: function (value, operator) {\r\n\t\tif (!operator.needsValue) {\r\n\t\t\treturn {\r\n\t\t\t\tvalues: [\"\", \"\"],\r\n\t\t\t\tlabels: [\"\", \"\"],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle multi-value operators\r\n\t\tif (operator.multiValue) {\r\n\t\t\treturn this._parseMultiValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle date operators\r\n\t\tif (operator.dateOperator) {\r\n\t\t\treturn this._parseDateValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Default single value\r\n\t\tvar cleanedValue = this._cleanValue(value);\r\n\t\treturn {\r\n\t\t\tvalues: [cleanedValue, \"\"],\r\n\t\t\tlabels: [cleanedValue, \"\"],\r\n\t\t};\r\n\t},\r\n\r\n\t_parseMultiValue: function (value, operator) {\r\n\t\tvar values = [];\r\n\t\tvar labels = [];\r\n\r\n\t\tif (operator.type === \"between\" || operator.type === \"date_part\") {\r\n\t\t\t// BETWEEN and DATEPART use @ as separator\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\tvalues.push(parts[0] ? this._cleanValue(parts[0]) : \"\");\r\n\t\t\tvalues.push(parts[1] ? this._cleanValue(parts[1]) : \"\");\r\n\t\t\tlabels.push(parts[0] ? this._cleanValue(parts[0]) : \"\");\r\n\t\t\tlabels.push(parts[1] ? this._cleanValue(parts[1]) : \"\");\r\n\t\t} else {\r\n\t\t\t// IN/NOT IN use comma separation - combine into first value\r\n\t\t\tvar combinedValue = value;\r\n\t\t\tvalues.push(combinedValue);\r\n\t\t\tvalues.push(\"\");\r\n\t\t\tlabels.push(combinedValue);\r\n\t\t\tlabels.push(\"\");\r\n\t\t}\r\n\r\n\t\t// Ensure we always have exactly 2 values\r\n\t\twhile (values.length < 2) {\r\n\t\t\tvalues.push(\"\");\r\n\t\t\tlabels.push(\"\");\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tvalues: values.slice(0, 2),\r\n\t\t\tlabels: labels.slice(0, 2),\r\n\t\t};\r\n\t},\r\n\r\n\t_parseDateValue: function (value, operator) {\r\n\t\t// Handle BETWEEN with @ separator\r\n\t\tif (operator.type === \"between\" && value.indexOf(\"@\") > -1) {\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\treturn {\r\n\t\t\t\tvalues: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t\tlabels: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle ON with @ separator (date range with javascript expressions)\r\n\t\tif (operator.type === \"on\" && value.indexOf(\"@\") > -1) {\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\t// For ON operator with date range, store the full value\r\n\t\t\t// The label is just the date part\r\n\t\t\tif (parts.length >= 3) {\r\n\t\t\t\t// Format: 2025-08-21@javascript:gs.dateGenerate('2025-08-21','start')@javascript:gs.dateGenerate('2025-08-21','end')\r\n\t\t\t\t// Or: Today@javascript:gs.beginningOfToday()@javascript:gs.endOfToday()\r\n\t\t\t\tvar dateValue = parts[0];\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalues: [value, \"\"], // Full value with javascript expressions\r\n\t\t\t\t\tlabels: [dateValue || \"\", \"\"], // Just the date part for label\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalues: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t\t\tlabels: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check for special value \"Today\"\r\n\t\tif (value === \"Today\") {\r\n\t\t\treturn {\r\n\t\t\t\tvalues: [\"Today\", \"\"],\r\n\t\t\t\tlabels: [\"Today\", \"\"],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Default date value\r\n\t\treturn {\r\n\t\t\tvalues: [value, \"\"],\r\n\t\t\tlabels: [value, \"\"],\r\n\t\t};\r\n\t},\r\n\r\n\t_cleanValue: function (value) {\r\n\t\tif (!value) return \"\";\r\n\r\n\t\t// Remove leading/trailing whitespace\r\n\t\tvalue = value.trim();\r\n\r\n\t\t// Return as-is to preserve the original value\r\n\t\treturn value;\r\n\t},\r\n\r\n\t_createFilterCondition: function (id, fieldName, operatorKey, operator, parsedValues) {\r\n\t\t// Get actual field metadata from ServiceNow if table is provided\r\n\t\tvar actualFieldMetadata = this.currentTable ? this._getActualFieldMetadata(this.currentTable, fieldName) : null;\r\n\r\n\t\t// Use actual metadata if available, otherwise fall back to inference\r\n\t\tvar fieldType =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.type\r\n\t\t\t\t? actualFieldMetadata.type\r\n\t\t\t\t: this._inferFieldType(fieldName, operator, parsedValues.values[0]);\r\n\r\n\t\tvar fieldDisplayName =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.displayValue\r\n\t\t\t\t? actualFieldMetadata.displayValue\r\n\t\t\t\t: this._humanizeFieldName(fieldName);\r\n\r\n\t\tvar isChoice =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.isChoice !== undefined\r\n\t\t\t\t? actualFieldMetadata.isChoice\r\n\t\t\t\t: this._isChoiceField(fieldName, fieldType);\r\n\r\n\t\tvar choices = actualFieldMetadata && actualFieldMetadata.choices ? actualFieldMetadata.choices : [];\r\n\r\n\t\tvar references = actualFieldMetadata && actualFieldMetadata.references ? actualFieldMetadata.references : [];\r\n\r\n\t\tvar refTable =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.refTable\r\n\t\t\t\t? actualFieldMetadata.refTable\r\n\t\t\t\t: this._getRefTable(fieldName, fieldType);\r\n\r\n\t\tvar canWrite =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.canWrite !== undefined ? actualFieldMetadata.canWrite : true;\r\n\r\n\t\tvar canClear =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.canClear !== undefined ? actualFieldMetadata.canClear : true;\r\n\r\n\t\tvar maxLength =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.maxLength\r\n\t\t\t\t? actualFieldMetadata.maxLength\r\n\t\t\t\t: this._getDefaultMaxLength(fieldType);\r\n\r\n\t\t// Build option arrays with proper formatting\r\n\t\tvar options = this._buildOptionArrays({\r\n\t\t\tparsedValues: parsedValues,\r\n\t\t\tfieldType: fieldType,\r\n\t\t\tfieldName: fieldName,\r\n\t\t\toperator: operator,\r\n\t\t\toperatorKey: operatorKey,\r\n\t\t\trefTable: refTable,\r\n\t\t\tchoices: choices,\r\n\t\t\treferences: references,\r\n\t\t});\r\n\r\n\t\treturn {\r\n\t\t\tid: id,\r\n\t\t\tfield: {\r\n\t\t\t\tdisplayValue: fieldDisplayName,\r\n\t\t\t\tname: fieldDisplayName,\r\n\t\t\t\tvalue: fieldName,\r\n\t\t\t\ttype: fieldType,\r\n\t\t\t\tisChoice: isChoice,\r\n\t\t\t\tchoices: choices,\r\n\t\t\t\treferences: references,\r\n\t\t\t\trefTable: refTable,\r\n\t\t\t\treference: refTable, // Add reference property\r\n\t\t\t\tcanWrite: canWrite,\r\n\t\t\t\tcanClear: canClear,\r\n\t\t\t\tcanSearch:\r\n\t\t\t\t\tactualFieldMetadata && actualFieldMetadata.canSearch !== undefined ? actualFieldMetadata.canSearch : true,\r\n\t\t\t\tmaxLength: maxLength,\r\n\t\t\t\tisRelatedFilter:\r\n\t\t\t\t\tactualFieldMetadata && actualFieldMetadata.isRelatedFilter ? actualFieldMetadata.isRelatedFilter : false,\r\n\t\t\t\trelatedFilter:\r\n\t\t\t\t\tactualFieldMetadata && actualFieldMetadata.relatedFilter ? actualFieldMetadata.relatedFilter : {},\r\n\t\t\t},\r\n\t\t\toperator: \"\", // Will be set by the calling function based on position\r\n\t\t\toperation: {\r\n\t\t\t\tlabel: operator.label || operatorKey.toLowerCase(),\r\n\t\t\t\tvalue: operatorKey,\r\n\t\t\t},\r\n\t\t\toption: options,\r\n\t\t\tcanDotWalk: fieldType === \"reference\",\r\n\t\t\tsearchInput: {\r\n\t\t\t\tfieldSeachInputValue: \"\",\r\n\t\t\t\toptionSearchInputValue: \"\",\r\n\t\t\t\ttimeSearchInputValue: \"\",\r\n\t\t\t},\r\n\t\t\tcurrency: fieldType === \"currency\" ? \"USD\" : \"\",\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Build option arrays with proper value formatting\r\n\t * @param {Object} params - Parameters for building options\r\n\t * @returns {Array} Array of two option objects\r\n\t */\r\n\t_buildOptionArrays: function (params) {\r\n\t\tvar parsedValues = params.parsedValues;\r\n\t\tvar fieldType = params.fieldType;\r\n\t\tvar fieldName = params.fieldName;\r\n\t\tvar operator = params.operator;\r\n\t\tvar operatorKey = params.operatorKey;\r\n\t\tvar refTable = params.refTable;\r\n\t\tvar choices = params.choices || [];\r\n\t\tvar references = params.references || [];\r\n\r\n\t\tvar Utils = this.Utils;\r\n\r\n\t\t// Get default option properties\r\n\t\tvar defaultOption1 = Utils.getDefaultOptionProperties(true);\r\n\t\tvar defaultOption2 = Utils.getDefaultOptionProperties(false);\r\n\r\n\t\t// Format values based on field type\r\n\t\tvar value1 = parsedValues.values[0] || \"\";\r\n\t\tvar value2 = parsedValues.values[1] || \"\";\r\n\t\tvar label1 = parsedValues.labels[0] || \"\";\r\n\t\tvar label2 = parsedValues.labels[1] || \"\";\r\n\r\n\t\t// Apply type-specific formatting to values\r\n\t\tif (value1) {\r\n\t\t\tvalue1 = this._formatValueByType(value1, fieldType, operatorKey);\r\n\t\t}\r\n\t\tif (value2) {\r\n\t\t\tvalue2 = this._formatValueByType(value2, fieldType, operatorKey);\r\n\t\t}\r\n\r\n\t\t// Format labels\r\n\t\tif (fieldType === \"boolean\") {\r\n\t\t\tlabel1 = value1 ? Utils.formatBooleanLabel(value1) : \"\";\r\n\t\t\tlabel2 = value2 ? Utils.formatBooleanLabel(value2) : \"\";\r\n\t\t} else if (fieldType === \"glide_date_time\" || fieldType === \"glide_date\") {\r\n\t\t\t// Format date labels\r\n\t\t\tif (label1 && label1 !== \"Today\" && label1 !== \"Yesterday\" && label1 !== \"Tomorrow\") {\r\n\t\t\t\tlabel1 = Utils.formatDateLabel(label1);\r\n\t\t\t}\r\n\t\t\tif (label2 && label2 !== \"Today\" && label2 !== \"Yesterday\" && label2 !== \"Tomorrow\") {\r\n\t\t\t\tlabel2 = Utils.formatDateLabel(label2);\r\n\t\t\t}\r\n\t\t} else if (fieldType === \"reference\") {\r\n\t\t\t// Get reference display values\r\n\t\t\tif (value1) {\r\n\t\t\t\tlabel1 = Utils.getReferenceLabel(value1, refTable, fieldName);\r\n\t\t\t}\r\n\t\t\tif (value2) {\r\n\t\t\t\tlabel2 = Utils.getReferenceLabel(value2, refTable, fieldName);\r\n\t\t\t}\r\n\t\t} else if (fieldType === \"choice\" && choices.length > 0) {\r\n\t\t\t// Get choice labels\r\n\t\t\tfor (var i = 0; i < choices.length; i++) {\r\n\t\t\t\tif (choices[i].value === value1) {\r\n\t\t\t\t\tlabel1 = choices[i].label;\r\n\t\t\t\t}\r\n\t\t\t\tif (choices[i].value === value2) {\r\n\t\t\t\t\tlabel2 = choices[i].label;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Build option1\r\n\t\tvar option1 = {\r\n\t\t\tid: 0,\r\n\t\t\tvalue: value1,\r\n\t\t\tlabel: label1,\r\n\t\t};\r\n\r\n\t\t// Build option2\r\n\t\tvar option2 = {\r\n\t\t\tid: 1,\r\n\t\t\tvalue: value2,\r\n\t\t\tlabel: label2,\r\n\t\t};\r\n\r\n\t\t// Merge with default properties\r\n\t\tfor (var key in defaultOption1) {\r\n\t\t\tif (!(key in option1)) {\r\n\t\t\t\toption1[key] = defaultOption1[key];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var key in defaultOption2) {\r\n\t\t\tif (!(key in option2)) {\r\n\t\t\t\toption2[key] = defaultOption2[key];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Handle special cases for dates\r\n\t\tif ((fieldType === \"glide_date_time\" || fieldType === \"glide_date\") && operator.type === \"on\") {\r\n\t\t\t// Parse selected date if not a special value\r\n\t\t\tif (label1 && label1 !== \"Today\" && label1 !== \"Yesterday\" && label1 !== \"Tomorrow\") {\r\n\t\t\t\toption1.selectedDate = Utils.parseSelectedDate(label1);\r\n\t\t\t}\r\n\r\n\t\t\t// Handle special date values\r\n\t\t\tif (typeof value1 === \"object\") {\r\n\t\t\t\t// Value is already formatted as special date object\r\n\t\t\t\toption1.value = value1;\r\n\t\t\t} else if (value1 && value1.indexOf(\"@\") > -1) {\r\n\t\t\t\t// Keep full value with javascript expressions\r\n\t\t\t\toption1.value = value1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Handle duration fields\r\n\t\tif (fieldType === \"glide_duration\" && value1) {\r\n\t\t\tvar duration1 = Utils.parseDuration(value1);\r\n\t\t\tif (duration1) {\r\n\t\t\t\toption1.duration = duration1;\r\n\t\t\t\toption1.tempDuration = duration1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fieldType === \"glide_duration\" && value2) {\r\n\t\t\tvar duration2 = Utils.parseDuration(value2);\r\n\t\t\tif (duration2) {\r\n\t\t\t\toption2.duration = duration2;\r\n\t\t\t\toption2.tempDuration = duration2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Handle currency fields\r\n\t\tif (fieldType === \"currency\") {\r\n\t\t\toption1.currency = \"USD\";\r\n\t\t\toption2.currency = \"USD\";\r\n\t\t}\r\n\r\n\t\t// Handle numeric fields with glideStringInput\r\n\t\tif ((fieldType === \"integer\" || fieldType === \"float\" || fieldType === \"decimal\") && value1) {\r\n\t\t\toption1.glideStringInput = value1;\r\n\t\t}\r\n\t\tif ((fieldType === \"integer\" || fieldType === \"float\" || fieldType === \"decimal\") && value2) {\r\n\t\t\toption2.glideStringInput = value2;\r\n\t\t}\r\n\r\n\t\t// Handle reference fields - add icon and avatar properties\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\toption1.icon = false;\r\n\t\t\toption1.avatar = \"\";\r\n\t\t\toption1.color = \"\";\r\n\r\n\t\t\toption2.icon = false;\r\n\t\t\toption2.avatar = \"\";\r\n\t\t\toption2.color = \"\";\r\n\r\n\t\t\t// Add reference-specific properties from references array\r\n\t\t\tif (references.length > 0) {\r\n\t\t\t\tfor (var j = 0; j < references.length; j++) {\r\n\t\t\t\t\tif (references[j].value === value1) {\r\n\t\t\t\t\t\toption1.avatar = references[j].avatar || \"\";\r\n\t\t\t\t\t\toption1.color = references[j].color || \"\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var k = 0; k < references.length; k++) {\r\n\t\t\t\t\tif (references[k].value === value2) {\r\n\t\t\t\t\t\toption2.avatar = references[k].avatar || \"\";\r\n\t\t\t\t\t\toption2.color = references[k].color || \"\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn [option1, option2];\r\n\t},\r\n\r\n\t_formatValues: function ({ parsedValues, fieldType, operator, Utils, fieldName, refTable }) {\r\n\t\tvar values = parsedValues.values.slice();\r\n\t\tvar labels = parsedValues.labels.slice();\r\n\r\n\t\t// Format boolean values\r\n\t\tif (fieldType === \"boolean\") {\r\n\t\t\tfor (var i = 0; i < values.length; i++) {\r\n\t\t\t\tif (values[i]) {\r\n\t\t\t\t\tlabels[i] = Utils.formatBooleanLabel(values[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Format date labels\r\n\t\tif (fieldType === \"glide_date_time\" && operator.dateOperator) {\r\n\t\t\tfor (var i = 0; i < values.length; i++) {\r\n\t\t\t\tif (labels[i] && labels[i] !== \"Today\") {\r\n\t\t\t\t\tlabels[i] = Utils.formatDateLabel(labels[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Format reference field labels - get display value\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\tfor (var i = 0; i < values.length; i++) {\r\n\t\t\t\tif (values[i]) {\r\n\t\t\t\t\t// Try to get the display value for the reference\r\n\t\t\t\t\tlabels[i] = Utils.getReferenceLabel(values[i], refTable, fieldName);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tvalues: values,\r\n\t\t\tlabels: labels,\r\n\t\t};\r\n\t},\r\n\r\n\t_isChoiceField: function (fieldName, fieldType) {\r\n\t\t// Check if it's a choice field\r\n\t\treturn (\r\n\t\t\tfieldType === \"choice\" ||\r\n\t\t\tfieldName === \"priority\" ||\r\n\t\t\tfieldName === \"state\" ||\r\n\t\t\tfieldName === \"impact\" ||\r\n\t\t\tfieldName === \"urgency\" ||\r\n\t\t\tfieldName === \"approval\"\r\n\t\t);\r\n\t},\r\n\r\n\t_getRefTable: function (fieldName, fieldType) {\r\n\t\t// Return reference table for reference fields\r\n\t\tif (fieldType !== \"reference\") {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Common reference field mappings\r\n\t\tif (fieldName === \"assigned_to\" || fieldName === \"caller_id\" || fieldName.indexOf(\"_by\") > -1) {\r\n\t\t\treturn \"sys_user\";\r\n\t\t}\r\n\t\tif (fieldName === \"assignment_group\") {\r\n\t\t\treturn \"sys_user_group\";\r\n\t\t}\r\n\t\tif (fieldName === \"template\") {\r\n\t\t\treturn \"x_cadso_automate_content_template\";\r\n\t\t}\r\n\t\tif (fieldName === \"company\") {\r\n\t\t\treturn \"core_company\";\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\t_inferFieldType: function (fieldName, operator, value) {\r\n\t\t// Check for date operators\r\n\t\tif (operator.dateOperator) {\r\n\t\t\treturn \"glide_date_time\";\r\n\t\t}\r\n\r\n\t\t// Check for common field patterns\r\n\t\tif (\r\n\t\t\tfieldName.indexOf(\"date\") > -1 ||\r\n\t\t\tfieldName.indexOf(\"time\") > -1 ||\r\n\t\t\tfieldName === \"go_live\" ||\r\n\t\t\tfieldName === \"opened_at\" ||\r\n\t\t\tfieldName === \"closed_at\" ||\r\n\t\t\tfieldName === \"resolved_at\"\r\n\t\t) {\r\n\t\t\treturn \"glide_date_time\";\r\n\t\t}\r\n\r\n\t\t// Choice fields\r\n\t\tif (\r\n\t\t\tfieldName === \"priority\" ||\r\n\t\t\tfieldName === \"state\" ||\r\n\t\t\tfieldName === \"impact\" ||\r\n\t\t\tfieldName === \"urgency\" ||\r\n\t\t\tfieldName === \"approval\" ||\r\n\t\t\tfieldName === \"contact_type\"\r\n\t\t) {\r\n\t\t\treturn \"choice\";\r\n\t\t}\r\n\r\n\t\t// Reference fields\r\n\t\tif (\r\n\t\t\tfieldName.indexOf(\"_by\") > -1 ||\r\n\t\t\tfieldName === \"assigned_to\" ||\r\n\t\t\tfieldName === \"caller_id\" ||\r\n\t\t\tfieldName === \"template\" ||\r\n\t\t\tfieldName === \"assignment_group\" ||\r\n\t\t\tfieldName === \"company\" ||\r\n\t\t\tfieldName === \"opened_by\" ||\r\n\t\t\tfieldName === \"closed_by\" ||\r\n\t\t\tfieldName === \"resolved_by\"\r\n\t\t) {\r\n\t\t\treturn \"reference\";\r\n\t\t}\r\n\r\n\t\t// Boolean fields\r\n\t\tif (\r\n\t\t\tfieldName === \"active\" ||\r\n\t\t\tfieldName === \"ad_hoc\" ||\r\n\t\t\tfieldName === \"made_sla\" ||\r\n\t\t\tfieldName === \"upon_approval\" ||\r\n\t\t\tfieldName === \"upon_reject\" ||\r\n\t\t\tfieldName.indexOf(\"is_\") === 0 ||\r\n\t\t\tfieldName.indexOf(\"has_\") === 0\r\n\t\t) {\r\n\t\t\treturn \"boolean\";\r\n\t\t}\r\n\r\n\t\t// Float fields\r\n\t\tif (\r\n\t\t\tfieldName === \"actual_hours\" ||\r\n\t\t\tfieldName === \"business_duration\" ||\r\n\t\t\tfieldName === \"calendar_duration\" ||\r\n\t\t\tfieldName.indexOf(\"_hours\") > -1\r\n\t\t) {\r\n\t\t\treturn \"float\";\r\n\t\t}\r\n\r\n\t\t// Integer fields\r\n\t\tif (\r\n\t\t\tfieldName === \"number\" ||\r\n\t\t\tfieldName === \"order\" ||\r\n\t\t\tfieldName === \"sys_mod_count\" ||\r\n\t\t\tfieldName.indexOf(\"count\") > -1\r\n\t\t) {\r\n\t\t\treturn \"integer\";\r\n\t\t}\r\n\r\n\t\t// Default to string\r\n\t\treturn \"string\";\r\n\t},\r\n\r\n\t_humanizeFieldName: function (fieldName) {\r\n\t\t// Convert field_name to Field Name\r\n\t\tvar words = fieldName.split(\"_\");\r\n\t\tvar humanized = [];\r\n\r\n\t\tfor (var i = 0; i < words.length; i++) {\r\n\t\t\tif (words[i]) {\r\n\t\t\t\thumanized.push(words[i].charAt(0).toUpperCase() + words[i].slice(1));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn humanized.join(\" \");\r\n\t},\r\n\r\n\t/**\r\n\t * Test function to verify the implementation\r\n\t * @param {string} encodedQuery - The encoded query to test\r\n\t * @returns {string} JSON representation of the result\r\n\t */\r\n\ttest: function (encodedQuery) {\r\n\t\tvar result = this.convert(encodedQuery);\r\n\t\treturn JSON.stringify(result, null, 2);\r\n\t},\r\n\r\n\t/**\r\n\t * Legacy convert function that returns flat FilterCondition array\r\n\t * @param {string} condition - The encoded query to convert\r\n\t * @returns {Array} Array of FilterCondition objects\r\n\t */\r\n\tconvertToFlat: function (condition) {\r\n\t\tvar filterGroups = this.convert(condition);\r\n\t\tvar allConditions = [];\r\n\r\n\t\tfor (var i = 0; i < filterGroups.length; i++) {\r\n\t\t\tif (filterGroups[i].filters) {\r\n\t\t\t\tallConditions = allConditions.concat(filterGroups[i].filters);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn allConditions;\r\n\t},\r\n\r\n\t/**\r\n\t * Retrieves actual field metadata from ServiceNow tables\r\n\t * Similar to GetTableDropdownsData implementation\r\n\t * @param {string} table - The table name\r\n\t * @param {string} fieldName - The field element name\r\n\t * @returns {Object} Field metadata object with actual ServiceNow properties\r\n\t */\r\n\t_getActualFieldMetadata: function (table, fieldName) {\r\n\t\t// Check cache first\r\n\t\tvar cacheKey = table;\r\n\t\tif (this.fieldMetadataCache[cacheKey] && this.fieldMetadataCache[cacheKey][fieldName]) {\r\n\t\t\treturn this.fieldMetadataCache[cacheKey][fieldName];\r\n\t\t}\r\n\r\n\t\t// Load cache if not already loaded for this table\r\n\t\tif (!this.fieldMetadataCache[cacheKey]) {\r\n\t\t\tthis._loadFieldMetadataCache(table);\r\n\t\t}\r\n\r\n\t\t// Return from cache or default metadata\r\n\t\tif (this.fieldMetadataCache[cacheKey] && this.fieldMetadataCache[cacheKey][fieldName]) {\r\n\t\t\treturn this.fieldMetadataCache[cacheKey][fieldName];\r\n\t\t}\r\n\r\n\t\t// Return default metadata if field not found\r\n\t\treturn {\r\n\t\t\tname: fieldName,\r\n\t\t\tvalue: fieldName,\r\n\t\t\tdisplayValue: this._humanizeFieldName(fieldName),\r\n\t\t\ttype: \"string\",\r\n\t\t\tisChoice: false,\r\n\t\t\tchoices: [],\r\n\t\t\treferences: [],\r\n\t\t\trefTable: null,\r\n\t\t\treference: null,\r\n\t\t\tcanWrite: false,\r\n\t\t\tcanClear: false,\r\n\t\t\tcanSearch: false,\r\n\t\t\tmaxLength: null,\r\n\t\t\tisRelatedFilter: false,\r\n\t\t\trelatedFilter: {},\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Load field metadata cache for a table\r\n\t * @param {string} table - The table name\r\n\t */\r\n\t_loadFieldMetadataCache: function (table) {\r\n\t\tif (!table) return;\r\n\r\n\t\ttry {\r\n\t\t\t// Use GetTableDropdownsData to get comprehensive field metadata\r\n\t\t\tvar fieldsMetaData = this.GetTableDropdownsData.getData(table, false, true);\r\n\r\n\t\t\t// Initialize cache for this table\r\n\t\t\tthis.fieldMetadataCache[table] = {};\r\n\r\n\t\t\t// Process each field\r\n\t\t\tfor (var fieldName in fieldsMetaData) {\r\n\t\t\t\tif (fieldsMetaData.hasOwnProperty(fieldName)) {\r\n\t\t\t\t\tvar fieldData = fieldsMetaData[fieldName];\r\n\r\n\t\t\t\t\t// Store enhanced metadata\r\n\t\t\t\t\tthis.fieldMetadataCache[table][fieldName] = {\r\n\t\t\t\t\t\tname: fieldData.name || fieldName,\r\n\t\t\t\t\t\tvalue: fieldData.value || fieldName,\r\n\t\t\t\t\t\tdisplayValue: fieldData.displayValue || fieldData.name || this._humanizeFieldName(fieldName),\r\n\t\t\t\t\t\ttype: fieldData.type || \"string\",\r\n\t\t\t\t\t\tisChoice: fieldData.isChoice || false,\r\n\t\t\t\t\t\tchoices: fieldData.choices || [],\r\n\t\t\t\t\t\treferences: fieldData.references || [],\r\n\t\t\t\t\t\trefTable: fieldData.refTable || fieldData.reference || null,\r\n\t\t\t\t\t\treference: fieldData.reference || fieldData.refTable || null,\r\n\t\t\t\t\t\tcanWrite: fieldData.canWrite !== undefined ? fieldData.canWrite : true,\r\n\t\t\t\t\t\tcanClear: fieldData.canClear !== undefined ? fieldData.canClear : true,\r\n\t\t\t\t\t\tcanSearch: fieldData.canSearch !== undefined ? fieldData.canSearch : true,\r\n\t\t\t\t\t\tmaxLength: fieldData.maxLength || this._getDefaultMaxLength(fieldData.type),\r\n\t\t\t\t\t\tisRelatedFilter: fieldData.isRelatedFilter || false,\r\n\t\t\t\t\t\trelatedFilter: fieldData.relatedFilter || {},\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tgs.error(\"ConditionBuilderMS: Error loading field metadata cache for table \" + table + \": \" + e);\r\n\t\t\tthis.fieldMetadataCache[table] = {};\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Get default max length for a field type\r\n\t * @param {string} fieldType - The field type\r\n\t * @returns {string} Default max length\r\n\t */\r\n\t_getDefaultMaxLength: function (fieldType) {\r\n\t\tswitch (fieldType) {\r\n\t\t\tcase \"reference\":\r\n\t\t\t\treturn \"32\";\r\n\t\t\tcase \"boolean\":\r\n\t\t\t\treturn \"40\";\r\n\t\t\tcase \"integer\":\r\n\t\t\t\treturn \"15\";\r\n\t\t\tcase \"float\":\r\n\t\t\t\treturn \"15\";\r\n\t\t\tcase \"currency\":\r\n\t\t\t\treturn \"20\";\r\n\t\t\tcase \"glide_date_time\":\r\n\t\t\t\treturn \"40\";\r\n\t\t\tcase \"glide_date\":\r\n\t\t\t\treturn \"10\";\r\n\t\t\tcase \"glide_time\":\r\n\t\t\t\treturn \"15\";\r\n\t\t\tcase \"glide_duration\":\r\n\t\t\t\treturn \"40\";\r\n\t\t\tdefault:\r\n\t\t\t\treturn \"40\";\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Get choice values for a choice field\r\n\t * @param {string} table - The table name\r\n\t * @param {string} fieldName - The field element name\r\n\t * @returns {Array} Array of choice objects\r\n\t */\r\n\t_getChoiceValues: function (table, fieldName) {\r\n\t\tvar choices = [];\r\n\r\n\t\ttry {\r\n\t\t\tvar choiceGR = new GlideRecordSecure(\"sys_choice\");\r\n\t\t\tchoiceGR.addQuery(\"name\", table);\r\n\t\t\tchoiceGR.addQuery(\"element\", fieldName);\r\n\t\t\tchoiceGR.addQuery(\"inactive\", false);\r\n\t\t\tchoiceGR.addQuery(\"language\", \"en\"); // TODO: Support multiple languages\r\n\t\t\tchoiceGR.orderBy(\"sequence\");\r\n\t\t\tchoiceGR.orderBy(\"value\");\r\n\t\t\tchoiceGR.query();\r\n\r\n\t\t\twhile (choiceGR.next()) {\r\n\t\t\t\tchoices.push({\r\n\t\t\t\t\tlabel: choiceGR.getValue(\"label\"),\r\n\t\t\t\t\tvalue: choiceGR.getValue(\"value\"),\r\n\t\t\t\t\tcolor: \"\",\r\n\t\t\t\t\tclassName: \"\",\r\n\t\t\t\t\ticon: false,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If no choices found, check task table (for inherited fields)\r\n\t\t\tif (choices.length === 0 && table !== \"task\") {\r\n\t\t\t\tchoiceGR = new GlideRecordSecure(\"sys_choice\");\r\n\t\t\t\tchoiceGR.addQuery(\"name\", \"task\");\r\n\t\t\t\tchoiceGR.addQuery(\"element\", fieldName);\r\n\t\t\t\tchoiceGR.addQuery(\"inactive\", false);\r\n\t\t\t\tchoiceGR.addQuery(\"language\", \"en\");\r\n\t\t\t\tchoiceGR.orderBy(\"sequence\");\r\n\t\t\t\tchoiceGR.orderBy(\"value\");\r\n\t\t\t\tchoiceGR.query();\r\n\r\n\t\t\t\twhile (choiceGR.next()) {\r\n\t\t\t\t\tchoices.push({\r\n\t\t\t\t\t\tlabel: choiceGR.getValue(\"label\"),\r\n\t\t\t\t\t\tvalue: choiceGR.getValue(\"value\"),\r\n\t\t\t\t\t\tcolor: \"\",\r\n\t\t\t\t\t\tclassName: \"\",\r\n\t\t\t\t\t\ticon: false,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tgs.error(\"ConditionBuilderMS: Error getting choice values for \" + table + \".\" + fieldName + \": \" + e);\r\n\t\t}\r\n\r\n\t\treturn choices;\r\n\t},\r\n\r\n\t/**\r\n\t * Get initial reference values for a reference field\r\n\t * @param {string} refTable - The reference table name\r\n\t * @param {string} table - The source table name\r\n\t * @param {string} fieldName - The field element name\r\n\t * @returns {Array} Array of reference objects\r\n\t */\r\n\t_getInitialReferences: function (refTable, table, fieldName) {\r\n\t\tvar references = [];\r\n\r\n\t\ttry {\r\n\t\t\t// Get reference qualifier if any\r\n\t\t\tvar referenceQualifier = \"\";\r\n\t\t\tvar refQualOverrideGR = new GlideRecord(\"sys_dictionary_override\");\r\n\t\t\trefQualOverrideGR.addQuery(\"name\", table);\r\n\t\t\trefQualOverrideGR.addQuery(\"element\", fieldName);\r\n\t\t\trefQualOverrideGR.query();\r\n\t\t\tif (refQualOverrideGR.next()) {\r\n\t\t\t\tif (refQualOverrideGR.getValue(\"reference_qual_override\") === \"1\") {\r\n\t\t\t\t\tvar refQual = refQualOverrideGR.getValue(\"reference_qual\");\r\n\t\t\t\t\tif (refQual && !refQual.includes(\"javascript:\")) {\r\n\t\t\t\t\t\treferenceQualifier = refQual;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Query reference table for initial values\r\n\t\t\tvar refGR = new GlideRecordSecure(refTable);\r\n\t\t\tif (referenceQualifier) {\r\n\t\t\t\trefGR.addEncodedQuery(referenceQualifier);\r\n\t\t\t}\r\n\t\t\trefGR.orderBy(refGR.getDisplayName());\r\n\t\t\trefGR.setLimit(12); // Limit to 12 like GetTableDropdownsData\r\n\t\t\trefGR.query();\r\n\r\n\t\t\twhile (refGR.next()) {\r\n\t\t\t\tvar refObj = {\r\n\t\t\t\t\tlabel: refGR.getDisplayValue() || \"Empty\",\r\n\t\t\t\t\tvalue: refGR.getValue(\"sys_id\"),\r\n\t\t\t\t\trefTable: refTable,\r\n\t\t\t\t\ticon: false,\r\n\t\t\t\t\tcolor: \"\",\r\n\t\t\t\t\tclassName: \"\",\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Special handling for sys_user (add avatar)\r\n\t\t\t\tif (refTable === \"sys_user\") {\r\n\t\t\t\t\tvar avatar = refGR.getValue(\"avatar\");\r\n\t\t\t\t\tvar photo = refGR.getValue(\"photo\");\r\n\t\t\t\t\trefObj.avatar = avatar || photo ? (avatar || photo) + \".iix\" : \"\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Special handling for tables with color fields\r\n\t\t\t\tif (\"x_cadso_work_status,x_cadso_work_project,x_cadso_work_campaign\".indexOf(refTable) > -1) {\r\n\t\t\t\t\tvar colorField = refTable === \"x_cadso_work_status\" ? \"color\" : \"glyph_color\";\r\n\t\t\t\t\trefObj.color = refGR.getValue(colorField) || \"\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\treferences.push(refObj);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tgs.error(\"ConditionBuilderMS: Error getting reference values for \" + refTable + \": \" + e);\r\n\t\t}\r\n\r\n\t\treturn references;\r\n\t},\r\n\r\n\t/**\r\n\t * Format value based on field type\r\n\t * @param {string} value - The value to format\r\n\t * @param {string} fieldType - The field type\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {string|Object} Formatted value\r\n\t */\r\n\t_formatValueByType: function (value, fieldType, operator) {\r\n\t\tif (!value) return value;\r\n\r\n\t\tvar Utils = this.Utils;\r\n\r\n\t\t// Handle special date values\r\n\t\tif (fieldType === \"glide_date_time\" || fieldType === \"glide_date\") {\r\n\t\t\tvar formatted = Utils.handleSpecialDateValue(value, operator);\r\n\t\t\tif (formatted !== value) {\r\n\t\t\t\treturn formatted;\r\n\t\t\t}\r\n\r\n\t\t\t// Format date time values\r\n\t\t\tif (operator === \"ON\" && value.indexOf(\"@\") > -1) {\r\n\t\t\t\treturn value; // Keep full value with javascript expressions\r\n\t\t\t}\r\n\r\n\t\t\treturn Utils.formatDateTimeValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle boolean values\r\n\t\tif (fieldType === \"boolean\") {\r\n\t\t\treturn value.toLowerCase() === \"true\" || value === \"1\" ? \"true\" : \"false\";\r\n\t\t}\r\n\r\n\t\t// Handle choice values\r\n\t\tif (fieldType === \"choice\") {\r\n\t\t\treturn Utils.formatChoiceValue(value, this.currentTable, fieldType);\r\n\t\t}\r\n\r\n\t\t// Handle currency values\r\n\t\tif (fieldType === \"currency\") {\r\n\t\t\treturn Utils.formatCurrencyValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle duration values\r\n\t\tif (fieldType === \"glide_duration\") {\r\n\t\t\treturn Utils.formatDurationValue(value);\r\n\t\t}\r\n\r\n\t\t// Handle reference values - keep sys_id\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Handle numeric fields\r\n\t\tif (fieldType === \"integer\" || fieldType === \"float\" || fieldType === \"decimal\") {\r\n\t\t\t// Keep numeric values as strings for proper handling\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Default - return as is\r\n\t\treturn value;\r\n\t},\r\n\r\n\ttype: \"ConditionBuilderMS\",\r\n};\r\n",
    "display_value": "/**\r\n * ConditionBuilderMS - Converts ServiceNow encoded queries to FilterGroup array\r\n *\r\n * Returns FilterGroup[] structure:\r\n * {\r\n *   filterGroupDisplayValue: string,  // Display name for the filter group\r\n *   filterGroupIndex: number,          // Index position of the group\r\n *   filters: FilterCondition[],        // Array of filter conditions\r\n *   collapsed: boolean                 // UI state for group collapse\r\n * }\r\n *\r\n * The ^NQ separator creates separate FilterGroups.\r\n * Queries without ^NQ return a single FilterGroup containing all conditions.\r\n *\r\n * @example\r\n * // Single group (no NQ)\r\n * convert(\"priority=1^state=2\") returns:\r\n * [{\r\n *   filterGroupDisplayValue: \"Filter Group 1\",\r\n *   filterGroupIndex: 0,\r\n *   filters: [condition1, condition2],\r\n *   collapsed: false\r\n * }]\r\n *\r\n * @example\r\n * // Multiple groups (with NQ)\r\n * convert(\"priority=1^NQstate=2\") returns:\r\n * [{\r\n *   filterGroupDisplayValue: \"Filter Group 1\",\r\n *   filterGroupIndex: 0,\r\n *   filters: [condition1],\r\n *   collapsed: false\r\n * }, {\r\n *   filterGroupDisplayValue: \"Filter Group 2\",\r\n *   filterGroupIndex: 1,\r\n *   filters: [condition2],\r\n *   collapsed: false\r\n * }]\r\n */\r\nvar ConditionBuilderMS = Class.create();\r\nConditionBuilderMS.prototype = {\r\n\tinitialize: function () {\r\n\t\tthis.Utils = new x_cadso_core.ConditionBuilderUtilsMS();\r\n\t\tthis.GetTableDropdownsData = new x_cadso_work.GetTableDropdownsData();\r\n\t\tthis.fieldMetadataCache = {};\r\n\t\tthis.language = gs.getSession().getLanguage();\r\n\t\t// ServiceNow operators mapping\r\n\t\tvar CF_Tables = new x_cadso_work.TenonComplexFilterTables();\r\n\t\tthis.tableMap = {\r\n\t\t\troutes: CF_Tables.routes,\r\n\t\t\toperations: CF_Tables.operations,\r\n\t\t\toperationTable: CF_Tables.operationTable,\r\n\t\t\toperators: CF_Tables.operators,\r\n\t\t\tbooleanTable: CF_Tables.booleanTable,\r\n\t\t\tglideDateTimeTable: CF_Tables.glideDateTimeTable,\r\n\t\t\tcurrencyTable: CF_Tables.currencyTable,\r\n\t\t};\r\n\t\tthis.operators = {\r\n\t\t\t// Equality operators\r\n\t\t\t\"=\": { type: \"equals\", label: \"is\", needsValue: true },\r\n\t\t\t\"!=\": { type: \"not_equals\", label: \"is not\", needsValue: true },\r\n\r\n\t\t\t// Comparison operators\r\n\t\t\t\">\": { type: \"greater_than\", label: \">\", needsValue: true },\r\n\t\t\t\">=\": { type: \"greater_than_or_equal\", label: \">=\", needsValue: true },\r\n\t\t\t\"<\": { type: \"less_than\", label: \"<\", needsValue: true },\r\n\t\t\t\"<=\": { type: \"less_than_or_equal\", label: \"<=\", needsValue: true },\r\n\r\n\t\t\t// String operators\r\n\t\t\tCONTAINS: { type: \"contains\", label: \"contains\", needsValue: true },\r\n\t\t\t\"DOES NOT CONTAIN\": { type: \"does_not_contain\", label: \"does not contain\", needsValue: true },\r\n\t\t\tSTARTSWITH: { type: \"starts_with\", label: \"starts with\", needsValue: true },\r\n\t\t\tENDSWITH: { type: \"ends_with\", label: \"ends with\", needsValue: true },\r\n\t\t\tLIKE: { type: \"like\", label: \"contains\", needsValue: true },\r\n\t\t\t\"NOT LIKE\": { type: \"not_like\", label: \"does not contain\", needsValue: true },\r\n\r\n\t\t\t// List operators\r\n\t\t\tIN: { type: \"in\", label: \"is one of\", needsValue: true, multiValue: true },\r\n\t\t\t\"NOT IN\": { type: \"not_in\", label: \"is not one of\", needsValue: true, multiValue: true },\r\n\r\n\t\t\t// Empty/null operators\r\n\t\t\tISEMPTY: { type: \"is_empty\", label: \"is empty\", needsValue: false },\r\n\t\t\tISNOTEMPTY: { type: \"is_not_empty\", label: \"is not empty\", needsValue: false },\r\n\t\t\tANYTHING: { type: \"anything\", label: \"is anything\", needsValue: false },\r\n\t\t\tEMPTYSTRING: { type: \"empty_string\", label: \"is empty string\", needsValue: false },\r\n\r\n\t\t\t// Date operators\r\n\t\t\tON: { type: \"on\", label: \"on\", needsValue: true, dateOperator: true },\r\n\t\t\tBETWEEN: {\r\n\t\t\t\ttype: \"between\",\r\n\t\t\t\tlabel: \"between\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tmultiValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVE: { type: \"relative\", label: \"relative\", needsValue: true, dateOperator: true },\r\n\t\t\tRELATIVEGT: {\r\n\t\t\t\ttype: \"relative_gt\",\r\n\t\t\t\tlabel: \"relative >\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVELT: {\r\n\t\t\t\ttype: \"relative_lt\",\r\n\t\t\t\tlabel: \"relative <\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVEGE: {\r\n\t\t\t\ttype: \"relative_ge\",\r\n\t\t\t\tlabel: \"relative >=\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVELE: {\r\n\t\t\t\ttype: \"relative_le\",\r\n\t\t\t\tlabel: \"relative <=\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tDATEPART: {\r\n\t\t\t\ttype: \"date_part\",\r\n\t\t\t\tlabel: \"date part\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tmultiValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tSAMEAS: { type: \"same_as\", label: \"same as\", needsValue: true, dateOperator: true },\r\n\t\t\tNSAMEAS: { type: \"not_same_as\", label: \"not same as\", needsValue: true, dateOperator: true },\r\n\t\t\tMORETHAN: { type: \"more_than\", label: \"more than\", needsValue: true, dateOperator: true },\r\n\t\t\tLESSTHAN: {\r\n\t\t\t\ttype: \"less_than_duration\",\r\n\t\t\t\tlabel: \"less than\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\r\n\t\t\t// JavaScript operators\r\n\t\t\tDYNAMIC: { type: \"dynamic\", label: \"dynamic\", needsValue: true },\r\n\t\t\tSCRIPT: { type: \"script\", label: \"script\", needsValue: true },\r\n\r\n\t\t\t// Currency operators\r\n\t\t\tVALCHANGES: { type: \"value_changes\", label: \"changes\", needsValue: false },\r\n\t\t\tVALCHANGESTO: { type: \"value_changes_to\", label: \"changes to\", needsValue: true },\r\n\t\t\tVALCHANGESFROM: { type: \"value_changes_from\", label: \"changes from\", needsValue: true },\r\n\r\n\t\t\t// Reference operators\r\n\t\t\tINSTANCEOF: { type: \"instance_of\", label: \"is a\", needsValue: true },\r\n\t\t\t\"NOT INSTANCEOF\": { type: \"not_instance_of\", label: \"is not a\", needsValue: true },\r\n\r\n\t\t\t// Duration operators\r\n\t\t\tDURATION: { type: \"duration\", label: \"duration\", needsValue: true },\r\n\t\t};\r\n\t},\r\n\r\n\tconvert: function (condition, table) {\r\n\t\tif (!condition || typeof condition !== \"string\") {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\t// Store table for metadata lookups\r\n\t\tthis.currentTable = table || null;\r\n\r\n\t\t// Clear metadata cache for new conversion\r\n\t\tthis.fieldMetadataCache = {};\r\n\r\n\t\ttry {\r\n\t\t\t// Split by ^NQ to get separate condition groups\r\n\t\t\tvar queryGroups = this._splitByNQ(condition);\r\n\t\t\tvar filterGroups = [];\r\n\t\t\tvar conditionId = 0;\r\n\r\n\t\t\tfor (var groupIndex = 0; groupIndex < queryGroups.length; groupIndex++) {\r\n\t\t\t\tvar isFirstGroup = groupIndex === 0;\r\n\t\t\t\tvar groupConditions = this._parseConditionGroup(queryGroups[groupIndex], conditionId, isFirstGroup);\r\n\r\n\t\t\t\t// Create a FilterGroup for this set of conditions\r\n\t\t\t\tif (groupConditions.length > 0) {\r\n\t\t\t\t\tvar filterGroup = {\r\n\t\t\t\t\t\tfilterGroupDisplayValue: \"Filter Group \" + (groupIndex + 1),\r\n\t\t\t\t\t\tfilterGroupIndex: groupIndex,\r\n\t\t\t\t\t\tfilters: groupConditions,\r\n\t\t\t\t\t\tcollapsed: false,\r\n\t\t\t\t\t};\r\n\t\t\t\t\tfilterGroups.push(filterGroup);\r\n\t\t\t\t\tconditionId += groupConditions.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Reverse the filter groups array to match expected order\r\n\t\t\tfilterGroups.reverse();\r\n\r\n\t\t\t// Update the display values and indices after reversing\r\n\t\t\tfor (var i = 0; i < filterGroups.length; i++) {\r\n\t\t\t\tfilterGroups[i].filterGroupDisplayValue = \"Filter Group \" + (i + 1);\r\n\t\t\t\tfilterGroups[i].filterGroupIndex = i;\r\n\t\t\t}\r\n\r\n\t\t\treturn filterGroups;\r\n\t\t} catch (error) {\r\n\t\t\tgs.error(\"Error converting encoded query: \" + error);\r\n\t\t\treturn [];\r\n\t\t}\r\n\t},\r\n\r\n\t_splitByNQ: function (query) {\r\n\t\tvar parts = query.split(\"^NQ\");\r\n\t\tvar result = [];\r\n\t\tfor (var i = 0; i < parts.length; i++) {\r\n\t\t\tif (parts[i].trim().length > 0) {\r\n\t\t\t\tresult.push(parts[i].trim());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.length > 0 ? result : [query];\r\n\t},\r\n\r\n\t_parseConditionGroup: function (groupQuery, startId, isFirstGroup) {\r\n\t\tvar conditions = [];\r\n\t\tvar currentId = startId || 0;\r\n\r\n\t\t// Check if query contains OR\r\n\t\tvar hasOR = groupQuery.indexOf(\"^OR\") > -1;\r\n\r\n\t\tif (!hasOR) {\r\n\t\t\t// No OR conditions, just parse as regular AND conditions\r\n\t\t\tvar andConditions = this._parseAndConditions(groupQuery, currentId, isFirstGroup);\r\n\t\t\tconditions = conditions.concat(andConditions);\r\n\t\t} else {\r\n\t\t\t// Split by ^OR to handle OR conditions\r\n\t\t\tvar orGroups = this._splitByOR(groupQuery);\r\n\r\n\t\t\tfor (var i = 0; i < orGroups.length; i++) {\r\n\t\t\t\tif (orGroups[i].trim()) {\r\n\t\t\t\t\tvar groupConditions = this._parseAndConditions(orGroups[i], currentId, isFirstGroup && i === 0);\r\n\r\n\t\t\t\t\t// Set operator for conditions\r\n\t\t\t\t\tfor (var j = 0; j < groupConditions.length; j++) {\r\n\t\t\t\t\t\tif (j === 0 && i === 0 && isFirstGroup) {\r\n\t\t\t\t\t\t\tgroupConditions[j].operator = \"\"; // First condition of first group has no operator\r\n\t\t\t\t\t\t} else if (i > 0 && j === 0) {\r\n\t\t\t\t\t\t\tgroupConditions[j].operator = { value: \"OR\", label: \"OR\" }; // First condition of OR group\r\n\t\t\t\t\t\t} else if (j > 0) {\r\n\t\t\t\t\t\t\tgroupConditions[j].operator = { value: \"AND\", label: \"AND\" }; // Subsequent conditions in same group\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcurrentId++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconditions = conditions.concat(groupConditions);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn conditions;\r\n\t},\r\n\r\n\t_splitByOR: function (query) {\r\n\t\tvar parts = [];\r\n\t\tvar currentPart = \"\";\r\n\t\tvar i = 0;\r\n\r\n\t\twhile (i < query.length) {\r\n\t\t\tif (query.substring(i, i + 3) === \"^OR\") {\r\n\t\t\t\tif (currentPart.trim()) {\r\n\t\t\t\t\tparts.push(currentPart.trim());\r\n\t\t\t\t}\r\n\t\t\t\tcurrentPart = \"\";\r\n\t\t\t\ti += 3;\r\n\t\t\t} else {\r\n\t\t\t\tcurrentPart += query.charAt(i);\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (currentPart.trim()) {\r\n\t\t\tparts.push(currentPart.trim());\r\n\t\t}\r\n\r\n\t\treturn parts.length > 0 ? parts : [query];\r\n\t},\r\n\r\n\t_parseAndConditions: function (groupQuery, startId, isFirstInGroup) {\r\n\t\tvar conditionStrings = this._splitByAND(groupQuery);\r\n\t\tvar conditions = [];\r\n\r\n\t\tfor (var i = 0; i < conditionStrings.length; i++) {\r\n\t\t\tvar condition = this._parseIndividualCondition(conditionStrings[i].trim(), startId + i);\r\n\t\t\tif (condition) {\r\n\t\t\t\t// Set operator based on position\r\n\t\t\t\tif (i === 0 && isFirstInGroup) {\r\n\t\t\t\t\tcondition.operator = \"\"; // First condition of first group has no operator\r\n\t\t\t\t} else if (i > 0) {\r\n\t\t\t\t\tcondition.operator = { value: \"AND\", label: \"AND\" }; // Subsequent conditions use AND\r\n\t\t\t\t}\r\n\t\t\t\t// Note: operator will be overridden by _parseConditionGroup for OR conditions\r\n\t\t\t\tconditions.push(condition);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn conditions;\r\n\t},\r\n\r\n\t_splitByAND: function (query) {\r\n\t\tvar parts = [];\r\n\t\tvar currentPart = \"\";\r\n\t\tvar i = 0;\r\n\r\n\t\twhile (i < query.length) {\r\n\t\t\tif (query.charAt(i) === \"^\") {\r\n\t\t\t\t// Check if this is a standalone AND operator\r\n\t\t\t\tif (this._isStandaloneAND(query, i)) {\r\n\t\t\t\t\tif (currentPart.trim()) {\r\n\t\t\t\t\t\tparts.push(currentPart.trim());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurrentPart = \"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentPart += query.charAt(i);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcurrentPart += query.charAt(i);\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\tif (currentPart.trim()) {\r\n\t\t\tparts.push(currentPart.trim());\r\n\t\t}\r\n\r\n\t\treturn parts.length > 0 ? parts : [query];\r\n\t},\r\n\r\n\t_isStandaloneAND: function (query, position) {\r\n\t\t// Look ahead to see if this is ^OR or ^NQ\r\n\t\tif (position + 2 < query.length) {\r\n\t\t\tvar next2 = query.substring(position, position + 3);\r\n\t\t\tif (next2 === \"^OR\" || next2 === \"^NQ\") {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Look behind to see if this is part of an operator\r\n\t\tif (position > 0) {\r\n\t\t\tvar prev = query.charAt(position - 1);\r\n\t\t\tif (prev === \"=\" || prev === \"!\" || prev === \">\" || prev === \"<\") {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_parseIndividualCondition: function (conditionStr, id) {\r\n\t\t// Find the operator in the condition string\r\n\t\tvar operatorMatch = this._findOperatorInCondition(conditionStr);\r\n\r\n\t\tif (!operatorMatch) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar operator = operatorMatch.operator;\r\n\t\tvar operatorKey = operatorMatch.operatorKey;\r\n\t\tvar startPos = operatorMatch.startPos;\r\n\t\tvar endPos = operatorMatch.endPos;\r\n\r\n\t\t// Extract field and value\r\n\t\tvar field = conditionStr.substring(0, startPos).trim();\r\n\t\tvar value = conditionStr.substring(endPos).trim();\r\n\r\n\t\t// Validate field\r\n\t\tif (!field) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Parse the value based on operator type\r\n\t\tvar parsedValues = this._parseValue(value, operator);\r\n\r\n\t\t// Create FilterCondition object\r\n\t\treturn this._createFilterCondition(id, field, operatorKey, operator, parsedValues);\r\n\t},\r\n\r\n\t_findOperatorInCondition: function (conditionStr) {\r\n\t\t// Sort operators by length (longest first) to match multi-character operators first\r\n\t\tvar sortedOperators = [];\r\n\t\tfor (var key in this.operators) {\r\n\t\t\tsortedOperators.push(key);\r\n\t\t}\r\n\t\tsortedOperators.sort(function (a, b) {\r\n\t\t\treturn b.length - a.length;\r\n\t\t});\r\n\r\n\t\tfor (var i = 0; i < sortedOperators.length; i++) {\r\n\t\t\tvar operatorKey = sortedOperators[i];\r\n\t\t\tvar index = conditionStr.indexOf(operatorKey);\r\n\t\t\tif (index > 0) {\r\n\t\t\t\t// Must have field before operator\r\n\t\t\t\treturn {\r\n\t\t\t\t\toperator: this.operators[operatorKey],\r\n\t\t\t\t\toperatorKey: operatorKey,\r\n\t\t\t\t\tstartPos: index,\r\n\t\t\t\t\tendPos: index + operatorKey.length,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\t_parseValue: function (value, operator) {\r\n\t\tif (!operator.needsValue) {\r\n\t\t\treturn {\r\n\t\t\t\tvalues: [\"\", \"\"],\r\n\t\t\t\tlabels: [\"\", \"\"],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle multi-value operators\r\n\t\tif (operator.multiValue) {\r\n\t\t\treturn this._parseMultiValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle date operators\r\n\t\tif (operator.dateOperator) {\r\n\t\t\treturn this._parseDateValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Default single value\r\n\t\tvar cleanedValue = this._cleanValue(value);\r\n\t\treturn {\r\n\t\t\tvalues: [cleanedValue, \"\"],\r\n\t\t\tlabels: [cleanedValue, \"\"],\r\n\t\t};\r\n\t},\r\n\r\n\t_parseMultiValue: function (value, operator) {\r\n\t\tvar values = [];\r\n\t\tvar labels = [];\r\n\r\n\t\tif (operator.type === \"between\" || operator.type === \"date_part\") {\r\n\t\t\t// BETWEEN and DATEPART use @ as separator\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\tvalues.push(parts[0] ? this._cleanValue(parts[0]) : \"\");\r\n\t\t\tvalues.push(parts[1] ? this._cleanValue(parts[1]) : \"\");\r\n\t\t\tlabels.push(parts[0] ? this._cleanValue(parts[0]) : \"\");\r\n\t\t\tlabels.push(parts[1] ? this._cleanValue(parts[1]) : \"\");\r\n\t\t} else {\r\n\t\t\t// IN/NOT IN use comma separation - combine into first value\r\n\t\t\tvar combinedValue = value;\r\n\t\t\tvalues.push(combinedValue);\r\n\t\t\tvalues.push(\"\");\r\n\t\t\tlabels.push(combinedValue);\r\n\t\t\tlabels.push(\"\");\r\n\t\t}\r\n\r\n\t\t// Ensure we always have exactly 2 values\r\n\t\twhile (values.length < 2) {\r\n\t\t\tvalues.push(\"\");\r\n\t\t\tlabels.push(\"\");\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tvalues: values.slice(0, 2),\r\n\t\t\tlabels: labels.slice(0, 2),\r\n\t\t};\r\n\t},\r\n\r\n\t_parseDateValue: function (value, operator) {\r\n\t\t// Handle BETWEEN with @ separator\r\n\t\tif (operator.type === \"between\" && value.indexOf(\"@\") > -1) {\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\treturn {\r\n\t\t\t\tvalues: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t\tlabels: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle ON with @ separator (date range with javascript expressions)\r\n\t\tif (operator.type === \"on\" && value.indexOf(\"@\") > -1) {\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\t// For ON operator with date range, store the full value\r\n\t\t\t// The label is just the date part\r\n\t\t\tif (parts.length >= 3) {\r\n\t\t\t\t// Format: 2025-08-21@javascript:gs.dateGenerate('2025-08-21','start')@javascript:gs.dateGenerate('2025-08-21','end')\r\n\t\t\t\t// Or: Today@javascript:gs.beginningOfToday()@javascript:gs.endOfToday()\r\n\t\t\t\tvar dateValue = parts[0];\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalues: [value, \"\"], // Full value with javascript expressions\r\n\t\t\t\t\tlabels: [dateValue || \"\", \"\"], // Just the date part for label\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalues: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t\t\tlabels: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check for special value \"Today\"\r\n\t\tif (value === \"Today\") {\r\n\t\t\treturn {\r\n\t\t\t\tvalues: [\"Today\", \"\"],\r\n\t\t\t\tlabels: [\"Today\", \"\"],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Default date value\r\n\t\treturn {\r\n\t\t\tvalues: [value, \"\"],\r\n\t\t\tlabels: [value, \"\"],\r\n\t\t};\r\n\t},\r\n\r\n\t_cleanValue: function (value) {\r\n\t\tif (!value) return \"\";\r\n\r\n\t\t// Remove leading/trailing whitespace\r\n\t\tvalue = value.trim();\r\n\r\n\t\t// Return as-is to preserve the original value\r\n\t\treturn value;\r\n\t},\r\n\r\n\t_createFilterCondition: function (id, fieldName, operatorKey, operator, parsedValues) {\r\n\t\t// Get actual field metadata from ServiceNow if table is provided\r\n\t\tvar actualFieldMetadata = this.currentTable ? this._getActualFieldMetadata(this.currentTable, fieldName) : null;\r\n\r\n\t\t// Use actual metadata if available, otherwise fall back to inference\r\n\t\tvar fieldType =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.type\r\n\t\t\t\t? actualFieldMetadata.type\r\n\t\t\t\t: this._inferFieldType(fieldName, operator, parsedValues.values[0]);\r\n\r\n\t\tvar fieldDisplayName =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.displayValue\r\n\t\t\t\t? actualFieldMetadata.displayValue\r\n\t\t\t\t: this._humanizeFieldName(fieldName);\r\n\r\n\t\tvar isChoice =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.isChoice !== undefined\r\n\t\t\t\t? actualFieldMetadata.isChoice\r\n\t\t\t\t: this._isChoiceField(fieldName, fieldType);\r\n\r\n\t\tvar choices = actualFieldMetadata && actualFieldMetadata.choices ? actualFieldMetadata.choices : [];\r\n\r\n\t\tvar references = actualFieldMetadata && actualFieldMetadata.references ? actualFieldMetadata.references : [];\r\n\r\n\t\tvar refTable =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.refTable\r\n\t\t\t\t? actualFieldMetadata.refTable\r\n\t\t\t\t: this._getRefTable(fieldName, fieldType);\r\n\r\n\t\tvar canWrite =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.canWrite !== undefined ? actualFieldMetadata.canWrite : true;\r\n\r\n\t\tvar canClear =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.canClear !== undefined ? actualFieldMetadata.canClear : true;\r\n\r\n\t\tvar maxLength =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.maxLength\r\n\t\t\t\t? actualFieldMetadata.maxLength\r\n\t\t\t\t: this._getDefaultMaxLength(fieldType);\r\n\r\n\t\t// Build option arrays with proper formatting\r\n\t\tvar options = this._buildOptionArrays({\r\n\t\t\tparsedValues: parsedValues,\r\n\t\t\tfieldType: fieldType,\r\n\t\t\tfieldName: fieldName,\r\n\t\t\toperator: operator,\r\n\t\t\toperatorKey: operatorKey,\r\n\t\t\trefTable: refTable,\r\n\t\t\tchoices: choices,\r\n\t\t\treferences: references,\r\n\t\t});\r\n\r\n\t\treturn {\r\n\t\t\tid: id,\r\n\t\t\tfield: {\r\n\t\t\t\tdisplayValue: fieldDisplayName,\r\n\t\t\t\tname: fieldDisplayName,\r\n\t\t\t\tvalue: fieldName,\r\n\t\t\t\ttype: fieldType,\r\n\t\t\t\tisChoice: isChoice,\r\n\t\t\t\tchoices: choices,\r\n\t\t\t\treferences: references,\r\n\t\t\t\trefTable: refTable,\r\n\t\t\t\treference: refTable, // Add reference property\r\n\t\t\t\tcanWrite: canWrite,\r\n\t\t\t\tcanClear: canClear,\r\n\t\t\t\tcanSearch:\r\n\t\t\t\t\tactualFieldMetadata && actualFieldMetadata.canSearch !== undefined ? actualFieldMetadata.canSearch : true,\r\n\t\t\t\tmaxLength: maxLength,\r\n\t\t\t\tisRelatedFilter:\r\n\t\t\t\t\tactualFieldMetadata && actualFieldMetadata.isRelatedFilter ? actualFieldMetadata.isRelatedFilter : false,\r\n\t\t\t\trelatedFilter:\r\n\t\t\t\t\tactualFieldMetadata && actualFieldMetadata.relatedFilter ? actualFieldMetadata.relatedFilter : {},\r\n\t\t\t},\r\n\t\t\toperator: \"\", // Will be set by the calling function based on position\r\n\t\t\toperation: {\r\n\t\t\t\tlabel: operator.label || operatorKey.toLowerCase(),\r\n\t\t\t\tvalue: operatorKey,\r\n\t\t\t},\r\n\t\t\toption: options,\r\n\t\t\tcanDotWalk: fieldType === \"reference\",\r\n\t\t\tsearchInput: {\r\n\t\t\t\tfieldSeachInputValue: \"\",\r\n\t\t\t\toptionSearchInputValue: \"\",\r\n\t\t\t\ttimeSearchInputValue: \"\",\r\n\t\t\t},\r\n\t\t\tcurrency: fieldType === \"currency\" ? \"USD\" : \"\",\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Build option arrays with proper value formatting\r\n\t * @param {Object} params - Parameters for building options\r\n\t * @returns {Array} Array of two option objects\r\n\t */\r\n\t_buildOptionArrays: function (params) {\r\n\t\tvar parsedValues = params.parsedValues;\r\n\t\tvar fieldType = params.fieldType;\r\n\t\tvar fieldName = params.fieldName;\r\n\t\tvar operator = params.operator;\r\n\t\tvar operatorKey = params.operatorKey;\r\n\t\tvar refTable = params.refTable;\r\n\t\tvar choices = params.choices || [];\r\n\t\tvar references = params.references || [];\r\n\r\n\t\tvar Utils = this.Utils;\r\n\r\n\t\t// Get default option properties\r\n\t\tvar defaultOption1 = Utils.getDefaultOptionProperties(true);\r\n\t\tvar defaultOption2 = Utils.getDefaultOptionProperties(false);\r\n\r\n\t\t// Format values based on field type\r\n\t\tvar value1 = parsedValues.values[0] || \"\";\r\n\t\tvar value2 = parsedValues.values[1] || \"\";\r\n\t\tvar label1 = parsedValues.labels[0] || \"\";\r\n\t\tvar label2 = parsedValues.labels[1] || \"\";\r\n\r\n\t\t// Apply type-specific formatting to values\r\n\t\tif (value1) {\r\n\t\t\tvalue1 = this._formatValueByType(value1, fieldType, operatorKey);\r\n\t\t}\r\n\t\tif (value2) {\r\n\t\t\tvalue2 = this._formatValueByType(value2, fieldType, operatorKey);\r\n\t\t}\r\n\r\n\t\t// Format labels\r\n\t\tif (fieldType === \"boolean\") {\r\n\t\t\tlabel1 = value1 ? Utils.formatBooleanLabel(value1) : \"\";\r\n\t\t\tlabel2 = value2 ? Utils.formatBooleanLabel(value2) : \"\";\r\n\t\t} else if (fieldType === \"glide_date_time\" || fieldType === \"glide_date\") {\r\n\t\t\t// Format date labels\r\n\t\t\tif (label1 && label1 !== \"Today\" && label1 !== \"Yesterday\" && label1 !== \"Tomorrow\") {\r\n\t\t\t\tlabel1 = Utils.formatDateLabel(label1);\r\n\t\t\t}\r\n\t\t\tif (label2 && label2 !== \"Today\" && label2 !== \"Yesterday\" && label2 !== \"Tomorrow\") {\r\n\t\t\t\tlabel2 = Utils.formatDateLabel(label2);\r\n\t\t\t}\r\n\t\t} else if (fieldType === \"reference\") {\r\n\t\t\t// Get reference display values\r\n\t\t\tif (value1) {\r\n\t\t\t\tlabel1 = Utils.getReferenceLabel(value1, refTable, fieldName);\r\n\t\t\t}\r\n\t\t\tif (value2) {\r\n\t\t\t\tlabel2 = Utils.getReferenceLabel(value2, refTable, fieldName);\r\n\t\t\t}\r\n\t\t} else if (fieldType === \"choice\" && choices.length > 0) {\r\n\t\t\t// Get choice labels\r\n\t\t\tfor (var i = 0; i < choices.length; i++) {\r\n\t\t\t\tif (choices[i].value === value1) {\r\n\t\t\t\t\tlabel1 = choices[i].label;\r\n\t\t\t\t}\r\n\t\t\t\tif (choices[i].value === value2) {\r\n\t\t\t\t\tlabel2 = choices[i].label;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Build option1\r\n\t\tvar option1 = {\r\n\t\t\tid: 0,\r\n\t\t\tvalue: value1,\r\n\t\t\tlabel: label1,\r\n\t\t};\r\n\r\n\t\t// Build option2\r\n\t\tvar option2 = {\r\n\t\t\tid: 1,\r\n\t\t\tvalue: value2,\r\n\t\t\tlabel: label2,\r\n\t\t};\r\n\r\n\t\t// Merge with default properties\r\n\t\tfor (var key in defaultOption1) {\r\n\t\t\tif (!(key in option1)) {\r\n\t\t\t\toption1[key] = defaultOption1[key];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var key in defaultOption2) {\r\n\t\t\tif (!(key in option2)) {\r\n\t\t\t\toption2[key] = defaultOption2[key];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Handle special cases for dates\r\n\t\tif ((fieldType === \"glide_date_time\" || fieldType === \"glide_date\") && operator.type === \"on\") {\r\n\t\t\t// Parse selected date if not a special value\r\n\t\t\tif (label1 && label1 !== \"Today\" && label1 !== \"Yesterday\" && label1 !== \"Tomorrow\") {\r\n\t\t\t\toption1.selectedDate = Utils.parseSelectedDate(label1);\r\n\t\t\t}\r\n\r\n\t\t\t// Handle special date values\r\n\t\t\tif (typeof value1 === \"object\") {\r\n\t\t\t\t// Value is already formatted as special date object\r\n\t\t\t\toption1.value = value1;\r\n\t\t\t} else if (value1 && value1.indexOf(\"@\") > -1) {\r\n\t\t\t\t// Keep full value with javascript expressions\r\n\t\t\t\toption1.value = value1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Handle duration fields\r\n\t\tif (fieldType === \"glide_duration\" && value1) {\r\n\t\t\tvar duration1 = Utils.parseDuration(value1);\r\n\t\t\tif (duration1) {\r\n\t\t\t\toption1.duration = duration1;\r\n\t\t\t\toption1.tempDuration = duration1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fieldType === \"glide_duration\" && value2) {\r\n\t\t\tvar duration2 = Utils.parseDuration(value2);\r\n\t\t\tif (duration2) {\r\n\t\t\t\toption2.duration = duration2;\r\n\t\t\t\toption2.tempDuration = duration2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Handle currency fields\r\n\t\tif (fieldType === \"currency\") {\r\n\t\t\toption1.currency = \"USD\";\r\n\t\t\toption2.currency = \"USD\";\r\n\t\t}\r\n\r\n\t\t// Handle numeric fields with glideStringInput\r\n\t\tif ((fieldType === \"integer\" || fieldType === \"float\" || fieldType === \"decimal\") && value1) {\r\n\t\t\toption1.glideStringInput = value1;\r\n\t\t}\r\n\t\tif ((fieldType === \"integer\" || fieldType === \"float\" || fieldType === \"decimal\") && value2) {\r\n\t\t\toption2.glideStringInput = value2;\r\n\t\t}\r\n\r\n\t\t// Handle reference fields - add icon and avatar properties\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\toption1.icon = false;\r\n\t\t\toption1.avatar = \"\";\r\n\t\t\toption1.color = \"\";\r\n\r\n\t\t\toption2.icon = false;\r\n\t\t\toption2.avatar = \"\";\r\n\t\t\toption2.color = \"\";\r\n\r\n\t\t\t// Add reference-specific properties from references array\r\n\t\t\tif (references.length > 0) {\r\n\t\t\t\tfor (var j = 0; j < references.length; j++) {\r\n\t\t\t\t\tif (references[j].value === value1) {\r\n\t\t\t\t\t\toption1.avatar = references[j].avatar || \"\";\r\n\t\t\t\t\t\toption1.color = references[j].color || \"\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var k = 0; k < references.length; k++) {\r\n\t\t\t\t\tif (references[k].value === value2) {\r\n\t\t\t\t\t\toption2.avatar = references[k].avatar || \"\";\r\n\t\t\t\t\t\toption2.color = references[k].color || \"\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn [option1, option2];\r\n\t},\r\n\r\n\t_formatValues: function ({ parsedValues, fieldType, operator, Utils, fieldName, refTable }) {\r\n\t\tvar values = parsedValues.values.slice();\r\n\t\tvar labels = parsedValues.labels.slice();\r\n\r\n\t\t// Format boolean values\r\n\t\tif (fieldType === \"boolean\") {\r\n\t\t\tfor (var i = 0; i < values.length; i++) {\r\n\t\t\t\tif (values[i]) {\r\n\t\t\t\t\tlabels[i] = Utils.formatBooleanLabel(values[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Format date labels\r\n\t\tif (fieldType === \"glide_date_time\" && operator.dateOperator) {\r\n\t\t\tfor (var i = 0; i < values.length; i++) {\r\n\t\t\t\tif (labels[i] && labels[i] !== \"Today\") {\r\n\t\t\t\t\tlabels[i] = Utils.formatDateLabel(labels[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Format reference field labels - get display value\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\tfor (var i = 0; i < values.length; i++) {\r\n\t\t\t\tif (values[i]) {\r\n\t\t\t\t\t// Try to get the display value for the reference\r\n\t\t\t\t\tlabels[i] = Utils.getReferenceLabel(values[i], refTable, fieldName);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tvalues: values,\r\n\t\t\tlabels: labels,\r\n\t\t};\r\n\t},\r\n\r\n\t_isChoiceField: function (fieldName, fieldType) {\r\n\t\t// Check if it's a choice field\r\n\t\treturn (\r\n\t\t\tfieldType === \"choice\" ||\r\n\t\t\tfieldName === \"priority\" ||\r\n\t\t\tfieldName === \"state\" ||\r\n\t\t\tfieldName === \"impact\" ||\r\n\t\t\tfieldName === \"urgency\" ||\r\n\t\t\tfieldName === \"approval\"\r\n\t\t);\r\n\t},\r\n\r\n\t_getRefTable: function (fieldName, fieldType) {\r\n\t\t// Return reference table for reference fields\r\n\t\tif (fieldType !== \"reference\") {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Common reference field mappings\r\n\t\tif (fieldName === \"assigned_to\" || fieldName === \"caller_id\" || fieldName.indexOf(\"_by\") > -1) {\r\n\t\t\treturn \"sys_user\";\r\n\t\t}\r\n\t\tif (fieldName === \"assignment_group\") {\r\n\t\t\treturn \"sys_user_group\";\r\n\t\t}\r\n\t\tif (fieldName === \"template\") {\r\n\t\t\treturn \"x_cadso_automate_content_template\";\r\n\t\t}\r\n\t\tif (fieldName === \"company\") {\r\n\t\t\treturn \"core_company\";\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\t_inferFieldType: function (fieldName, operator, value) {\r\n\t\t// Check for date operators\r\n\t\tif (operator.dateOperator) {\r\n\t\t\treturn \"glide_date_time\";\r\n\t\t}\r\n\r\n\t\t// Check for common field patterns\r\n\t\tif (\r\n\t\t\tfieldName.indexOf(\"date\") > -1 ||\r\n\t\t\tfieldName.indexOf(\"time\") > -1 ||\r\n\t\t\tfieldName === \"go_live\" ||\r\n\t\t\tfieldName === \"opened_at\" ||\r\n\t\t\tfieldName === \"closed_at\" ||\r\n\t\t\tfieldName === \"resolved_at\"\r\n\t\t) {\r\n\t\t\treturn \"glide_date_time\";\r\n\t\t}\r\n\r\n\t\t// Choice fields\r\n\t\tif (\r\n\t\t\tfieldName === \"priority\" ||\r\n\t\t\tfieldName === \"state\" ||\r\n\t\t\tfieldName === \"impact\" ||\r\n\t\t\tfieldName === \"urgency\" ||\r\n\t\t\tfieldName === \"approval\" ||\r\n\t\t\tfieldName === \"contact_type\"\r\n\t\t) {\r\n\t\t\treturn \"choice\";\r\n\t\t}\r\n\r\n\t\t// Reference fields\r\n\t\tif (\r\n\t\t\tfieldName.indexOf(\"_by\") > -1 ||\r\n\t\t\tfieldName === \"assigned_to\" ||\r\n\t\t\tfieldName === \"caller_id\" ||\r\n\t\t\tfieldName === \"template\" ||\r\n\t\t\tfieldName === \"assignment_group\" ||\r\n\t\t\tfieldName === \"company\" ||\r\n\t\t\tfieldName === \"opened_by\" ||\r\n\t\t\tfieldName === \"closed_by\" ||\r\n\t\t\tfieldName === \"resolved_by\"\r\n\t\t) {\r\n\t\t\treturn \"reference\";\r\n\t\t}\r\n\r\n\t\t// Boolean fields\r\n\t\tif (\r\n\t\t\tfieldName === \"active\" ||\r\n\t\t\tfieldName === \"ad_hoc\" ||\r\n\t\t\tfieldName === \"made_sla\" ||\r\n\t\t\tfieldName === \"upon_approval\" ||\r\n\t\t\tfieldName === \"upon_reject\" ||\r\n\t\t\tfieldName.indexOf(\"is_\") === 0 ||\r\n\t\t\tfieldName.indexOf(\"has_\") === 0\r\n\t\t) {\r\n\t\t\treturn \"boolean\";\r\n\t\t}\r\n\r\n\t\t// Float fields\r\n\t\tif (\r\n\t\t\tfieldName === \"actual_hours\" ||\r\n\t\t\tfieldName === \"business_duration\" ||\r\n\t\t\tfieldName === \"calendar_duration\" ||\r\n\t\t\tfieldName.indexOf(\"_hours\") > -1\r\n\t\t) {\r\n\t\t\treturn \"float\";\r\n\t\t}\r\n\r\n\t\t// Integer fields\r\n\t\tif (\r\n\t\t\tfieldName === \"number\" ||\r\n\t\t\tfieldName === \"order\" ||\r\n\t\t\tfieldName === \"sys_mod_count\" ||\r\n\t\t\tfieldName.indexOf(\"count\") > -1\r\n\t\t) {\r\n\t\t\treturn \"integer\";\r\n\t\t}\r\n\r\n\t\t// Default to string\r\n\t\treturn \"string\";\r\n\t},\r\n\r\n\t_humanizeFieldName: function (fieldName) {\r\n\t\t// Convert field_name to Field Name\r\n\t\tvar words = fieldName.split(\"_\");\r\n\t\tvar humanized = [];\r\n\r\n\t\tfor (var i = 0; i < words.length; i++) {\r\n\t\t\tif (words[i]) {\r\n\t\t\t\thumanized.push(words[i].charAt(0).toUpperCase() + words[i].slice(1));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn humanized.join(\" \");\r\n\t},\r\n\r\n\t/**\r\n\t * Test function to verify the implementation\r\n\t * @param {string} encodedQuery - The encoded query to test\r\n\t * @returns {string} JSON representation of the result\r\n\t */\r\n\ttest: function (encodedQuery) {\r\n\t\tvar result = this.convert(encodedQuery);\r\n\t\treturn JSON.stringify(result, null, 2);\r\n\t},\r\n\r\n\t/**\r\n\t * Legacy convert function that returns flat FilterCondition array\r\n\t * @param {string} condition - The encoded query to convert\r\n\t * @returns {Array} Array of FilterCondition objects\r\n\t */\r\n\tconvertToFlat: function (condition) {\r\n\t\tvar filterGroups = this.convert(condition);\r\n\t\tvar allConditions = [];\r\n\r\n\t\tfor (var i = 0; i < filterGroups.length; i++) {\r\n\t\t\tif (filterGroups[i].filters) {\r\n\t\t\t\tallConditions = allConditions.concat(filterGroups[i].filters);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn allConditions;\r\n\t},\r\n\r\n\t/**\r\n\t * Retrieves actual field metadata from ServiceNow tables\r\n\t * Similar to GetTableDropdownsData implementation\r\n\t * @param {string} table - The table name\r\n\t * @param {string} fieldName - The field element name\r\n\t * @returns {Object} Field metadata object with actual ServiceNow properties\r\n\t */\r\n\t_getActualFieldMetadata: function (table, fieldName) {\r\n\t\t// Check cache first\r\n\t\tvar cacheKey = table;\r\n\t\tif (this.fieldMetadataCache[cacheKey] && this.fieldMetadataCache[cacheKey][fieldName]) {\r\n\t\t\treturn this.fieldMetadataCache[cacheKey][fieldName];\r\n\t\t}\r\n\r\n\t\t// Load cache if not already loaded for this table\r\n\t\tif (!this.fieldMetadataCache[cacheKey]) {\r\n\t\t\tthis._loadFieldMetadataCache(table);\r\n\t\t}\r\n\r\n\t\t// Return from cache or default metadata\r\n\t\tif (this.fieldMetadataCache[cacheKey] && this.fieldMetadataCache[cacheKey][fieldName]) {\r\n\t\t\treturn this.fieldMetadataCache[cacheKey][fieldName];\r\n\t\t}\r\n\r\n\t\t// Return default metadata if field not found\r\n\t\treturn {\r\n\t\t\tname: fieldName,\r\n\t\t\tvalue: fieldName,\r\n\t\t\tdisplayValue: this._humanizeFieldName(fieldName),\r\n\t\t\ttype: \"string\",\r\n\t\t\tisChoice: false,\r\n\t\t\tchoices: [],\r\n\t\t\treferences: [],\r\n\t\t\trefTable: null,\r\n\t\t\treference: null,\r\n\t\t\tcanWrite: false,\r\n\t\t\tcanClear: false,\r\n\t\t\tcanSearch: false,\r\n\t\t\tmaxLength: null,\r\n\t\t\tisRelatedFilter: false,\r\n\t\t\trelatedFilter: {},\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Load field metadata cache for a table\r\n\t * @param {string} table - The table name\r\n\t */\r\n\t_loadFieldMetadataCache: function (table) {\r\n\t\tif (!table) return;\r\n\r\n\t\ttry {\r\n\t\t\t// Use GetTableDropdownsData to get comprehensive field metadata\r\n\t\t\tvar fieldsMetaData = this.GetTableDropdownsData.getData(table, false, true);\r\n\r\n\t\t\t// Initialize cache for this table\r\n\t\t\tthis.fieldMetadataCache[table] = {};\r\n\r\n\t\t\t// Process each field\r\n\t\t\tfor (var fieldName in fieldsMetaData) {\r\n\t\t\t\tif (fieldsMetaData.hasOwnProperty(fieldName)) {\r\n\t\t\t\t\tvar fieldData = fieldsMetaData[fieldName];\r\n\r\n\t\t\t\t\t// Store enhanced metadata\r\n\t\t\t\t\tthis.fieldMetadataCache[table][fieldName] = {\r\n\t\t\t\t\t\tname: fieldData.name || fieldName,\r\n\t\t\t\t\t\tvalue: fieldData.value || fieldName,\r\n\t\t\t\t\t\tdisplayValue: fieldData.displayValue || fieldData.name || this._humanizeFieldName(fieldName),\r\n\t\t\t\t\t\ttype: fieldData.type || \"string\",\r\n\t\t\t\t\t\tisChoice: fieldData.isChoice || false,\r\n\t\t\t\t\t\tchoices: fieldData.choices || [],\r\n\t\t\t\t\t\treferences: fieldData.references || [],\r\n\t\t\t\t\t\trefTable: fieldData.refTable || fieldData.reference || null,\r\n\t\t\t\t\t\treference: fieldData.reference || fieldData.refTable || null,\r\n\t\t\t\t\t\tcanWrite: fieldData.canWrite !== undefined ? fieldData.canWrite : true,\r\n\t\t\t\t\t\tcanClear: fieldData.canClear !== undefined ? fieldData.canClear : true,\r\n\t\t\t\t\t\tcanSearch: fieldData.canSearch !== undefined ? fieldData.canSearch : true,\r\n\t\t\t\t\t\tmaxLength: fieldData.maxLength || this._getDefaultMaxLength(fieldData.type),\r\n\t\t\t\t\t\tisRelatedFilter: fieldData.isRelatedFilter || false,\r\n\t\t\t\t\t\trelatedFilter: fieldData.relatedFilter || {},\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tgs.error(\"ConditionBuilderMS: Error loading field metadata cache for table \" + table + \": \" + e);\r\n\t\t\tthis.fieldMetadataCache[table] = {};\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Get default max length for a field type\r\n\t * @param {string} fieldType - The field type\r\n\t * @returns {string} Default max length\r\n\t */\r\n\t_getDefaultMaxLength: function (fieldType) {\r\n\t\tswitch (fieldType) {\r\n\t\t\tcase \"reference\":\r\n\t\t\t\treturn \"32\";\r\n\t\t\tcase \"boolean\":\r\n\t\t\t\treturn \"40\";\r\n\t\t\tcase \"integer\":\r\n\t\t\t\treturn \"15\";\r\n\t\t\tcase \"float\":\r\n\t\t\t\treturn \"15\";\r\n\t\t\tcase \"currency\":\r\n\t\t\t\treturn \"20\";\r\n\t\t\tcase \"glide_date_time\":\r\n\t\t\t\treturn \"40\";\r\n\t\t\tcase \"glide_date\":\r\n\t\t\t\treturn \"10\";\r\n\t\t\tcase \"glide_time\":\r\n\t\t\t\treturn \"15\";\r\n\t\t\tcase \"glide_duration\":\r\n\t\t\t\treturn \"40\";\r\n\t\t\tdefault:\r\n\t\t\t\treturn \"40\";\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Get choice values for a choice field\r\n\t * @param {string} table - The table name\r\n\t * @param {string} fieldName - The field element name\r\n\t * @returns {Array} Array of choice objects\r\n\t */\r\n\t_getChoiceValues: function (table, fieldName) {\r\n\t\tvar choices = [];\r\n\r\n\t\ttry {\r\n\t\t\tvar choiceGR = new GlideRecordSecure(\"sys_choice\");\r\n\t\t\tchoiceGR.addQuery(\"name\", table);\r\n\t\t\tchoiceGR.addQuery(\"element\", fieldName);\r\n\t\t\tchoiceGR.addQuery(\"inactive\", false);\r\n\t\t\tchoiceGR.addQuery(\"language\", \"en\"); // TODO: Support multiple languages\r\n\t\t\tchoiceGR.orderBy(\"sequence\");\r\n\t\t\tchoiceGR.orderBy(\"value\");\r\n\t\t\tchoiceGR.query();\r\n\r\n\t\t\twhile (choiceGR.next()) {\r\n\t\t\t\tchoices.push({\r\n\t\t\t\t\tlabel: choiceGR.getValue(\"label\"),\r\n\t\t\t\t\tvalue: choiceGR.getValue(\"value\"),\r\n\t\t\t\t\tcolor: \"\",\r\n\t\t\t\t\tclassName: \"\",\r\n\t\t\t\t\ticon: false,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If no choices found, check task table (for inherited fields)\r\n\t\t\tif (choices.length === 0 && table !== \"task\") {\r\n\t\t\t\tchoiceGR = new GlideRecordSecure(\"sys_choice\");\r\n\t\t\t\tchoiceGR.addQuery(\"name\", \"task\");\r\n\t\t\t\tchoiceGR.addQuery(\"element\", fieldName);\r\n\t\t\t\tchoiceGR.addQuery(\"inactive\", false);\r\n\t\t\t\tchoiceGR.addQuery(\"language\", \"en\");\r\n\t\t\t\tchoiceGR.orderBy(\"sequence\");\r\n\t\t\t\tchoiceGR.orderBy(\"value\");\r\n\t\t\t\tchoiceGR.query();\r\n\r\n\t\t\t\twhile (choiceGR.next()) {\r\n\t\t\t\t\tchoices.push({\r\n\t\t\t\t\t\tlabel: choiceGR.getValue(\"label\"),\r\n\t\t\t\t\t\tvalue: choiceGR.getValue(\"value\"),\r\n\t\t\t\t\t\tcolor: \"\",\r\n\t\t\t\t\t\tclassName: \"\",\r\n\t\t\t\t\t\ticon: false,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tgs.error(\"ConditionBuilderMS: Error getting choice values for \" + table + \".\" + fieldName + \": \" + e);\r\n\t\t}\r\n\r\n\t\treturn choices;\r\n\t},\r\n\r\n\t/**\r\n\t * Get initial reference values for a reference field\r\n\t * @param {string} refTable - The reference table name\r\n\t * @param {string} table - The source table name\r\n\t * @param {string} fieldName - The field element name\r\n\t * @returns {Array} Array of reference objects\r\n\t */\r\n\t_getInitialReferences: function (refTable, table, fieldName) {\r\n\t\tvar references = [];\r\n\r\n\t\ttry {\r\n\t\t\t// Get reference qualifier if any\r\n\t\t\tvar referenceQualifier = \"\";\r\n\t\t\tvar refQualOverrideGR = new GlideRecord(\"sys_dictionary_override\");\r\n\t\t\trefQualOverrideGR.addQuery(\"name\", table);\r\n\t\t\trefQualOverrideGR.addQuery(\"element\", fieldName);\r\n\t\t\trefQualOverrideGR.query();\r\n\t\t\tif (refQualOverrideGR.next()) {\r\n\t\t\t\tif (refQualOverrideGR.getValue(\"reference_qual_override\") === \"1\") {\r\n\t\t\t\t\tvar refQual = refQualOverrideGR.getValue(\"reference_qual\");\r\n\t\t\t\t\tif (refQual && !refQual.includes(\"javascript:\")) {\r\n\t\t\t\t\t\treferenceQualifier = refQual;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Query reference table for initial values\r\n\t\t\tvar refGR = new GlideRecordSecure(refTable);\r\n\t\t\tif (referenceQualifier) {\r\n\t\t\t\trefGR.addEncodedQuery(referenceQualifier);\r\n\t\t\t}\r\n\t\t\trefGR.orderBy(refGR.getDisplayName());\r\n\t\t\trefGR.setLimit(12); // Limit to 12 like GetTableDropdownsData\r\n\t\t\trefGR.query();\r\n\r\n\t\t\twhile (refGR.next()) {\r\n\t\t\t\tvar refObj = {\r\n\t\t\t\t\tlabel: refGR.getDisplayValue() || \"Empty\",\r\n\t\t\t\t\tvalue: refGR.getValue(\"sys_id\"),\r\n\t\t\t\t\trefTable: refTable,\r\n\t\t\t\t\ticon: false,\r\n\t\t\t\t\tcolor: \"\",\r\n\t\t\t\t\tclassName: \"\",\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Special handling for sys_user (add avatar)\r\n\t\t\t\tif (refTable === \"sys_user\") {\r\n\t\t\t\t\tvar avatar = refGR.getValue(\"avatar\");\r\n\t\t\t\t\tvar photo = refGR.getValue(\"photo\");\r\n\t\t\t\t\trefObj.avatar = avatar || photo ? (avatar || photo) + \".iix\" : \"\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Special handling for tables with color fields\r\n\t\t\t\tif (\"x_cadso_work_status,x_cadso_work_project,x_cadso_work_campaign\".indexOf(refTable) > -1) {\r\n\t\t\t\t\tvar colorField = refTable === \"x_cadso_work_status\" ? \"color\" : \"glyph_color\";\r\n\t\t\t\t\trefObj.color = refGR.getValue(colorField) || \"\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\treferences.push(refObj);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tgs.error(\"ConditionBuilderMS: Error getting reference values for \" + refTable + \": \" + e);\r\n\t\t}\r\n\r\n\t\treturn references;\r\n\t},\r\n\r\n\t/**\r\n\t * Format value based on field type\r\n\t * @param {string} value - The value to format\r\n\t * @param {string} fieldType - The field type\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {string|Object} Formatted value\r\n\t */\r\n\t_formatValueByType: function (value, fieldType, operator) {\r\n\t\tif (!value) return value;\r\n\r\n\t\tvar Utils = this.Utils;\r\n\r\n\t\t// Handle special date values\r\n\t\tif (fieldType === \"glide_date_time\" || fieldType === \"glide_date\") {\r\n\t\t\tvar formatted = Utils.handleSpecialDateValue(value, operator);\r\n\t\t\tif (formatted !== value) {\r\n\t\t\t\treturn formatted;\r\n\t\t\t}\r\n\r\n\t\t\t// Format date time values\r\n\t\t\tif (operator === \"ON\" && value.indexOf(\"@\") > -1) {\r\n\t\t\t\treturn value; // Keep full value with javascript expressions\r\n\t\t\t}\r\n\r\n\t\t\treturn Utils.formatDateTimeValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle boolean values\r\n\t\tif (fieldType === \"boolean\") {\r\n\t\t\treturn value.toLowerCase() === \"true\" || value === \"1\" ? \"true\" : \"false\";\r\n\t\t}\r\n\r\n\t\t// Handle choice values\r\n\t\tif (fieldType === \"choice\") {\r\n\t\t\treturn Utils.formatChoiceValue(value, this.currentTable, fieldType);\r\n\t\t}\r\n\r\n\t\t// Handle currency values\r\n\t\tif (fieldType === \"currency\") {\r\n\t\t\treturn Utils.formatCurrencyValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle duration values\r\n\t\tif (fieldType === \"glide_duration\") {\r\n\t\t\treturn Utils.formatDurationValue(value);\r\n\t\t}\r\n\r\n\t\t// Handle reference values - keep sys_id\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Handle numeric fields\r\n\t\tif (fieldType === \"integer\" || fieldType === \"float\" || fieldType === \"decimal\") {\r\n\t\t\t// Keep numeric values as strings for proper handling\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Default - return as is\r\n\t\treturn value;\r\n\t},\r\n\r\n\ttype: \"ConditionBuilderMS\",\r\n};\r\n",
    "formatted_script": {
      "line_count": 1288,
      "char_count": 38480,
      "preview": "/**\r\n * ConditionBuilderMS - Converts ServiceNow encoded queries to FilterGroup array\r\n *\r\n * Returns FilterGroup[] structure:\r\n * {\r\n *   filterGroupDisplayValue: string,  // Display name for the fil...",
      "full_script": "/**\r\n * ConditionBuilderMS - Converts ServiceNow encoded queries to FilterGroup array\r\n *\r\n * Returns FilterGroup[] structure:\r\n * {\r\n *   filterGroupDisplayValue: string,  // Display name for the filter group\r\n *   filterGroupIndex: number,          // Index position of the group\r\n *   filters: FilterCondition[],        // Array of filter conditions\r\n *   collapsed: boolean                 // UI state for group collapse\r\n * }\r\n *\r\n * The ^NQ separator creates separate FilterGroups.\r\n * Queries without ^NQ return a single FilterGroup containing all conditions.\r\n *\r\n * @example\r\n * // Single group (no NQ)\r\n * convert(\"priority=1^state=2\") returns:\r\n * [{\r\n *   filterGroupDisplayValue: \"Filter Group 1\",\r\n *   filterGroupIndex: 0,\r\n *   filters: [condition1, condition2],\r\n *   collapsed: false\r\n * }]\r\n *\r\n * @example\r\n * // Multiple groups (with NQ)\r\n * convert(\"priority=1^NQstate=2\") returns:\r\n * [{\r\n *   filterGroupDisplayValue: \"Filter Group 1\",\r\n *   filterGroupIndex: 0,\r\n *   filters: [condition1],\r\n *   collapsed: false\r\n * }, {\r\n *   filterGroupDisplayValue: \"Filter Group 2\",\r\n *   filterGroupIndex: 1,\r\n *   filters: [condition2],\r\n *   collapsed: false\r\n * }]\r\n */\r\nvar ConditionBuilderMS = Class.create();\r\nConditionBuilderMS.prototype = {\r\n\tinitialize: function () {\r\n\t\tthis.Utils = new x_cadso_core.ConditionBuilderUtilsMS();\r\n\t\tthis.GetTableDropdownsData = new x_cadso_work.GetTableDropdownsData();\r\n\t\tthis.fieldMetadataCache = {};\r\n\t\tthis.language = gs.getSession().getLanguage();\r\n\t\t// ServiceNow operators mapping\r\n\t\tvar CF_Tables = new x_cadso_work.TenonComplexFilterTables();\r\n\t\tthis.tableMap = {\r\n\t\t\troutes: CF_Tables.routes,\r\n\t\t\toperations: CF_Tables.operations,\r\n\t\t\toperationTable: CF_Tables.operationTable,\r\n\t\t\toperators: CF_Tables.operators,\r\n\t\t\tbooleanTable: CF_Tables.booleanTable,\r\n\t\t\tglideDateTimeTable: CF_Tables.glideDateTimeTable,\r\n\t\t\tcurrencyTable: CF_Tables.currencyTable,\r\n\t\t};\r\n\t\tthis.operators = {\r\n\t\t\t// Equality operators\r\n\t\t\t\"=\": { type: \"equals\", label: \"is\", needsValue: true },\r\n\t\t\t\"!=\": { type: \"not_equals\", label: \"is not\", needsValue: true },\r\n\r\n\t\t\t// Comparison operators\r\n\t\t\t\">\": { type: \"greater_than\", label: \">\", needsValue: true },\r\n\t\t\t\">=\": { type: \"greater_than_or_equal\", label: \">=\", needsValue: true },\r\n\t\t\t\"<\": { type: \"less_than\", label: \"<\", needsValue: true },\r\n\t\t\t\"<=\": { type: \"less_than_or_equal\", label: \"<=\", needsValue: true },\r\n\r\n\t\t\t// String operators\r\n\t\t\tCONTAINS: { type: \"contains\", label: \"contains\", needsValue: true },\r\n\t\t\t\"DOES NOT CONTAIN\": { type: \"does_not_contain\", label: \"does not contain\", needsValue: true },\r\n\t\t\tSTARTSWITH: { type: \"starts_with\", label: \"starts with\", needsValue: true },\r\n\t\t\tENDSWITH: { type: \"ends_with\", label: \"ends with\", needsValue: true },\r\n\t\t\tLIKE: { type: \"like\", label: \"contains\", needsValue: true },\r\n\t\t\t\"NOT LIKE\": { type: \"not_like\", label: \"does not contain\", needsValue: true },\r\n\r\n\t\t\t// List operators\r\n\t\t\tIN: { type: \"in\", label: \"is one of\", needsValue: true, multiValue: true },\r\n\t\t\t\"NOT IN\": { type: \"not_in\", label: \"is not one of\", needsValue: true, multiValue: true },\r\n\r\n\t\t\t// Empty/null operators\r\n\t\t\tISEMPTY: { type: \"is_empty\", label: \"is empty\", needsValue: false },\r\n\t\t\tISNOTEMPTY: { type: \"is_not_empty\", label: \"is not empty\", needsValue: false },\r\n\t\t\tANYTHING: { type: \"anything\", label: \"is anything\", needsValue: false },\r\n\t\t\tEMPTYSTRING: { type: \"empty_string\", label: \"is empty string\", needsValue: false },\r\n\r\n\t\t\t// Date operators\r\n\t\t\tON: { type: \"on\", label: \"on\", needsValue: true, dateOperator: true },\r\n\t\t\tBETWEEN: {\r\n\t\t\t\ttype: \"between\",\r\n\t\t\t\tlabel: \"between\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tmultiValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVE: { type: \"relative\", label: \"relative\", needsValue: true, dateOperator: true },\r\n\t\t\tRELATIVEGT: {\r\n\t\t\t\ttype: \"relative_gt\",\r\n\t\t\t\tlabel: \"relative >\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVELT: {\r\n\t\t\t\ttype: \"relative_lt\",\r\n\t\t\t\tlabel: \"relative <\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVEGE: {\r\n\t\t\t\ttype: \"relative_ge\",\r\n\t\t\t\tlabel: \"relative >=\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tRELATIVELE: {\r\n\t\t\t\ttype: \"relative_le\",\r\n\t\t\t\tlabel: \"relative <=\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tDATEPART: {\r\n\t\t\t\ttype: \"date_part\",\r\n\t\t\t\tlabel: \"date part\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tmultiValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\t\t\tSAMEAS: { type: \"same_as\", label: \"same as\", needsValue: true, dateOperator: true },\r\n\t\t\tNSAMEAS: { type: \"not_same_as\", label: \"not same as\", needsValue: true, dateOperator: true },\r\n\t\t\tMORETHAN: { type: \"more_than\", label: \"more than\", needsValue: true, dateOperator: true },\r\n\t\t\tLESSTHAN: {\r\n\t\t\t\ttype: \"less_than_duration\",\r\n\t\t\t\tlabel: \"less than\",\r\n\t\t\t\tneedsValue: true,\r\n\t\t\t\tdateOperator: true,\r\n\t\t\t},\r\n\r\n\t\t\t// JavaScript operators\r\n\t\t\tDYNAMIC: { type: \"dynamic\", label: \"dynamic\", needsValue: true },\r\n\t\t\tSCRIPT: { type: \"script\", label: \"script\", needsValue: true },\r\n\r\n\t\t\t// Currency operators\r\n\t\t\tVALCHANGES: { type: \"value_changes\", label: \"changes\", needsValue: false },\r\n\t\t\tVALCHANGESTO: { type: \"value_changes_to\", label: \"changes to\", needsValue: true },\r\n\t\t\tVALCHANGESFROM: { type: \"value_changes_from\", label: \"changes from\", needsValue: true },\r\n\r\n\t\t\t// Reference operators\r\n\t\t\tINSTANCEOF: { type: \"instance_of\", label: \"is a\", needsValue: true },\r\n\t\t\t\"NOT INSTANCEOF\": { type: \"not_instance_of\", label: \"is not a\", needsValue: true },\r\n\r\n\t\t\t// Duration operators\r\n\t\t\tDURATION: { type: \"duration\", label: \"duration\", needsValue: true },\r\n\t\t};\r\n\t},\r\n\r\n\tconvert: function (condition, table) {\r\n\t\tif (!condition || typeof condition !== \"string\") {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\t// Store table for metadata lookups\r\n\t\tthis.currentTable = table || null;\r\n\r\n\t\t// Clear metadata cache for new conversion\r\n\t\tthis.fieldMetadataCache = {};\r\n\r\n\t\ttry {\r\n\t\t\t// Split by ^NQ to get separate condition groups\r\n\t\t\tvar queryGroups = this._splitByNQ(condition);\r\n\t\t\tvar filterGroups = [];\r\n\t\t\tvar conditionId = 0;\r\n\r\n\t\t\tfor (var groupIndex = 0; groupIndex < queryGroups.length; groupIndex++) {\r\n\t\t\t\tvar isFirstGroup = groupIndex === 0;\r\n\t\t\t\tvar groupConditions = this._parseConditionGroup(queryGroups[groupIndex], conditionId, isFirstGroup);\r\n\r\n\t\t\t\t// Create a FilterGroup for this set of conditions\r\n\t\t\t\tif (groupConditions.length > 0) {\r\n\t\t\t\t\tvar filterGroup = {\r\n\t\t\t\t\t\tfilterGroupDisplayValue: \"Filter Group \" + (groupIndex + 1),\r\n\t\t\t\t\t\tfilterGroupIndex: groupIndex,\r\n\t\t\t\t\t\tfilters: groupConditions,\r\n\t\t\t\t\t\tcollapsed: false,\r\n\t\t\t\t\t};\r\n\t\t\t\t\tfilterGroups.push(filterGroup);\r\n\t\t\t\t\tconditionId += groupConditions.length;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Reverse the filter groups array to match expected order\r\n\t\t\tfilterGroups.reverse();\r\n\r\n\t\t\t// Update the display values and indices after reversing\r\n\t\t\tfor (var i = 0; i < filterGroups.length; i++) {\r\n\t\t\t\tfilterGroups[i].filterGroupDisplayValue = \"Filter Group \" + (i + 1);\r\n\t\t\t\tfilterGroups[i].filterGroupIndex = i;\r\n\t\t\t}\r\n\r\n\t\t\treturn filterGroups;\r\n\t\t} catch (error) {\r\n\t\t\tgs.error(\"Error converting encoded query: \" + error);\r\n\t\t\treturn [];\r\n\t\t}\r\n\t},\r\n\r\n\t_splitByNQ: function (query) {\r\n\t\tvar parts = query.split(\"^NQ\");\r\n\t\tvar result = [];\r\n\t\tfor (var i = 0; i < parts.length; i++) {\r\n\t\t\tif (parts[i].trim().length > 0) {\r\n\t\t\t\tresult.push(parts[i].trim());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.length > 0 ? result : [query];\r\n\t},\r\n\r\n\t_parseConditionGroup: function (groupQuery, startId, isFirstGroup) {\r\n\t\tvar conditions = [];\r\n\t\tvar currentId = startId || 0;\r\n\r\n\t\t// Check if query contains OR\r\n\t\tvar hasOR = groupQuery.indexOf(\"^OR\") > -1;\r\n\r\n\t\tif (!hasOR) {\r\n\t\t\t// No OR conditions, just parse as regular AND conditions\r\n\t\t\tvar andConditions = this._parseAndConditions(groupQuery, currentId, isFirstGroup);\r\n\t\t\tconditions = conditions.concat(andConditions);\r\n\t\t} else {\r\n\t\t\t// Split by ^OR to handle OR conditions\r\n\t\t\tvar orGroups = this._splitByOR(groupQuery);\r\n\r\n\t\t\tfor (var i = 0; i < orGroups.length; i++) {\r\n\t\t\t\tif (orGroups[i].trim()) {\r\n\t\t\t\t\tvar groupConditions = this._parseAndConditions(orGroups[i], currentId, isFirstGroup && i === 0);\r\n\r\n\t\t\t\t\t// Set operator for conditions\r\n\t\t\t\t\tfor (var j = 0; j < groupConditions.length; j++) {\r\n\t\t\t\t\t\tif (j === 0 && i === 0 && isFirstGroup) {\r\n\t\t\t\t\t\t\tgroupConditions[j].operator = \"\"; // First condition of first group has no operator\r\n\t\t\t\t\t\t} else if (i > 0 && j === 0) {\r\n\t\t\t\t\t\t\tgroupConditions[j].operator = { value: \"OR\", label: \"OR\" }; // First condition of OR group\r\n\t\t\t\t\t\t} else if (j > 0) {\r\n\t\t\t\t\t\t\tgroupConditions[j].operator = { value: \"AND\", label: \"AND\" }; // Subsequent conditions in same group\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcurrentId++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconditions = conditions.concat(groupConditions);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn conditions;\r\n\t},\r\n\r\n\t_splitByOR: function (query) {\r\n\t\tvar parts = [];\r\n\t\tvar currentPart = \"\";\r\n\t\tvar i = 0;\r\n\r\n\t\twhile (i < query.length) {\r\n\t\t\tif (query.substring(i, i + 3) === \"^OR\") {\r\n\t\t\t\tif (currentPart.trim()) {\r\n\t\t\t\t\tparts.push(currentPart.trim());\r\n\t\t\t\t}\r\n\t\t\t\tcurrentPart = \"\";\r\n\t\t\t\ti += 3;\r\n\t\t\t} else {\r\n\t\t\t\tcurrentPart += query.charAt(i);\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (currentPart.trim()) {\r\n\t\t\tparts.push(currentPart.trim());\r\n\t\t}\r\n\r\n\t\treturn parts.length > 0 ? parts : [query];\r\n\t},\r\n\r\n\t_parseAndConditions: function (groupQuery, startId, isFirstInGroup) {\r\n\t\tvar conditionStrings = this._splitByAND(groupQuery);\r\n\t\tvar conditions = [];\r\n\r\n\t\tfor (var i = 0; i < conditionStrings.length; i++) {\r\n\t\t\tvar condition = this._parseIndividualCondition(conditionStrings[i].trim(), startId + i);\r\n\t\t\tif (condition) {\r\n\t\t\t\t// Set operator based on position\r\n\t\t\t\tif (i === 0 && isFirstInGroup) {\r\n\t\t\t\t\tcondition.operator = \"\"; // First condition of first group has no operator\r\n\t\t\t\t} else if (i > 0) {\r\n\t\t\t\t\tcondition.operator = { value: \"AND\", label: \"AND\" }; // Subsequent conditions use AND\r\n\t\t\t\t}\r\n\t\t\t\t// Note: operator will be overridden by _parseConditionGroup for OR conditions\r\n\t\t\t\tconditions.push(condition);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn conditions;\r\n\t},\r\n\r\n\t_splitByAND: function (query) {\r\n\t\tvar parts = [];\r\n\t\tvar currentPart = \"\";\r\n\t\tvar i = 0;\r\n\r\n\t\twhile (i < query.length) {\r\n\t\t\tif (query.charAt(i) === \"^\") {\r\n\t\t\t\t// Check if this is a standalone AND operator\r\n\t\t\t\tif (this._isStandaloneAND(query, i)) {\r\n\t\t\t\t\tif (currentPart.trim()) {\r\n\t\t\t\t\t\tparts.push(currentPart.trim());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurrentPart = \"\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentPart += query.charAt(i);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcurrentPart += query.charAt(i);\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\tif (currentPart.trim()) {\r\n\t\t\tparts.push(currentPart.trim());\r\n\t\t}\r\n\r\n\t\treturn parts.length > 0 ? parts : [query];\r\n\t},\r\n\r\n\t_isStandaloneAND: function (query, position) {\r\n\t\t// Look ahead to see if this is ^OR or ^NQ\r\n\t\tif (position + 2 < query.length) {\r\n\t\t\tvar next2 = query.substring(position, position + 3);\r\n\t\t\tif (next2 === \"^OR\" || next2 === \"^NQ\") {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Look behind to see if this is part of an operator\r\n\t\tif (position > 0) {\r\n\t\t\tvar prev = query.charAt(position - 1);\r\n\t\t\tif (prev === \"=\" || prev === \"!\" || prev === \">\" || prev === \"<\") {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_parseIndividualCondition: function (conditionStr, id) {\r\n\t\t// Find the operator in the condition string\r\n\t\tvar operatorMatch = this._findOperatorInCondition(conditionStr);\r\n\r\n\t\tif (!operatorMatch) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar operator = operatorMatch.operator;\r\n\t\tvar operatorKey = operatorMatch.operatorKey;\r\n\t\tvar startPos = operatorMatch.startPos;\r\n\t\tvar endPos = operatorMatch.endPos;\r\n\r\n\t\t// Extract field and value\r\n\t\tvar field = conditionStr.substring(0, startPos).trim();\r\n\t\tvar value = conditionStr.substring(endPos).trim();\r\n\r\n\t\t// Validate field\r\n\t\tif (!field) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Parse the value based on operator type\r\n\t\tvar parsedValues = this._parseValue(value, operator);\r\n\r\n\t\t// Create FilterCondition object\r\n\t\treturn this._createFilterCondition(id, field, operatorKey, operator, parsedValues);\r\n\t},\r\n\r\n\t_findOperatorInCondition: function (conditionStr) {\r\n\t\t// Sort operators by length (longest first) to match multi-character operators first\r\n\t\tvar sortedOperators = [];\r\n\t\tfor (var key in this.operators) {\r\n\t\t\tsortedOperators.push(key);\r\n\t\t}\r\n\t\tsortedOperators.sort(function (a, b) {\r\n\t\t\treturn b.length - a.length;\r\n\t\t});\r\n\r\n\t\tfor (var i = 0; i < sortedOperators.length; i++) {\r\n\t\t\tvar operatorKey = sortedOperators[i];\r\n\t\t\tvar index = conditionStr.indexOf(operatorKey);\r\n\t\t\tif (index > 0) {\r\n\t\t\t\t// Must have field before operator\r\n\t\t\t\treturn {\r\n\t\t\t\t\toperator: this.operators[operatorKey],\r\n\t\t\t\t\toperatorKey: operatorKey,\r\n\t\t\t\t\tstartPos: index,\r\n\t\t\t\t\tendPos: index + operatorKey.length,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\t_parseValue: function (value, operator) {\r\n\t\tif (!operator.needsValue) {\r\n\t\t\treturn {\r\n\t\t\t\tvalues: [\"\", \"\"],\r\n\t\t\t\tlabels: [\"\", \"\"],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle multi-value operators\r\n\t\tif (operator.multiValue) {\r\n\t\t\treturn this._parseMultiValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle date operators\r\n\t\tif (operator.dateOperator) {\r\n\t\t\treturn this._parseDateValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Default single value\r\n\t\tvar cleanedValue = this._cleanValue(value);\r\n\t\treturn {\r\n\t\t\tvalues: [cleanedValue, \"\"],\r\n\t\t\tlabels: [cleanedValue, \"\"],\r\n\t\t};\r\n\t},\r\n\r\n\t_parseMultiValue: function (value, operator) {\r\n\t\tvar values = [];\r\n\t\tvar labels = [];\r\n\r\n\t\tif (operator.type === \"between\" || operator.type === \"date_part\") {\r\n\t\t\t// BETWEEN and DATEPART use @ as separator\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\tvalues.push(parts[0] ? this._cleanValue(parts[0]) : \"\");\r\n\t\t\tvalues.push(parts[1] ? this._cleanValue(parts[1]) : \"\");\r\n\t\t\tlabels.push(parts[0] ? this._cleanValue(parts[0]) : \"\");\r\n\t\t\tlabels.push(parts[1] ? this._cleanValue(parts[1]) : \"\");\r\n\t\t} else {\r\n\t\t\t// IN/NOT IN use comma separation - combine into first value\r\n\t\t\tvar combinedValue = value;\r\n\t\t\tvalues.push(combinedValue);\r\n\t\t\tvalues.push(\"\");\r\n\t\t\tlabels.push(combinedValue);\r\n\t\t\tlabels.push(\"\");\r\n\t\t}\r\n\r\n\t\t// Ensure we always have exactly 2 values\r\n\t\twhile (values.length < 2) {\r\n\t\t\tvalues.push(\"\");\r\n\t\t\tlabels.push(\"\");\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tvalues: values.slice(0, 2),\r\n\t\t\tlabels: labels.slice(0, 2),\r\n\t\t};\r\n\t},\r\n\r\n\t_parseDateValue: function (value, operator) {\r\n\t\t// Handle BETWEEN with @ separator\r\n\t\tif (operator.type === \"between\" && value.indexOf(\"@\") > -1) {\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\treturn {\r\n\t\t\t\tvalues: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t\tlabels: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Handle ON with @ separator (date range with javascript expressions)\r\n\t\tif (operator.type === \"on\" && value.indexOf(\"@\") > -1) {\r\n\t\t\tvar parts = value.split(\"@\");\r\n\t\t\t// For ON operator with date range, store the full value\r\n\t\t\t// The label is just the date part\r\n\t\t\tif (parts.length >= 3) {\r\n\t\t\t\t// Format: 2025-08-21@javascript:gs.dateGenerate('2025-08-21','start')@javascript:gs.dateGenerate('2025-08-21','end')\r\n\t\t\t\t// Or: Today@javascript:gs.beginningOfToday()@javascript:gs.endOfToday()\r\n\t\t\t\tvar dateValue = parts[0];\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalues: [value, \"\"], // Full value with javascript expressions\r\n\t\t\t\t\tlabels: [dateValue || \"\", \"\"], // Just the date part for label\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalues: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t\t\tlabels: [parts[0] || \"\", parts[1] || \"\"],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check for special value \"Today\"\r\n\t\tif (value === \"Today\") {\r\n\t\t\treturn {\r\n\t\t\t\tvalues: [\"Today\", \"\"],\r\n\t\t\t\tlabels: [\"Today\", \"\"],\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Default date value\r\n\t\treturn {\r\n\t\t\tvalues: [value, \"\"],\r\n\t\t\tlabels: [value, \"\"],\r\n\t\t};\r\n\t},\r\n\r\n\t_cleanValue: function (value) {\r\n\t\tif (!value) return \"\";\r\n\r\n\t\t// Remove leading/trailing whitespace\r\n\t\tvalue = value.trim();\r\n\r\n\t\t// Return as-is to preserve the original value\r\n\t\treturn value;\r\n\t},\r\n\r\n\t_createFilterCondition: function (id, fieldName, operatorKey, operator, parsedValues) {\r\n\t\t// Get actual field metadata from ServiceNow if table is provided\r\n\t\tvar actualFieldMetadata = this.currentTable ? this._getActualFieldMetadata(this.currentTable, fieldName) : null;\r\n\r\n\t\t// Use actual metadata if available, otherwise fall back to inference\r\n\t\tvar fieldType =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.type\r\n\t\t\t\t? actualFieldMetadata.type\r\n\t\t\t\t: this._inferFieldType(fieldName, operator, parsedValues.values[0]);\r\n\r\n\t\tvar fieldDisplayName =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.displayValue\r\n\t\t\t\t? actualFieldMetadata.displayValue\r\n\t\t\t\t: this._humanizeFieldName(fieldName);\r\n\r\n\t\tvar isChoice =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.isChoice !== undefined\r\n\t\t\t\t? actualFieldMetadata.isChoice\r\n\t\t\t\t: this._isChoiceField(fieldName, fieldType);\r\n\r\n\t\tvar choices = actualFieldMetadata && actualFieldMetadata.choices ? actualFieldMetadata.choices : [];\r\n\r\n\t\tvar references = actualFieldMetadata && actualFieldMetadata.references ? actualFieldMetadata.references : [];\r\n\r\n\t\tvar refTable =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.refTable\r\n\t\t\t\t? actualFieldMetadata.refTable\r\n\t\t\t\t: this._getRefTable(fieldName, fieldType);\r\n\r\n\t\tvar canWrite =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.canWrite !== undefined ? actualFieldMetadata.canWrite : true;\r\n\r\n\t\tvar canClear =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.canClear !== undefined ? actualFieldMetadata.canClear : true;\r\n\r\n\t\tvar maxLength =\r\n\t\t\tactualFieldMetadata && actualFieldMetadata.maxLength\r\n\t\t\t\t? actualFieldMetadata.maxLength\r\n\t\t\t\t: this._getDefaultMaxLength(fieldType);\r\n\r\n\t\t// Build option arrays with proper formatting\r\n\t\tvar options = this._buildOptionArrays({\r\n\t\t\tparsedValues: parsedValues,\r\n\t\t\tfieldType: fieldType,\r\n\t\t\tfieldName: fieldName,\r\n\t\t\toperator: operator,\r\n\t\t\toperatorKey: operatorKey,\r\n\t\t\trefTable: refTable,\r\n\t\t\tchoices: choices,\r\n\t\t\treferences: references,\r\n\t\t});\r\n\r\n\t\treturn {\r\n\t\t\tid: id,\r\n\t\t\tfield: {\r\n\t\t\t\tdisplayValue: fieldDisplayName,\r\n\t\t\t\tname: fieldDisplayName,\r\n\t\t\t\tvalue: fieldName,\r\n\t\t\t\ttype: fieldType,\r\n\t\t\t\tisChoice: isChoice,\r\n\t\t\t\tchoices: choices,\r\n\t\t\t\treferences: references,\r\n\t\t\t\trefTable: refTable,\r\n\t\t\t\treference: refTable, // Add reference property\r\n\t\t\t\tcanWrite: canWrite,\r\n\t\t\t\tcanClear: canClear,\r\n\t\t\t\tcanSearch:\r\n\t\t\t\t\tactualFieldMetadata && actualFieldMetadata.canSearch !== undefined ? actualFieldMetadata.canSearch : true,\r\n\t\t\t\tmaxLength: maxLength,\r\n\t\t\t\tisRelatedFilter:\r\n\t\t\t\t\tactualFieldMetadata && actualFieldMetadata.isRelatedFilter ? actualFieldMetadata.isRelatedFilter : false,\r\n\t\t\t\trelatedFilter:\r\n\t\t\t\t\tactualFieldMetadata && actualFieldMetadata.relatedFilter ? actualFieldMetadata.relatedFilter : {},\r\n\t\t\t},\r\n\t\t\toperator: \"\", // Will be set by the calling function based on position\r\n\t\t\toperation: {\r\n\t\t\t\tlabel: operator.label || operatorKey.toLowerCase(),\r\n\t\t\t\tvalue: operatorKey,\r\n\t\t\t},\r\n\t\t\toption: options,\r\n\t\t\tcanDotWalk: fieldType === \"reference\",\r\n\t\t\tsearchInput: {\r\n\t\t\t\tfieldSeachInputValue: \"\",\r\n\t\t\t\toptionSearchInputValue: \"\",\r\n\t\t\t\ttimeSearchInputValue: \"\",\r\n\t\t\t},\r\n\t\t\tcurrency: fieldType === \"currency\" ? \"USD\" : \"\",\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Build option arrays with proper value formatting\r\n\t * @param {Object} params - Parameters for building options\r\n\t * @returns {Array} Array of two option objects\r\n\t */\r\n\t_buildOptionArrays: function (params) {\r\n\t\tvar parsedValues = params.parsedValues;\r\n\t\tvar fieldType = params.fieldType;\r\n\t\tvar fieldName = params.fieldName;\r\n\t\tvar operator = params.operator;\r\n\t\tvar operatorKey = params.operatorKey;\r\n\t\tvar refTable = params.refTable;\r\n\t\tvar choices = params.choices || [];\r\n\t\tvar references = params.references || [];\r\n\r\n\t\tvar Utils = this.Utils;\r\n\r\n\t\t// Get default option properties\r\n\t\tvar defaultOption1 = Utils.getDefaultOptionProperties(true);\r\n\t\tvar defaultOption2 = Utils.getDefaultOptionProperties(false);\r\n\r\n\t\t// Format values based on field type\r\n\t\tvar value1 = parsedValues.values[0] || \"\";\r\n\t\tvar value2 = parsedValues.values[1] || \"\";\r\n\t\tvar label1 = parsedValues.labels[0] || \"\";\r\n\t\tvar label2 = parsedValues.labels[1] || \"\";\r\n\r\n\t\t// Apply type-specific formatting to values\r\n\t\tif (value1) {\r\n\t\t\tvalue1 = this._formatValueByType(value1, fieldType, operatorKey);\r\n\t\t}\r\n\t\tif (value2) {\r\n\t\t\tvalue2 = this._formatValueByType(value2, fieldType, operatorKey);\r\n\t\t}\r\n\r\n\t\t// Format labels\r\n\t\tif (fieldType === \"boolean\") {\r\n\t\t\tlabel1 = value1 ? Utils.formatBooleanLabel(value1) : \"\";\r\n\t\t\tlabel2 = value2 ? Utils.formatBooleanLabel(value2) : \"\";\r\n\t\t} else if (fieldType === \"glide_date_time\" || fieldType === \"glide_date\") {\r\n\t\t\t// Format date labels\r\n\t\t\tif (label1 && label1 !== \"Today\" && label1 !== \"Yesterday\" && label1 !== \"Tomorrow\") {\r\n\t\t\t\tlabel1 = Utils.formatDateLabel(label1);\r\n\t\t\t}\r\n\t\t\tif (label2 && label2 !== \"Today\" && label2 !== \"Yesterday\" && label2 !== \"Tomorrow\") {\r\n\t\t\t\tlabel2 = Utils.formatDateLabel(label2);\r\n\t\t\t}\r\n\t\t} else if (fieldType === \"reference\") {\r\n\t\t\t// Get reference display values\r\n\t\t\tif (value1) {\r\n\t\t\t\tlabel1 = Utils.getReferenceLabel(value1, refTable, fieldName);\r\n\t\t\t}\r\n\t\t\tif (value2) {\r\n\t\t\t\tlabel2 = Utils.getReferenceLabel(value2, refTable, fieldName);\r\n\t\t\t}\r\n\t\t} else if (fieldType === \"choice\" && choices.length > 0) {\r\n\t\t\t// Get choice labels\r\n\t\t\tfor (var i = 0; i < choices.length; i++) {\r\n\t\t\t\tif (choices[i].value === value1) {\r\n\t\t\t\t\tlabel1 = choices[i].label;\r\n\t\t\t\t}\r\n\t\t\t\tif (choices[i].value === value2) {\r\n\t\t\t\t\tlabel2 = choices[i].label;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Build option1\r\n\t\tvar option1 = {\r\n\t\t\tid: 0,\r\n\t\t\tvalue: value1,\r\n\t\t\tlabel: label1,\r\n\t\t};\r\n\r\n\t\t// Build option2\r\n\t\tvar option2 = {\r\n\t\t\tid: 1,\r\n\t\t\tvalue: value2,\r\n\t\t\tlabel: label2,\r\n\t\t};\r\n\r\n\t\t// Merge with default properties\r\n\t\tfor (var key in defaultOption1) {\r\n\t\t\tif (!(key in option1)) {\r\n\t\t\t\toption1[key] = defaultOption1[key];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var key in defaultOption2) {\r\n\t\t\tif (!(key in option2)) {\r\n\t\t\t\toption2[key] = defaultOption2[key];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Handle special cases for dates\r\n\t\tif ((fieldType === \"glide_date_time\" || fieldType === \"glide_date\") && operator.type === \"on\") {\r\n\t\t\t// Parse selected date if not a special value\r\n\t\t\tif (label1 && label1 !== \"Today\" && label1 !== \"Yesterday\" && label1 !== \"Tomorrow\") {\r\n\t\t\t\toption1.selectedDate = Utils.parseSelectedDate(label1);\r\n\t\t\t}\r\n\r\n\t\t\t// Handle special date values\r\n\t\t\tif (typeof value1 === \"object\") {\r\n\t\t\t\t// Value is already formatted as special date object\r\n\t\t\t\toption1.value = value1;\r\n\t\t\t} else if (value1 && value1.indexOf(\"@\") > -1) {\r\n\t\t\t\t// Keep full value with javascript expressions\r\n\t\t\t\toption1.value = value1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Handle duration fields\r\n\t\tif (fieldType === \"glide_duration\" && value1) {\r\n\t\t\tvar duration1 = Utils.parseDuration(value1);\r\n\t\t\tif (duration1) {\r\n\t\t\t\toption1.duration = duration1;\r\n\t\t\t\toption1.tempDuration = duration1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fieldType === \"glide_duration\" && value2) {\r\n\t\t\tvar duration2 = Utils.parseDuration(value2);\r\n\t\t\tif (duration2) {\r\n\t\t\t\toption2.duration = duration2;\r\n\t\t\t\toption2.tempDuration = duration2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Handle currency fields\r\n\t\tif (fieldType === \"currency\") {\r\n\t\t\toption1.currency = \"USD\";\r\n\t\t\toption2.currency = \"USD\";\r\n\t\t}\r\n\r\n\t\t// Handle numeric fields with glideStringInput\r\n\t\tif ((fieldType === \"integer\" || fieldType === \"float\" || fieldType === \"decimal\") && value1) {\r\n\t\t\toption1.glideStringInput = value1;\r\n\t\t}\r\n\t\tif ((fieldType === \"integer\" || fieldType === \"float\" || fieldType === \"decimal\") && value2) {\r\n\t\t\toption2.glideStringInput = value2;\r\n\t\t}\r\n\r\n\t\t// Handle reference fields - add icon and avatar properties\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\toption1.icon = false;\r\n\t\t\toption1.avatar = \"\";\r\n\t\t\toption1.color = \"\";\r\n\r\n\t\t\toption2.icon = false;\r\n\t\t\toption2.avatar = \"\";\r\n\t\t\toption2.color = \"\";\r\n\r\n\t\t\t// Add reference-specific properties from references array\r\n\t\t\tif (references.length > 0) {\r\n\t\t\t\tfor (var j = 0; j < references.length; j++) {\r\n\t\t\t\t\tif (references[j].value === value1) {\r\n\t\t\t\t\t\toption1.avatar = references[j].avatar || \"\";\r\n\t\t\t\t\t\toption1.color = references[j].color || \"\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var k = 0; k < references.length; k++) {\r\n\t\t\t\t\tif (references[k].value === value2) {\r\n\t\t\t\t\t\toption2.avatar = references[k].avatar || \"\";\r\n\t\t\t\t\t\toption2.color = references[k].color || \"\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn [option1, option2];\r\n\t},\r\n\r\n\t_formatValues: function ({ parsedValues, fieldType, operator, Utils, fieldName, refTable }) {\r\n\t\tvar values = parsedValues.values.slice();\r\n\t\tvar labels = parsedValues.labels.slice();\r\n\r\n\t\t// Format boolean values\r\n\t\tif (fieldType === \"boolean\") {\r\n\t\t\tfor (var i = 0; i < values.length; i++) {\r\n\t\t\t\tif (values[i]) {\r\n\t\t\t\t\tlabels[i] = Utils.formatBooleanLabel(values[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Format date labels\r\n\t\tif (fieldType === \"glide_date_time\" && operator.dateOperator) {\r\n\t\t\tfor (var i = 0; i < values.length; i++) {\r\n\t\t\t\tif (labels[i] && labels[i] !== \"Today\") {\r\n\t\t\t\t\tlabels[i] = Utils.formatDateLabel(labels[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Format reference field labels - get display value\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\tfor (var i = 0; i < values.length; i++) {\r\n\t\t\t\tif (values[i]) {\r\n\t\t\t\t\t// Try to get the display value for the reference\r\n\t\t\t\t\tlabels[i] = Utils.getReferenceLabel(values[i], refTable, fieldName);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tvalues: values,\r\n\t\t\tlabels: labels,\r\n\t\t};\r\n\t},\r\n\r\n\t_isChoiceField: function (fieldName, fieldType) {\r\n\t\t// Check if it's a choice field\r\n\t\treturn (\r\n\t\t\tfieldType === \"choice\" ||\r\n\t\t\tfieldName === \"priority\" ||\r\n\t\t\tfieldName === \"state\" ||\r\n\t\t\tfieldName === \"impact\" ||\r\n\t\t\tfieldName === \"urgency\" ||\r\n\t\t\tfieldName === \"approval\"\r\n\t\t);\r\n\t},\r\n\r\n\t_getRefTable: function (fieldName, fieldType) {\r\n\t\t// Return reference table for reference fields\r\n\t\tif (fieldType !== \"reference\") {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Common reference field mappings\r\n\t\tif (fieldName === \"assigned_to\" || fieldName === \"caller_id\" || fieldName.indexOf(\"_by\") > -1) {\r\n\t\t\treturn \"sys_user\";\r\n\t\t}\r\n\t\tif (fieldName === \"assignment_group\") {\r\n\t\t\treturn \"sys_user_group\";\r\n\t\t}\r\n\t\tif (fieldName === \"template\") {\r\n\t\t\treturn \"x_cadso_automate_content_template\";\r\n\t\t}\r\n\t\tif (fieldName === \"company\") {\r\n\t\t\treturn \"core_company\";\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\t_inferFieldType: function (fieldName, operator, value) {\r\n\t\t// Check for date operators\r\n\t\tif (operator.dateOperator) {\r\n\t\t\treturn \"glide_date_time\";\r\n\t\t}\r\n\r\n\t\t// Check for common field patterns\r\n\t\tif (\r\n\t\t\tfieldName.indexOf(\"date\") > -1 ||\r\n\t\t\tfieldName.indexOf(\"time\") > -1 ||\r\n\t\t\tfieldName === \"go_live\" ||\r\n\t\t\tfieldName === \"opened_at\" ||\r\n\t\t\tfieldName === \"closed_at\" ||\r\n\t\t\tfieldName === \"resolved_at\"\r\n\t\t) {\r\n\t\t\treturn \"glide_date_time\";\r\n\t\t}\r\n\r\n\t\t// Choice fields\r\n\t\tif (\r\n\t\t\tfieldName === \"priority\" ||\r\n\t\t\tfieldName === \"state\" ||\r\n\t\t\tfieldName === \"impact\" ||\r\n\t\t\tfieldName === \"urgency\" ||\r\n\t\t\tfieldName === \"approval\" ||\r\n\t\t\tfieldName === \"contact_type\"\r\n\t\t) {\r\n\t\t\treturn \"choice\";\r\n\t\t}\r\n\r\n\t\t// Reference fields\r\n\t\tif (\r\n\t\t\tfieldName.indexOf(\"_by\") > -1 ||\r\n\t\t\tfieldName === \"assigned_to\" ||\r\n\t\t\tfieldName === \"caller_id\" ||\r\n\t\t\tfieldName === \"template\" ||\r\n\t\t\tfieldName === \"assignment_group\" ||\r\n\t\t\tfieldName === \"company\" ||\r\n\t\t\tfieldName === \"opened_by\" ||\r\n\t\t\tfieldName === \"closed_by\" ||\r\n\t\t\tfieldName === \"resolved_by\"\r\n\t\t) {\r\n\t\t\treturn \"reference\";\r\n\t\t}\r\n\r\n\t\t// Boolean fields\r\n\t\tif (\r\n\t\t\tfieldName === \"active\" ||\r\n\t\t\tfieldName === \"ad_hoc\" ||\r\n\t\t\tfieldName === \"made_sla\" ||\r\n\t\t\tfieldName === \"upon_approval\" ||\r\n\t\t\tfieldName === \"upon_reject\" ||\r\n\t\t\tfieldName.indexOf(\"is_\") === 0 ||\r\n\t\t\tfieldName.indexOf(\"has_\") === 0\r\n\t\t) {\r\n\t\t\treturn \"boolean\";\r\n\t\t}\r\n\r\n\t\t// Float fields\r\n\t\tif (\r\n\t\t\tfieldName === \"actual_hours\" ||\r\n\t\t\tfieldName === \"business_duration\" ||\r\n\t\t\tfieldName === \"calendar_duration\" ||\r\n\t\t\tfieldName.indexOf(\"_hours\") > -1\r\n\t\t) {\r\n\t\t\treturn \"float\";\r\n\t\t}\r\n\r\n\t\t// Integer fields\r\n\t\tif (\r\n\t\t\tfieldName === \"number\" ||\r\n\t\t\tfieldName === \"order\" ||\r\n\t\t\tfieldName === \"sys_mod_count\" ||\r\n\t\t\tfieldName.indexOf(\"count\") > -1\r\n\t\t) {\r\n\t\t\treturn \"integer\";\r\n\t\t}\r\n\r\n\t\t// Default to string\r\n\t\treturn \"string\";\r\n\t},\r\n\r\n\t_humanizeFieldName: function (fieldName) {\r\n\t\t// Convert field_name to Field Name\r\n\t\tvar words = fieldName.split(\"_\");\r\n\t\tvar humanized = [];\r\n\r\n\t\tfor (var i = 0; i < words.length; i++) {\r\n\t\t\tif (words[i]) {\r\n\t\t\t\thumanized.push(words[i].charAt(0).toUpperCase() + words[i].slice(1));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn humanized.join(\" \");\r\n\t},\r\n\r\n\t/**\r\n\t * Test function to verify the implementation\r\n\t * @param {string} encodedQuery - The encoded query to test\r\n\t * @returns {string} JSON representation of the result\r\n\t */\r\n\ttest: function (encodedQuery) {\r\n\t\tvar result = this.convert(encodedQuery);\r\n\t\treturn JSON.stringify(result, null, 2);\r\n\t},\r\n\r\n\t/**\r\n\t * Legacy convert function that returns flat FilterCondition array\r\n\t * @param {string} condition - The encoded query to convert\r\n\t * @returns {Array} Array of FilterCondition objects\r\n\t */\r\n\tconvertToFlat: function (condition) {\r\n\t\tvar filterGroups = this.convert(condition);\r\n\t\tvar allConditions = [];\r\n\r\n\t\tfor (var i = 0; i < filterGroups.length; i++) {\r\n\t\t\tif (filterGroups[i].filters) {\r\n\t\t\t\tallConditions = allConditions.concat(filterGroups[i].filters);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn allConditions;\r\n\t},\r\n\r\n\t/**\r\n\t * Retrieves actual field metadata from ServiceNow tables\r\n\t * Similar to GetTableDropdownsData implementation\r\n\t * @param {string} table - The table name\r\n\t * @param {string} fieldName - The field element name\r\n\t * @returns {Object} Field metadata object with actual ServiceNow properties\r\n\t */\r\n\t_getActualFieldMetadata: function (table, fieldName) {\r\n\t\t// Check cache first\r\n\t\tvar cacheKey = table;\r\n\t\tif (this.fieldMetadataCache[cacheKey] && this.fieldMetadataCache[cacheKey][fieldName]) {\r\n\t\t\treturn this.fieldMetadataCache[cacheKey][fieldName];\r\n\t\t}\r\n\r\n\t\t// Load cache if not already loaded for this table\r\n\t\tif (!this.fieldMetadataCache[cacheKey]) {\r\n\t\t\tthis._loadFieldMetadataCache(table);\r\n\t\t}\r\n\r\n\t\t// Return from cache or default metadata\r\n\t\tif (this.fieldMetadataCache[cacheKey] && this.fieldMetadataCache[cacheKey][fieldName]) {\r\n\t\t\treturn this.fieldMetadataCache[cacheKey][fieldName];\r\n\t\t}\r\n\r\n\t\t// Return default metadata if field not found\r\n\t\treturn {\r\n\t\t\tname: fieldName,\r\n\t\t\tvalue: fieldName,\r\n\t\t\tdisplayValue: this._humanizeFieldName(fieldName),\r\n\t\t\ttype: \"string\",\r\n\t\t\tisChoice: false,\r\n\t\t\tchoices: [],\r\n\t\t\treferences: [],\r\n\t\t\trefTable: null,\r\n\t\t\treference: null,\r\n\t\t\tcanWrite: false,\r\n\t\t\tcanClear: false,\r\n\t\t\tcanSearch: false,\r\n\t\t\tmaxLength: null,\r\n\t\t\tisRelatedFilter: false,\r\n\t\t\trelatedFilter: {},\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Load field metadata cache for a table\r\n\t * @param {string} table - The table name\r\n\t */\r\n\t_loadFieldMetadataCache: function (table) {\r\n\t\tif (!table) return;\r\n\r\n\t\ttry {\r\n\t\t\t// Use GetTableDropdownsData to get comprehensive field metadata\r\n\t\t\tvar fieldsMetaData = this.GetTableDropdownsData.getData(table, false, true);\r\n\r\n\t\t\t// Initialize cache for this table\r\n\t\t\tthis.fieldMetadataCache[table] = {};\r\n\r\n\t\t\t// Process each field\r\n\t\t\tfor (var fieldName in fieldsMetaData) {\r\n\t\t\t\tif (fieldsMetaData.hasOwnProperty(fieldName)) {\r\n\t\t\t\t\tvar fieldData = fieldsMetaData[fieldName];\r\n\r\n\t\t\t\t\t// Store enhanced metadata\r\n\t\t\t\t\tthis.fieldMetadataCache[table][fieldName] = {\r\n\t\t\t\t\t\tname: fieldData.name || fieldName,\r\n\t\t\t\t\t\tvalue: fieldData.value || fieldName,\r\n\t\t\t\t\t\tdisplayValue: fieldData.displayValue || fieldData.name || this._humanizeFieldName(fieldName),\r\n\t\t\t\t\t\ttype: fieldData.type || \"string\",\r\n\t\t\t\t\t\tisChoice: fieldData.isChoice || false,\r\n\t\t\t\t\t\tchoices: fieldData.choices || [],\r\n\t\t\t\t\t\treferences: fieldData.references || [],\r\n\t\t\t\t\t\trefTable: fieldData.refTable || fieldData.reference || null,\r\n\t\t\t\t\t\treference: fieldData.reference || fieldData.refTable || null,\r\n\t\t\t\t\t\tcanWrite: fieldData.canWrite !== undefined ? fieldData.canWrite : true,\r\n\t\t\t\t\t\tcanClear: fieldData.canClear !== undefined ? fieldData.canClear : true,\r\n\t\t\t\t\t\tcanSearch: fieldData.canSearch !== undefined ? fieldData.canSearch : true,\r\n\t\t\t\t\t\tmaxLength: fieldData.maxLength || this._getDefaultMaxLength(fieldData.type),\r\n\t\t\t\t\t\tisRelatedFilter: fieldData.isRelatedFilter || false,\r\n\t\t\t\t\t\trelatedFilter: fieldData.relatedFilter || {},\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tgs.error(\"ConditionBuilderMS: Error loading field metadata cache for table \" + table + \": \" + e);\r\n\t\t\tthis.fieldMetadataCache[table] = {};\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Get default max length for a field type\r\n\t * @param {string} fieldType - The field type\r\n\t * @returns {string} Default max length\r\n\t */\r\n\t_getDefaultMaxLength: function (fieldType) {\r\n\t\tswitch (fieldType) {\r\n\t\t\tcase \"reference\":\r\n\t\t\t\treturn \"32\";\r\n\t\t\tcase \"boolean\":\r\n\t\t\t\treturn \"40\";\r\n\t\t\tcase \"integer\":\r\n\t\t\t\treturn \"15\";\r\n\t\t\tcase \"float\":\r\n\t\t\t\treturn \"15\";\r\n\t\t\tcase \"currency\":\r\n\t\t\t\treturn \"20\";\r\n\t\t\tcase \"glide_date_time\":\r\n\t\t\t\treturn \"40\";\r\n\t\t\tcase \"glide_date\":\r\n\t\t\t\treturn \"10\";\r\n\t\t\tcase \"glide_time\":\r\n\t\t\t\treturn \"15\";\r\n\t\t\tcase \"glide_duration\":\r\n\t\t\t\treturn \"40\";\r\n\t\t\tdefault:\r\n\t\t\t\treturn \"40\";\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Get choice values for a choice field\r\n\t * @param {string} table - The table name\r\n\t * @param {string} fieldName - The field element name\r\n\t * @returns {Array} Array of choice objects\r\n\t */\r\n\t_getChoiceValues: function (table, fieldName) {\r\n\t\tvar choices = [];\r\n\r\n\t\ttry {\r\n\t\t\tvar choiceGR = new GlideRecordSecure(\"sys_choice\");\r\n\t\t\tchoiceGR.addQuery(\"name\", table);\r\n\t\t\tchoiceGR.addQuery(\"element\", fieldName);\r\n\t\t\tchoiceGR.addQuery(\"inactive\", false);\r\n\t\t\tchoiceGR.addQuery(\"language\", \"en\"); // TODO: Support multiple languages\r\n\t\t\tchoiceGR.orderBy(\"sequence\");\r\n\t\t\tchoiceGR.orderBy(\"value\");\r\n\t\t\tchoiceGR.query();\r\n\r\n\t\t\twhile (choiceGR.next()) {\r\n\t\t\t\tchoices.push({\r\n\t\t\t\t\tlabel: choiceGR.getValue(\"label\"),\r\n\t\t\t\t\tvalue: choiceGR.getValue(\"value\"),\r\n\t\t\t\t\tcolor: \"\",\r\n\t\t\t\t\tclassName: \"\",\r\n\t\t\t\t\ticon: false,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If no choices found, check task table (for inherited fields)\r\n\t\t\tif (choices.length === 0 && table !== \"task\") {\r\n\t\t\t\tchoiceGR = new GlideRecordSecure(\"sys_choice\");\r\n\t\t\t\tchoiceGR.addQuery(\"name\", \"task\");\r\n\t\t\t\tchoiceGR.addQuery(\"element\", fieldName);\r\n\t\t\t\tchoiceGR.addQuery(\"inactive\", false);\r\n\t\t\t\tchoiceGR.addQuery(\"language\", \"en\");\r\n\t\t\t\tchoiceGR.orderBy(\"sequence\");\r\n\t\t\t\tchoiceGR.orderBy(\"value\");\r\n\t\t\t\tchoiceGR.query();\r\n\r\n\t\t\t\twhile (choiceGR.next()) {\r\n\t\t\t\t\tchoices.push({\r\n\t\t\t\t\t\tlabel: choiceGR.getValue(\"label\"),\r\n\t\t\t\t\t\tvalue: choiceGR.getValue(\"value\"),\r\n\t\t\t\t\t\tcolor: \"\",\r\n\t\t\t\t\t\tclassName: \"\",\r\n\t\t\t\t\t\ticon: false,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tgs.error(\"ConditionBuilderMS: Error getting choice values for \" + table + \".\" + fieldName + \": \" + e);\r\n\t\t}\r\n\r\n\t\treturn choices;\r\n\t},\r\n\r\n\t/**\r\n\t * Get initial reference values for a reference field\r\n\t * @param {string} refTable - The reference table name\r\n\t * @param {string} table - The source table name\r\n\t * @param {string} fieldName - The field element name\r\n\t * @returns {Array} Array of reference objects\r\n\t */\r\n\t_getInitialReferences: function (refTable, table, fieldName) {\r\n\t\tvar references = [];\r\n\r\n\t\ttry {\r\n\t\t\t// Get reference qualifier if any\r\n\t\t\tvar referenceQualifier = \"\";\r\n\t\t\tvar refQualOverrideGR = new GlideRecord(\"sys_dictionary_override\");\r\n\t\t\trefQualOverrideGR.addQuery(\"name\", table);\r\n\t\t\trefQualOverrideGR.addQuery(\"element\", fieldName);\r\n\t\t\trefQualOverrideGR.query();\r\n\t\t\tif (refQualOverrideGR.next()) {\r\n\t\t\t\tif (refQualOverrideGR.getValue(\"reference_qual_override\") === \"1\") {\r\n\t\t\t\t\tvar refQual = refQualOverrideGR.getValue(\"reference_qual\");\r\n\t\t\t\t\tif (refQual && !refQual.includes(\"javascript:\")) {\r\n\t\t\t\t\t\treferenceQualifier = refQual;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Query reference table for initial values\r\n\t\t\tvar refGR = new GlideRecordSecure(refTable);\r\n\t\t\tif (referenceQualifier) {\r\n\t\t\t\trefGR.addEncodedQuery(referenceQualifier);\r\n\t\t\t}\r\n\t\t\trefGR.orderBy(refGR.getDisplayName());\r\n\t\t\trefGR.setLimit(12); // Limit to 12 like GetTableDropdownsData\r\n\t\t\trefGR.query();\r\n\r\n\t\t\twhile (refGR.next()) {\r\n\t\t\t\tvar refObj = {\r\n\t\t\t\t\tlabel: refGR.getDisplayValue() || \"Empty\",\r\n\t\t\t\t\tvalue: refGR.getValue(\"sys_id\"),\r\n\t\t\t\t\trefTable: refTable,\r\n\t\t\t\t\ticon: false,\r\n\t\t\t\t\tcolor: \"\",\r\n\t\t\t\t\tclassName: \"\",\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Special handling for sys_user (add avatar)\r\n\t\t\t\tif (refTable === \"sys_user\") {\r\n\t\t\t\t\tvar avatar = refGR.getValue(\"avatar\");\r\n\t\t\t\t\tvar photo = refGR.getValue(\"photo\");\r\n\t\t\t\t\trefObj.avatar = avatar || photo ? (avatar || photo) + \".iix\" : \"\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Special handling for tables with color fields\r\n\t\t\t\tif (\"x_cadso_work_status,x_cadso_work_project,x_cadso_work_campaign\".indexOf(refTable) > -1) {\r\n\t\t\t\t\tvar colorField = refTable === \"x_cadso_work_status\" ? \"color\" : \"glyph_color\";\r\n\t\t\t\t\trefObj.color = refGR.getValue(colorField) || \"\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\treferences.push(refObj);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tgs.error(\"ConditionBuilderMS: Error getting reference values for \" + refTable + \": \" + e);\r\n\t\t}\r\n\r\n\t\treturn references;\r\n\t},\r\n\r\n\t/**\r\n\t * Format value based on field type\r\n\t * @param {string} value - The value to format\r\n\t * @param {string} fieldType - The field type\r\n\t * @param {string} operator - The operator type\r\n\t * @returns {string|Object} Formatted value\r\n\t */\r\n\t_formatValueByType: function (value, fieldType, operator) {\r\n\t\tif (!value) return value;\r\n\r\n\t\tvar Utils = this.Utils;\r\n\r\n\t\t// Handle special date values\r\n\t\tif (fieldType === \"glide_date_time\" || fieldType === \"glide_date\") {\r\n\t\t\tvar formatted = Utils.handleSpecialDateValue(value, operator);\r\n\t\t\tif (formatted !== value) {\r\n\t\t\t\treturn formatted;\r\n\t\t\t}\r\n\r\n\t\t\t// Format date time values\r\n\t\t\tif (operator === \"ON\" && value.indexOf(\"@\") > -1) {\r\n\t\t\t\treturn value; // Keep full value with javascript expressions\r\n\t\t\t}\r\n\r\n\t\t\treturn Utils.formatDateTimeValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle boolean values\r\n\t\tif (fieldType === \"boolean\") {\r\n\t\t\treturn value.toLowerCase() === \"true\" || value === \"1\" ? \"true\" : \"false\";\r\n\t\t}\r\n\r\n\t\t// Handle choice values\r\n\t\tif (fieldType === \"choice\") {\r\n\t\t\treturn Utils.formatChoiceValue(value, this.currentTable, fieldType);\r\n\t\t}\r\n\r\n\t\t// Handle currency values\r\n\t\tif (fieldType === \"currency\") {\r\n\t\t\treturn Utils.formatCurrencyValue(value, operator);\r\n\t\t}\r\n\r\n\t\t// Handle duration values\r\n\t\tif (fieldType === \"glide_duration\") {\r\n\t\t\treturn Utils.formatDurationValue(value);\r\n\t\t}\r\n\r\n\t\t// Handle reference values - keep sys_id\r\n\t\tif (fieldType === \"reference\") {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Handle numeric fields\r\n\t\tif (fieldType === \"integer\" || fieldType === \"float\" || fieldType === \"decimal\") {\r\n\t\t\t// Keep numeric values as strings for proper handling\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Default - return as is\r\n\t\treturn value;\r\n\t},\r\n\r\n\ttype: \"ConditionBuilderMS\",\r\n};\r\n"
    }
  },
  "sys_class_name": {
    "value": "sys_script_include",
    "display_value": "Script Include"
  },
  "sys_package": {
    "value": "608cd026c374e250d4ddf1db050131bb",
    "display_value": "Tenon - Core"
  },
  "sys_update_name": {
    "value": "sys_script_include_4a950c0bc3132210d4ddf1db05013160",
    "display_value": "sys_script_include_4a950c0bc3132210d4ddf1db05013160"
  },
  "sys_updated_by": {
    "value": "daniel.cudney",
    "display_value": "daniel.cudney"
  },
  "api_name": {
    "value": "x_cadso_core.ConditionBuilderMS",
    "display_value": "x_cadso_core.ConditionBuilderMS"
  },
  "sys_created_on": {
    "value": "2025-08-15 18:20:16",
    "display_value": "2025-08-15 11:20:16 AM"
  },
  "caller_access": {
    "value": "",
    "display_value": null
  },
  "name": {
    "value": "ConditionBuilderMS",
    "display_value": "ConditionBuilderMS"
  },
  "sys_name": {
    "value": "ConditionBuilderMS",
    "display_value": "ConditionBuilderMS"
  },
  "sys_scope": {
    "value": "608cd026c374e250d4ddf1db050131bb",
    "display_value": "Tenon - Core"
  },
  "sys_created_by": {
    "value": "admin",
    "display_value": "admin"
  },
  "sys_policy": {
    "value": "read",
    "display_value": "Read-only"
  }
}
