{
  "_metadata": {
    "table": "sys_script_include",
    "sys_id": "97333a10330d2a507b18bc534d5c7baf",
    "extracted_at": "2025-09-19T21:48:28.902Z",
    "display_value": "APIUtilsMS",
    "application": "Tenon_-_Core",
    "scope": {
      "display_value": "Tenon - Core",
      "link": "https://tenonworkstudio.service-now.com/api/now/table/sys_scope/608cd026c374e250d4ddf1db050131bb",
      "value": "608cd026c374e250d4ddf1db050131bb"
    }
  },
  "client_callable": {
    "value": "false",
    "display_value": "false"
  },
  "access": {
    "value": "public",
    "display_value": "All application scopes"
  },
  "mobile_callable": {
    "value": "false",
    "display_value": "false"
  },
  "sys_mod_count": {
    "value": "24",
    "display_value": "24"
  },
  "active": {
    "value": "true",
    "display_value": "true"
  },
  "description": {
    "value": "Utilities methods for performing operations from SRAPIs\r\n\r\nExamples:\r\n\r\nconst apiUtil = new x_cadso_automate.APIUtils()\r\n\r\n// Get a single record from any table, optionally include an array of fields to return, otherwise get all field from the table\r\nlet email = apiUtil.get({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71',\r\n    returnFields: ['name', 'html', 'status']\r\n});\r\n\r\n//Update a single record on any table providing an object with field names and values\r\nlet email = apiUtil.update({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71',\r\n    updates: {\r\n        name: 'Updated Name',\r\n        status: 'published'\r\n    }\r\n})\r\n\r\n//Insert a record to any table using providing an object with field names and values. Optionally include an array of fields' values to be returned, otherwise get all fields from the table\r\nlet email = apiUtil.insert({\r\n    table: 'x_cadso_automate_email',\r\n    data: {\r\n        name: 'New email',\r\n        status: 'draft'\r\n    },\r\n\r\n})\r\n\r\n// Get a record count for any table with the provided query. Optionally include a field to group by\r\nlet emailCount = apiUtil.count{\r\n    table: 'x_cadso_automate_email',\r\n    query: 'status=sent'\r\n}\r\n\r\n// Delete a single record from any table\r\napiUtil.delete({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71'\r\n})\r\n\r\n// Get the first or last record of a query\r\nlet currentVersionNumber = apiUtil.queryFirstOrLast({\r\n    table: 'x_cadso_journey_version',\r\n    query: 'journey=0598b22b877313003c1c8467a7cb0b71',\r\n    orderBy: 'version',\r\n    order: 'descending',\r\n    returnFields: 'version'\r\n})",
    "display_value": "Utilities methods for performing operations from SRAPIs\r\n\r\nExamples:\r\n\r\nconst apiUtil = new x_cadso_automate.APIUtils()\r\n\r\n// Get a single record from any table, optionally include an array of fields to return, otherwise get all field from the table\r\nlet email = apiUtil.get({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71',\r\n    returnFields: ['name', 'html', 'status']\r\n});\r\n\r\n//Update a single record on any table providing an object with field names and values\r\nlet email = apiUtil.update({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71',\r\n    updates: {\r\n        name: 'Updated Name',\r\n        status: 'published'\r\n    }\r\n})\r\n\r\n//Insert a record to any table using providing an object with field names and values. Optionally include an array of fields' values to be returned, otherwise get all fields from the table\r\nlet email = apiUtil.insert({\r\n    table: 'x_cadso_automate_email',\r\n    data: {\r\n        name: 'New email',\r\n        status: 'draft'\r\n    },\r\n\r\n})\r\n\r\n// Get a record count for any table with the provided query. Optionally include a field to group by\r\nlet emailCount = apiUtil.count{\r\n    table: 'x_cadso_automate_email',\r\n    query: 'status=sent'\r\n}\r\n\r\n// Delete a single record from any table\r\napiUtil.delete({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71'\r\n})\r\n\r\n// Get the first or last record of a query\r\nlet currentVersionNumber = apiUtil.queryFirstOrLast({\r\n    table: 'x_cadso_journey_version',\r\n    query: 'journey=0598b22b877313003c1c8467a7cb0b71',\r\n    orderBy: 'version',\r\n    order: 'descending',\r\n    returnFields: 'version'\r\n})"
  },
  "sys_updated_on": {
    "value": "2025-06-20 20:59:01",
    "display_value": "2025-06-20 01:59:01 PM"
  },
  "sys_tags": {
    "value": "",
    "display_value": ""
  },
  "sandbox_callable": {
    "value": "false",
    "display_value": "false"
  },
  "script": {
    "value": "var APIUtilsMS = Class.create();\nAPIUtilsMS.prototype = {\n    initialize: function() {\n        this.defaultFields = {\n            \"x_cadso_automate_content_template\": ['json_content']\n        };\n    },\n\n    get: function({\n        table,\n        sysID,\n        returnFields,\n\t\tincludeDisplay\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        // if(table.indexOf('x_cadso_') !== 0){\n        // \tthrow new Error('API is not configured to get records for ' + table);\n        // }\n        if (!sysID) {\n            throw new Error('Missing sys_id');\n        }\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\n        let recordGQ = new global.GlideQuery(table)\n            .get(sysID, returnFields)\n            .orElse(null);\n        return recordGQ;\n    },\n\n    delete: function({\n        table,\n        sysID\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to delete records for ' + table);\n        }\n        const recordGR = new GlideRecord(table);\n        if (!recordGR.get(sysID)) {\n            return false;\n        }\n        return recordGR.deleteRecord();\n    },\n\n    queryFirstOrLast({\n        table,\n        query,\n        returnFields,\n        orderBy,\n        order\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to get records for ' + table);\n        }\n        if (!orderBy) {\n            throw new Error('Must provide a field to order by');\n        }\n\n        order = order || 'orderBy';\n        returnFields = returnFields || this._getTableSchema(table);\n\n        const recordGQ = new global.GlideQuery.parse(table, query)[order](orderBy)\n            .selectOne(returnFields)\n        try {\n            return recordGQ.get()\n        } catch (error) {\n            return null;\n        }\n    },\n\n    query: function({\n        table,\n        query,\n        returnFields\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        // if(table.indexOf('x_cadso_') !== 0){\n        // \tthrow new Error('API is not configured to get records for ' + table);\n        // }\n        if (!query) {\n            throw new Error('Must provide a query');\n        }\n\n        returnFields = returnFields || this._getTableSchema(table);\n        let records = [];\n\n        let tableGQ = new global.GlideQuery.parse(table, query)\n            .select(returnFields)\n            .forEach(record => records.push(record));\n\n        return records;\n    },\n\n    update: function({\n        table,\n        sysID,\n        updates,\n        returnFields,\n        enforceAcls = false\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to update records for ' + table);\n        }\n        if (!sysID) {\n            throw new Error('Must provide sys_id');\n        }\n        if (!updates || Object.getOwnPropertyNames(updates).length === 0) {\n            throw new Error('Must include field values');\n        }\n\n        returnFields = this._getTableSchema(table);\n\n        let invalidFields = this._checkFields(table, updates);\n        invalidFields.forEach(key => delete updates[key]);\n\n\n        let recordGQ = new global.GlideQuery(table)\n            .where('sys_id', sysID);\n        if (enforceAcls) {\n            recordGQ.withAcls();\n        }\n\n        let response = recordGQ.update(updates, returnFields)\n\t\t.orElse(null)\n\n        return response;\n    },\n\n    insert: function({\n        table,\n        data,\n        returnFields,\n        enforceAcls = false\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to create records for ' + table);\n        }\n        if (!data || Object.getOwnPropertyNames(data).length === 0) {\n            throw new Error('Must include field values');\n        }\n\n        returnFields = returnFields || this._getTableSchema(table);\n\n        let invalidFields = this._checkFields(table, data);\n        invalidFields.forEach(key => delete data[key]);\n\n        const recordGQ = new global.GlideQuery(table);\n        if (enforceAcls) {\n            recordGQ.withAcls();\n        }\n        recordGQ.insert(data)\n            .get(returnFields);\n        return recordGQ;\n    },\n\n    count: function({\n        table,\n        query,\n        groupBy,\n        distinctField\n    }) {\n        // if(table.indexOf('x_cadso') === -1){\n        // \tthrow new Error('API is not configured to get counts for ' + table);\n        // }\n        let recordGQ = new global.GlideQuery.parse(table, query);\n        if (groupBy && distinctField) {\n            var ga = new GlideAggregate(table);\n            ga.addEncodedQuery(query);\n            ga.groupBy(groupBy);\n            ga.addAggregate('COUNT(DISTINCT', distinctField);\n            ga.query();\n\n            var result = {};\n            while (ga.next()) {\n                result[ga.getValue(groupBy)] = ga.getAggregate('COUNT(DISTINCT', distinctField);\n            }\n            return result;\n        } else if (groupBy) {\n            let counts = {};\n            recordGQ\n                .groupBy(groupBy)\n                .aggregate('COUNT')\n                .select()\n                .forEach(result => counts[result.group[groupBy]] = result.count);\n            return counts;\n        } else {\n            return recordGQ.count();\n        }\n    },\n\n    getRequiredParameters(schemaID) {\n        const requiredParameters = [];\n        const propertyGQ = new global.GlideQuery('x_cadso_api_docs_schema_properties')\n            .where('parent_schema', schemaID)\n            .where('required', true)\n            .select('name')\n            .forEach(parameter >= requiredParameters.push(parameter));\n        return requiredParameters;\n    },\n\n\t_getTableSchema: function(table, includeDisplay){\n\t\tconst schema = global.Schema.of(table, ['*']);\n\t\tlet fields = Object.keys(schema[table]);\n\t\tfields = fields.filter(field => !field.includes('sys_') || field == 'sys_id' || field == 'sys_class_name');\n\n\t\tfields = includeDisplay ? fields.flatMap(field => [field, `${field}$DISPLAY`]) : fields;\n\t\treturn fields.sort();\n\t},\n\n\n    _checkFields(table, fields) {\n        let invalidFields = [];\n        let tableGR = new GlideRecord(table);\n        for (field in fields) {\n            if (!tableGR.isValidField(field)) {\n                invalidFields.push(field);\n            }\n        }\n        return invalidFields;\n    },\n\n    type: 'APIUtilsMS'\n};",
    "display_value": "var APIUtilsMS = Class.create();\nAPIUtilsMS.prototype = {\n    initialize: function() {\n        this.defaultFields = {\n            \"x_cadso_automate_content_template\": ['json_content']\n        };\n    },\n\n    get: function({\n        table,\n        sysID,\n        returnFields,\n\t\tincludeDisplay\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        // if(table.indexOf('x_cadso_') !== 0){\n        // \tthrow new Error('API is not configured to get records for ' + table);\n        // }\n        if (!sysID) {\n            throw new Error('Missing sys_id');\n        }\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\n        let recordGQ = new global.GlideQuery(table)\n            .get(sysID, returnFields)\n            .orElse(null);\n        return recordGQ;\n    },\n\n    delete: function({\n        table,\n        sysID\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to delete records for ' + table);\n        }\n        const recordGR = new GlideRecord(table);\n        if (!recordGR.get(sysID)) {\n            return false;\n        }\n        return recordGR.deleteRecord();\n    },\n\n    queryFirstOrLast({\n        table,\n        query,\n        returnFields,\n        orderBy,\n        order\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to get records for ' + table);\n        }\n        if (!orderBy) {\n            throw new Error('Must provide a field to order by');\n        }\n\n        order = order || 'orderBy';\n        returnFields = returnFields || this._getTableSchema(table);\n\n        const recordGQ = new global.GlideQuery.parse(table, query)[order](orderBy)\n            .selectOne(returnFields)\n        try {\n            return recordGQ.get()\n        } catch (error) {\n            return null;\n        }\n    },\n\n    query: function({\n        table,\n        query,\n        returnFields\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        // if(table.indexOf('x_cadso_') !== 0){\n        // \tthrow new Error('API is not configured to get records for ' + table);\n        // }\n        if (!query) {\n            throw new Error('Must provide a query');\n        }\n\n        returnFields = returnFields || this._getTableSchema(table);\n        let records = [];\n\n        let tableGQ = new global.GlideQuery.parse(table, query)\n            .select(returnFields)\n            .forEach(record => records.push(record));\n\n        return records;\n    },\n\n    update: function({\n        table,\n        sysID,\n        updates,\n        returnFields,\n        enforceAcls = false\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to update records for ' + table);\n        }\n        if (!sysID) {\n            throw new Error('Must provide sys_id');\n        }\n        if (!updates || Object.getOwnPropertyNames(updates).length === 0) {\n            throw new Error('Must include field values');\n        }\n\n        returnFields = this._getTableSchema(table);\n\n        let invalidFields = this._checkFields(table, updates);\n        invalidFields.forEach(key => delete updates[key]);\n\n\n        let recordGQ = new global.GlideQuery(table)\n            .where('sys_id', sysID);\n        if (enforceAcls) {\n            recordGQ.withAcls();\n        }\n\n        let response = recordGQ.update(updates, returnFields)\n\t\t.orElse(null)\n\n        return response;\n    },\n\n    insert: function({\n        table,\n        data,\n        returnFields,\n        enforceAcls = false\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to create records for ' + table);\n        }\n        if (!data || Object.getOwnPropertyNames(data).length === 0) {\n            throw new Error('Must include field values');\n        }\n\n        returnFields = returnFields || this._getTableSchema(table);\n\n        let invalidFields = this._checkFields(table, data);\n        invalidFields.forEach(key => delete data[key]);\n\n        const recordGQ = new global.GlideQuery(table);\n        if (enforceAcls) {\n            recordGQ.withAcls();\n        }\n        recordGQ.insert(data)\n            .get(returnFields);\n        return recordGQ;\n    },\n\n    count: function({\n        table,\n        query,\n        groupBy,\n        distinctField\n    }) {\n        // if(table.indexOf('x_cadso') === -1){\n        // \tthrow new Error('API is not configured to get counts for ' + table);\n        // }\n        let recordGQ = new global.GlideQuery.parse(table, query);\n        if (groupBy && distinctField) {\n            var ga = new GlideAggregate(table);\n            ga.addEncodedQuery(query);\n            ga.groupBy(groupBy);\n            ga.addAggregate('COUNT(DISTINCT', distinctField);\n            ga.query();\n\n            var result = {};\n            while (ga.next()) {\n                result[ga.getValue(groupBy)] = ga.getAggregate('COUNT(DISTINCT', distinctField);\n            }\n            return result;\n        } else if (groupBy) {\n            let counts = {};\n            recordGQ\n                .groupBy(groupBy)\n                .aggregate('COUNT')\n                .select()\n                .forEach(result => counts[result.group[groupBy]] = result.count);\n            return counts;\n        } else {\n            return recordGQ.count();\n        }\n    },\n\n    getRequiredParameters(schemaID) {\n        const requiredParameters = [];\n        const propertyGQ = new global.GlideQuery('x_cadso_api_docs_schema_properties')\n            .where('parent_schema', schemaID)\n            .where('required', true)\n            .select('name')\n            .forEach(parameter >= requiredParameters.push(parameter));\n        return requiredParameters;\n    },\n\n\t_getTableSchema: function(table, includeDisplay){\n\t\tconst schema = global.Schema.of(table, ['*']);\n\t\tlet fields = Object.keys(schema[table]);\n\t\tfields = fields.filter(field => !field.includes('sys_') || field == 'sys_id' || field == 'sys_class_name');\n\n\t\tfields = includeDisplay ? fields.flatMap(field => [field, `${field}$DISPLAY`]) : fields;\n\t\treturn fields.sort();\n\t},\n\n\n    _checkFields(table, fields) {\n        let invalidFields = [];\n        let tableGR = new GlideRecord(table);\n        for (field in fields) {\n            if (!tableGR.isValidField(field)) {\n                invalidFields.push(field);\n            }\n        }\n        return invalidFields;\n    },\n\n    type: 'APIUtilsMS'\n};",
    "formatted_script": {
      "line_count": 237,
      "char_count": 6870,
      "preview": "var APIUtilsMS = Class.create();\nAPIUtilsMS.prototype = {\n    initialize: function() {\n        this.defaultFields = {\n            \"x_cadso_automate_content_template\": ['json_content']\n        };\n    }...",
      "full_script": "var APIUtilsMS = Class.create();\nAPIUtilsMS.prototype = {\n    initialize: function() {\n        this.defaultFields = {\n            \"x_cadso_automate_content_template\": ['json_content']\n        };\n    },\n\n    get: function({\n        table,\n        sysID,\n        returnFields,\n\t\tincludeDisplay\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        // if(table.indexOf('x_cadso_') !== 0){\n        // \tthrow new Error('API is not configured to get records for ' + table);\n        // }\n        if (!sysID) {\n            throw new Error('Missing sys_id');\n        }\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\n        let recordGQ = new global.GlideQuery(table)\n            .get(sysID, returnFields)\n            .orElse(null);\n        return recordGQ;\n    },\n\n    delete: function({\n        table,\n        sysID\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to delete records for ' + table);\n        }\n        const recordGR = new GlideRecord(table);\n        if (!recordGR.get(sysID)) {\n            return false;\n        }\n        return recordGR.deleteRecord();\n    },\n\n    queryFirstOrLast({\n        table,\n        query,\n        returnFields,\n        orderBy,\n        order\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to get records for ' + table);\n        }\n        if (!orderBy) {\n            throw new Error('Must provide a field to order by');\n        }\n\n        order = order || 'orderBy';\n        returnFields = returnFields || this._getTableSchema(table);\n\n        const recordGQ = new global.GlideQuery.parse(table, query)[order](orderBy)\n            .selectOne(returnFields)\n        try {\n            return recordGQ.get()\n        } catch (error) {\n            return null;\n        }\n    },\n\n    query: function({\n        table,\n        query,\n        returnFields\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        // if(table.indexOf('x_cadso_') !== 0){\n        // \tthrow new Error('API is not configured to get records for ' + table);\n        // }\n        if (!query) {\n            throw new Error('Must provide a query');\n        }\n\n        returnFields = returnFields || this._getTableSchema(table);\n        let records = [];\n\n        let tableGQ = new global.GlideQuery.parse(table, query)\n            .select(returnFields)\n            .forEach(record => records.push(record));\n\n        return records;\n    },\n\n    update: function({\n        table,\n        sysID,\n        updates,\n        returnFields,\n        enforceAcls = false\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to update records for ' + table);\n        }\n        if (!sysID) {\n            throw new Error('Must provide sys_id');\n        }\n        if (!updates || Object.getOwnPropertyNames(updates).length === 0) {\n            throw new Error('Must include field values');\n        }\n\n        returnFields = this._getTableSchema(table);\n\n        let invalidFields = this._checkFields(table, updates);\n        invalidFields.forEach(key => delete updates[key]);\n\n\n        let recordGQ = new global.GlideQuery(table)\n            .where('sys_id', sysID);\n        if (enforceAcls) {\n            recordGQ.withAcls();\n        }\n\n        let response = recordGQ.update(updates, returnFields)\n\t\t.orElse(null)\n\n        return response;\n    },\n\n    insert: function({\n        table,\n        data,\n        returnFields,\n        enforceAcls = false\n    }) {\n        if (!table) {\n            throw new Error('Must provide a table');\n        }\n        if (table.indexOf('x_cadso_') !== 0) {\n            throw new Error('API is not configured to create records for ' + table);\n        }\n        if (!data || Object.getOwnPropertyNames(data).length === 0) {\n            throw new Error('Must include field values');\n        }\n\n        returnFields = returnFields || this._getTableSchema(table);\n\n        let invalidFields = this._checkFields(table, data);\n        invalidFields.forEach(key => delete data[key]);\n\n        const recordGQ = new global.GlideQuery(table);\n        if (enforceAcls) {\n            recordGQ.withAcls();\n        }\n        recordGQ.insert(data)\n            .get(returnFields);\n        return recordGQ;\n    },\n\n    count: function({\n        table,\n        query,\n        groupBy,\n        distinctField\n    }) {\n        // if(table.indexOf('x_cadso') === -1){\n        // \tthrow new Error('API is not configured to get counts for ' + table);\n        // }\n        let recordGQ = new global.GlideQuery.parse(table, query);\n        if (groupBy && distinctField) {\n            var ga = new GlideAggregate(table);\n            ga.addEncodedQuery(query);\n            ga.groupBy(groupBy);\n            ga.addAggregate('COUNT(DISTINCT', distinctField);\n            ga.query();\n\n            var result = {};\n            while (ga.next()) {\n                result[ga.getValue(groupBy)] = ga.getAggregate('COUNT(DISTINCT', distinctField);\n            }\n            return result;\n        } else if (groupBy) {\n            let counts = {};\n            recordGQ\n                .groupBy(groupBy)\n                .aggregate('COUNT')\n                .select()\n                .forEach(result => counts[result.group[groupBy]] = result.count);\n            return counts;\n        } else {\n            return recordGQ.count();\n        }\n    },\n\n    getRequiredParameters(schemaID) {\n        const requiredParameters = [];\n        const propertyGQ = new global.GlideQuery('x_cadso_api_docs_schema_properties')\n            .where('parent_schema', schemaID)\n            .where('required', true)\n            .select('name')\n            .forEach(parameter >= requiredParameters.push(parameter));\n        return requiredParameters;\n    },\n\n\t_getTableSchema: function(table, includeDisplay){\n\t\tconst schema = global.Schema.of(table, ['*']);\n\t\tlet fields = Object.keys(schema[table]);\n\t\tfields = fields.filter(field => !field.includes('sys_') || field == 'sys_id' || field == 'sys_class_name');\n\n\t\tfields = includeDisplay ? fields.flatMap(field => [field, `${field}$DISPLAY`]) : fields;\n\t\treturn fields.sort();\n\t},\n\n\n    _checkFields(table, fields) {\n        let invalidFields = [];\n        let tableGR = new GlideRecord(table);\n        for (field in fields) {\n            if (!tableGR.isValidField(field)) {\n                invalidFields.push(field);\n            }\n        }\n        return invalidFields;\n    },\n\n    type: 'APIUtilsMS'\n};"
    }
  },
  "sys_class_name": {
    "value": "sys_script_include",
    "display_value": "Script Include"
  },
  "sys_package": {
    "value": "608cd026c374e250d4ddf1db050131bb",
    "display_value": "Tenon - Core"
  },
  "sys_update_name": {
    "value": "sys_script_include_97333a10330d2a507b18bc534d5c7baf",
    "display_value": "sys_script_include_97333a10330d2a507b18bc534d5c7baf"
  },
  "sys_updated_by": {
    "value": "rob.medved",
    "display_value": "rob.medved"
  },
  "api_name": {
    "value": "x_cadso_core.APIUtilsMS",
    "display_value": "x_cadso_core.APIUtilsMS"
  },
  "sys_created_on": {
    "value": "2025-04-17 21:35:11",
    "display_value": "2025-04-17 02:35:11 PM"
  },
  "caller_access": {
    "value": "",
    "display_value": null
  },
  "name": {
    "value": "APIUtilsMS",
    "display_value": "APIUtilsMS"
  },
  "sys_name": {
    "value": "APIUtilsMS",
    "display_value": "APIUtilsMS"
  },
  "sys_scope": {
    "value": "608cd026c374e250d4ddf1db050131bb",
    "display_value": "Tenon - Core"
  },
  "sys_created_by": {
    "value": "rob.medved",
    "display_value": "rob.medved"
  },
  "sys_policy": {
    "value": "read",
    "display_value": "Read-only"
  }
}
