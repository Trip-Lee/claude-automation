{
  "_metadata": {
    "table": "sys_script_include",
    "sys_id": "e316635cc3aa425085b196c4e40131f3",
    "extracted_at": "2025-09-19T21:48:29.568Z",
    "display_value": "APIUtilsMS",
    "application": "Tenon_Marketing_Automation",
    "scope": {
      "display_value": "Tenon Marketing Automation",
      "link": "https://tenonworkstudio.service-now.com/api/now/table/sys_scope/5e9f5f8b87420250369f33373cbb3559",
      "value": "5e9f5f8b87420250369f33373cbb3559"
    }
  },
  "client_callable": {
    "value": "false",
    "display_value": "false"
  },
  "access": {
    "value": "public",
    "display_value": "All application scopes"
  },
  "mobile_callable": {
    "value": "false",
    "display_value": "false"
  },
  "sys_mod_count": {
    "value": "190",
    "display_value": "190"
  },
  "active": {
    "value": "true",
    "display_value": "true"
  },
  "description": {
    "value": "Utilities methods for performing operations from SRAPIs\r\nExamples:\r\n\r\nconst apiUtil = new x_cadso_automate.APIUtils()\r\n\r\n// Get a single record from any table, optionally include an array of fields to return, otherwise get all field from the table\r\nlet email = apiUtil.get({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71',\r\n    returnFields: ['name', 'html', 'status']\r\n});\r\n\r\n//Update a single record on any table providing an object with field names and values\r\nlet email = apiUtil.update({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71',\r\n    updates: {\r\n        name: 'Updated Name',\r\n        status: 'published'\r\n    }\r\n})\r\n\r\n//Insert a record to any table using providing an object with field names and values. Optionally include an array of fields' values to be returned, otherwise get all fields from the table\r\nlet email = apiUtil.insert({\r\n    table: 'x_cadso_automate_email',\r\n    data: {\r\n        name: 'New email',\r\n        status: 'draft'\r\n    },\r\n\r\n})\r\n\r\n// Get a record count for any table with the provided query. Optionally include a field to group by\r\nlet emailCount = apiUtil.count{\r\n    table: 'x_cadso_automate_email',\r\n    query: 'status=sent'\r\n}\r\n\r\n// Delete a single record from any table\r\napiUtil.delete({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71'\r\n})\r\n\r\n// Get the first or last record of a query\r\nlet currentVersionNumber = apiUtil.queryFirstOrLast({\r\n    table: 'x_cadso_journey_version',\r\n    query: 'journey=0598b22b877313003c1c8467a7cb0b71',\r\n    orderBy: 'version',\r\n    order: 'descending',\r\n    returnFields: 'version'\r\n})\r\n\r\n// Duplicate a single record from any table\r\napiUtil.duplicate({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71',\r\n   data: [\r\n      { \"name\": \"new name\", \"type\": \"standard\" }\r\n   ]\r\n})",
    "display_value": "Utilities methods for performing operations from SRAPIs\r\nExamples:\r\n\r\nconst apiUtil = new x_cadso_automate.APIUtils()\r\n\r\n// Get a single record from any table, optionally include an array of fields to return, otherwise get all field from the table\r\nlet email = apiUtil.get({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71',\r\n    returnFields: ['name', 'html', 'status']\r\n});\r\n\r\n//Update a single record on any table providing an object with field names and values\r\nlet email = apiUtil.update({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71',\r\n    updates: {\r\n        name: 'Updated Name',\r\n        status: 'published'\r\n    }\r\n})\r\n\r\n//Insert a record to any table using providing an object with field names and values. Optionally include an array of fields' values to be returned, otherwise get all fields from the table\r\nlet email = apiUtil.insert({\r\n    table: 'x_cadso_automate_email',\r\n    data: {\r\n        name: 'New email',\r\n        status: 'draft'\r\n    },\r\n\r\n})\r\n\r\n// Get a record count for any table with the provided query. Optionally include a field to group by\r\nlet emailCount = apiUtil.count{\r\n    table: 'x_cadso_automate_email',\r\n    query: 'status=sent'\r\n}\r\n\r\n// Delete a single record from any table\r\napiUtil.delete({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71'\r\n})\r\n\r\n// Get the first or last record of a query\r\nlet currentVersionNumber = apiUtil.queryFirstOrLast({\r\n    table: 'x_cadso_journey_version',\r\n    query: 'journey=0598b22b877313003c1c8467a7cb0b71',\r\n    orderBy: 'version',\r\n    order: 'descending',\r\n    returnFields: 'version'\r\n})\r\n\r\n// Duplicate a single record from any table\r\napiUtil.duplicate({\r\n    table: 'x_cadso_automate_email',\r\n    sysID: '0598b22b877313003c1c8467a7cb0b71',\r\n   data: [\r\n      { \"name\": \"new name\", \"type\": \"standard\" }\r\n   ]\r\n})"
  },
  "sys_updated_on": {
    "value": "2025-07-22 16:29:42",
    "display_value": "2025-07-22 09:29:42 AM"
  },
  "sys_tags": {
    "value": "",
    "display_value": ""
  },
  "sandbox_callable": {
    "value": "false",
    "display_value": "false"
  },
  "script": {
    "value": "var APIUtilsMS = Class.create();\r\nAPIUtilsMS.prototype = {\r\n    initialize: function() {\r\n        this.defaultFields = {\r\n            \"x_cadso_automate_content_template\": ['json_content']\r\n        };\r\n    },\r\n\r\n    get: function({\r\n        table,\r\n        sysID,\r\n        returnFields,\r\n        includeDisplay\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        // if(table.indexOf('x_cadso_') !== 0){\r\n        // \tthrow new Error('API is not configured to get records for ' + table);\r\n        // }\r\n        if (!sysID) {\r\n            throw new Error('Missing sys_id');\r\n        }\r\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\r\n        let recordGQ = new global.GlideQuery(table)\r\n            .get(sysID, returnFields)\r\n            .orElse(null);\r\n        return recordGQ;\r\n    },\r\n\r\n    delete: function({\r\n        table,\r\n        sysID\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to delete records for ' + table);\r\n        }\r\n        const recordGR = new GlideRecord(table);\r\n        if (!recordGR.get(sysID)) {\r\n            return false;\r\n        }\r\n        return recordGR.deleteRecord();\r\n    },\r\n\r\n    queryFirstOrLast({\r\n        table,\r\n        query,\r\n        returnFields,\r\n        orderBy,\r\n        order\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to get records for ' + table);\r\n        }\r\n        if (!orderBy) {\r\n            throw new Error('Must provide a field to order by');\r\n        }\r\n\r\n        order = order || 'orderBy';\r\n        returnFields = returnFields || this._getTableSchema(table);\r\n\r\n        const recordGQ = new global.GlideQuery.parse(table, query)[order](orderBy)\r\n            .selectOne(returnFields)\r\n        try {\r\n            return recordGQ.get()\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    query: function({\r\n        table,\r\n        query,\r\n        returnFields,\r\n        includeDisplay\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        // if(table.indexOf('x_cadso_') !== 0){\r\n        // \tthrow new Error('API is not configured to get records for ' + table);\r\n        // }\r\n        if (!query) {\r\n            throw new Error('Must provide a query');\r\n        }\r\n\r\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\r\n        let records = [];\r\n\r\n        let tableGQ = new global.GlideQuery.parse(table, query)\r\n            .select(returnFields)\r\n            .forEach(record => records.push(record));\r\n\r\n        return records;\r\n    },\r\n\r\n    insertOrUpdate: function({\r\n        table,\r\n        data\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to update records for ' + table);\r\n        }\r\n        if (!data.sys_id) {\r\n            throw new Error('Must provide sys_id');\r\n        }\r\n        if (!data || Object.getOwnPropertyNames(data).length === 0) {\r\n            throw new Error('Must include field values');\r\n        }\r\n\r\n        // let invalidFields = this._checkFields(table, updates);\r\n        // invalidFields.forEach(key => delete updates[key]);\r\n        data = this._checkFields(table, data);\r\n\r\n\r\n        let recordGQ = new global.GlideQuery(table)\r\n            .insertOrUpdate(data)\r\n            .get();\r\n\r\n        return recordGQ;\r\n    },\r\n\r\n    update: function({\r\n        table,\r\n        sysID,\r\n        updates\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to update records for ' + table);\r\n        }\r\n        if (!sysID) {\r\n            throw new Error('Must provide sys_id');\r\n        }\r\n        if (!updates || Object.getOwnPropertyNames(updates).length === 0) {\r\n            throw new Error('Must include field values');\r\n        }\r\n\r\n        // let invalidFields = this._checkFields(table, updates);\r\n        // invalidFields.forEach(key => delete updates[key]);\r\n        updates = this._checkFields(table, updates);\r\n\r\n        let recordGQ = new global.GlideQuery(table)\r\n            .where('sys_id', sysID)\r\n            .update(updates)\r\n            .get();\r\n\r\n        return recordGQ;\r\n    },\r\n\r\n    insert: function({\r\n        table,\r\n        data,\r\n        returnFields,\r\n        includeDisplay\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to create records for ' + table);\r\n        }\r\n        if (!data || Object.getOwnPropertyNames(data).length === 0) {\r\n            throw new Error('Must include field values');\r\n        }\r\n\r\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\r\n\r\n        // let invalidFields = this._checkFields(table, updates);\r\n        // invalidFields.forEach(key => delete updates[key]);\r\n        data = this._checkFields(table, data);\r\n\r\n        const recordGQ = new global.GlideQuery(table)\r\n            .insert(data)\r\n            .get(returnFields);\r\n        return recordGQ;\r\n    },\r\n\r\n    count: function({\r\n        table,\r\n        query,\r\n        groupBy,\r\n        distinctField\r\n    }) {\r\n        // if(table.indexOf('x_cadso') === -1){\r\n        // \tthrow new Error('API is not configured to get counts for ' + table);\r\n        // }\r\n        let recordGQ = new global.GlideQuery.parse(table, query);\r\n        if (groupBy && distinctField) {\r\n            var ga = new GlideAggregate(table);\r\n            ga.addEncodedQuery(query);\r\n            ga.groupBy(groupBy);\r\n            ga.addAggregate('COUNT(DISTINCT', distinctField);\r\n            ga.query();\r\n\r\n            var result = {};\r\n            while (ga.next()) {\r\n                result[ga.getValue(groupBy)] = ga.getAggregate('COUNT(DISTINCT', distinctField);\r\n            }\r\n            return result;\r\n        } else if (groupBy) {\r\n            let counts = {};\r\n            recordGQ\r\n                .groupBy(groupBy)\r\n                .aggregate('COUNT')\r\n                .select()\r\n                .forEach(result => counts[result.group[groupBy]] = result.count);\r\n            return counts;\r\n        } else {\r\n            return recordGQ.count();\r\n        }\r\n    },\r\n\r\n    getRequiredParameters(schemaID) {\r\n        const requiredParameters = [];\r\n        const propertyGQ = new global.GlideQuery('x_cadso_api_docs_schema_properties')\r\n            .where('parent_schema', schemaID)\r\n            .where('required', true)\r\n            .select('name')\r\n            .forEach(parameter >= requiredParameters.push(parameter));\r\n        return requiredParameters;\r\n    },\r\n\r\n    _getTableSchema: function(table, includeDisplay) {\r\n        const schema = global.Schema.of(table, ['*']);\r\n        let fields = Object.keys(schema[table]);\r\n        fields = fields.filter(field => !field.includes('sys_') || field == 'sys_id' || field == 'sys_class_name');\r\n\r\n        fields = includeDisplay ? fields.flatMap(field => [field, `${field}$DISPLAY`]) : fields;\r\n        return fields.sort();\r\n    },\r\n\r\n    // _checkFields(table, fields){\r\n    // \tlet updates = {};\r\n    // \tlet invalidFields = [];\r\n    // \tlet tableGR = new GlideRecord(table);\r\n    // \tfor(field in fields){\r\n    // \t\tif(!tableGR.isValidField(field)){\r\n    // \t\t\tinvalidFields.push(field);\r\n    // \t\t}\r\n    // \t}\r\n    // \treturn invalidFields;\r\n    // },\r\n\r\n    _checkFields(table, fields) {\r\n        let updates = {};\r\n        let invalidFields = [];\r\n        let tableGR = new GlideRecord(table);\r\n        for (field in fields) {\r\n            if (!tableGR.isValidField(field)) {\r\n                continue;\r\n            }\r\n            let fieldType = tableGR.getElement(field).getED().getInternalType();\r\n            if (fieldType === 'glide_date_time') {\r\n                let gdt = new GlideDateTime();\r\n                gdt.setDisplayValue(fields[field]);\r\n                updates[field] = gdt;\r\n            } else if (fieldType === 'glide_date') {\r\n                let gd = new GlideDate();\r\n                gd.setDisplayValue(fields[field]);\r\n                updates[field] = gd;\r\n            } else {\r\n                updates[field] = fields[field]\r\n            }\r\n        }\r\n        return updates;\r\n    },\r\n\r\n\r\n    duplicate: function({\r\n        table,\r\n        sysID,\r\n        data\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to dupplicate records for ' + table);\r\n        }\r\n        var sourceGR = new GlideRecord(table);\r\n        if (!sourceGR.get(sysID)) {\r\n            response.setStatus(404);\r\n            response.setBody({\r\n                error: \"Record not found\"\r\n            });\r\n            return;\r\n        }\r\n\r\n        // Create a new record in the same table\r\n        var grNew = new GlideRecord(table);\r\n        grNew.initialize();\r\n\r\n        var fields = Object.keys(sourceGR);\r\n\r\n        var skipFields = ['sys_id', 'sys_created_on', 'sys_updated_on', 'sys_created_by', 'sys_updated_by'];\r\n\r\n        fields.forEach(function(field) {\r\n            if (!skipFields.includes(field)) {\r\n                grNew.setValue(field, data && data[field] ? data[field] : sourceGR.getValue(field));\r\n            }\r\n        });\r\n\r\n        // Insert the new record and return\r\n        return grNew.insert();\r\n    },\r\n    type: 'APIUtilsMS'\r\n};",
    "display_value": "var APIUtilsMS = Class.create();\r\nAPIUtilsMS.prototype = {\r\n    initialize: function() {\r\n        this.defaultFields = {\r\n            \"x_cadso_automate_content_template\": ['json_content']\r\n        };\r\n    },\r\n\r\n    get: function({\r\n        table,\r\n        sysID,\r\n        returnFields,\r\n        includeDisplay\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        // if(table.indexOf('x_cadso_') !== 0){\r\n        // \tthrow new Error('API is not configured to get records for ' + table);\r\n        // }\r\n        if (!sysID) {\r\n            throw new Error('Missing sys_id');\r\n        }\r\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\r\n        let recordGQ = new global.GlideQuery(table)\r\n            .get(sysID, returnFields)\r\n            .orElse(null);\r\n        return recordGQ;\r\n    },\r\n\r\n    delete: function({\r\n        table,\r\n        sysID\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to delete records for ' + table);\r\n        }\r\n        const recordGR = new GlideRecord(table);\r\n        if (!recordGR.get(sysID)) {\r\n            return false;\r\n        }\r\n        return recordGR.deleteRecord();\r\n    },\r\n\r\n    queryFirstOrLast({\r\n        table,\r\n        query,\r\n        returnFields,\r\n        orderBy,\r\n        order\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to get records for ' + table);\r\n        }\r\n        if (!orderBy) {\r\n            throw new Error('Must provide a field to order by');\r\n        }\r\n\r\n        order = order || 'orderBy';\r\n        returnFields = returnFields || this._getTableSchema(table);\r\n\r\n        const recordGQ = new global.GlideQuery.parse(table, query)[order](orderBy)\r\n            .selectOne(returnFields)\r\n        try {\r\n            return recordGQ.get()\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    query: function({\r\n        table,\r\n        query,\r\n        returnFields,\r\n        includeDisplay\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        // if(table.indexOf('x_cadso_') !== 0){\r\n        // \tthrow new Error('API is not configured to get records for ' + table);\r\n        // }\r\n        if (!query) {\r\n            throw new Error('Must provide a query');\r\n        }\r\n\r\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\r\n        let records = [];\r\n\r\n        let tableGQ = new global.GlideQuery.parse(table, query)\r\n            .select(returnFields)\r\n            .forEach(record => records.push(record));\r\n\r\n        return records;\r\n    },\r\n\r\n    insertOrUpdate: function({\r\n        table,\r\n        data\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to update records for ' + table);\r\n        }\r\n        if (!data.sys_id) {\r\n            throw new Error('Must provide sys_id');\r\n        }\r\n        if (!data || Object.getOwnPropertyNames(data).length === 0) {\r\n            throw new Error('Must include field values');\r\n        }\r\n\r\n        // let invalidFields = this._checkFields(table, updates);\r\n        // invalidFields.forEach(key => delete updates[key]);\r\n        data = this._checkFields(table, data);\r\n\r\n\r\n        let recordGQ = new global.GlideQuery(table)\r\n            .insertOrUpdate(data)\r\n            .get();\r\n\r\n        return recordGQ;\r\n    },\r\n\r\n    update: function({\r\n        table,\r\n        sysID,\r\n        updates\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to update records for ' + table);\r\n        }\r\n        if (!sysID) {\r\n            throw new Error('Must provide sys_id');\r\n        }\r\n        if (!updates || Object.getOwnPropertyNames(updates).length === 0) {\r\n            throw new Error('Must include field values');\r\n        }\r\n\r\n        // let invalidFields = this._checkFields(table, updates);\r\n        // invalidFields.forEach(key => delete updates[key]);\r\n        updates = this._checkFields(table, updates);\r\n\r\n        let recordGQ = new global.GlideQuery(table)\r\n            .where('sys_id', sysID)\r\n            .update(updates)\r\n            .get();\r\n\r\n        return recordGQ;\r\n    },\r\n\r\n    insert: function({\r\n        table,\r\n        data,\r\n        returnFields,\r\n        includeDisplay\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to create records for ' + table);\r\n        }\r\n        if (!data || Object.getOwnPropertyNames(data).length === 0) {\r\n            throw new Error('Must include field values');\r\n        }\r\n\r\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\r\n\r\n        // let invalidFields = this._checkFields(table, updates);\r\n        // invalidFields.forEach(key => delete updates[key]);\r\n        data = this._checkFields(table, data);\r\n\r\n        const recordGQ = new global.GlideQuery(table)\r\n            .insert(data)\r\n            .get(returnFields);\r\n        return recordGQ;\r\n    },\r\n\r\n    count: function({\r\n        table,\r\n        query,\r\n        groupBy,\r\n        distinctField\r\n    }) {\r\n        // if(table.indexOf('x_cadso') === -1){\r\n        // \tthrow new Error('API is not configured to get counts for ' + table);\r\n        // }\r\n        let recordGQ = new global.GlideQuery.parse(table, query);\r\n        if (groupBy && distinctField) {\r\n            var ga = new GlideAggregate(table);\r\n            ga.addEncodedQuery(query);\r\n            ga.groupBy(groupBy);\r\n            ga.addAggregate('COUNT(DISTINCT', distinctField);\r\n            ga.query();\r\n\r\n            var result = {};\r\n            while (ga.next()) {\r\n                result[ga.getValue(groupBy)] = ga.getAggregate('COUNT(DISTINCT', distinctField);\r\n            }\r\n            return result;\r\n        } else if (groupBy) {\r\n            let counts = {};\r\n            recordGQ\r\n                .groupBy(groupBy)\r\n                .aggregate('COUNT')\r\n                .select()\r\n                .forEach(result => counts[result.group[groupBy]] = result.count);\r\n            return counts;\r\n        } else {\r\n            return recordGQ.count();\r\n        }\r\n    },\r\n\r\n    getRequiredParameters(schemaID) {\r\n        const requiredParameters = [];\r\n        const propertyGQ = new global.GlideQuery('x_cadso_api_docs_schema_properties')\r\n            .where('parent_schema', schemaID)\r\n            .where('required', true)\r\n            .select('name')\r\n            .forEach(parameter >= requiredParameters.push(parameter));\r\n        return requiredParameters;\r\n    },\r\n\r\n    _getTableSchema: function(table, includeDisplay) {\r\n        const schema = global.Schema.of(table, ['*']);\r\n        let fields = Object.keys(schema[table]);\r\n        fields = fields.filter(field => !field.includes('sys_') || field == 'sys_id' || field == 'sys_class_name');\r\n\r\n        fields = includeDisplay ? fields.flatMap(field => [field, `${field}$DISPLAY`]) : fields;\r\n        return fields.sort();\r\n    },\r\n\r\n    // _checkFields(table, fields){\r\n    // \tlet updates = {};\r\n    // \tlet invalidFields = [];\r\n    // \tlet tableGR = new GlideRecord(table);\r\n    // \tfor(field in fields){\r\n    // \t\tif(!tableGR.isValidField(field)){\r\n    // \t\t\tinvalidFields.push(field);\r\n    // \t\t}\r\n    // \t}\r\n    // \treturn invalidFields;\r\n    // },\r\n\r\n    _checkFields(table, fields) {\r\n        let updates = {};\r\n        let invalidFields = [];\r\n        let tableGR = new GlideRecord(table);\r\n        for (field in fields) {\r\n            if (!tableGR.isValidField(field)) {\r\n                continue;\r\n            }\r\n            let fieldType = tableGR.getElement(field).getED().getInternalType();\r\n            if (fieldType === 'glide_date_time') {\r\n                let gdt = new GlideDateTime();\r\n                gdt.setDisplayValue(fields[field]);\r\n                updates[field] = gdt;\r\n            } else if (fieldType === 'glide_date') {\r\n                let gd = new GlideDate();\r\n                gd.setDisplayValue(fields[field]);\r\n                updates[field] = gd;\r\n            } else {\r\n                updates[field] = fields[field]\r\n            }\r\n        }\r\n        return updates;\r\n    },\r\n\r\n\r\n    duplicate: function({\r\n        table,\r\n        sysID,\r\n        data\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to dupplicate records for ' + table);\r\n        }\r\n        var sourceGR = new GlideRecord(table);\r\n        if (!sourceGR.get(sysID)) {\r\n            response.setStatus(404);\r\n            response.setBody({\r\n                error: \"Record not found\"\r\n            });\r\n            return;\r\n        }\r\n\r\n        // Create a new record in the same table\r\n        var grNew = new GlideRecord(table);\r\n        grNew.initialize();\r\n\r\n        var fields = Object.keys(sourceGR);\r\n\r\n        var skipFields = ['sys_id', 'sys_created_on', 'sys_updated_on', 'sys_created_by', 'sys_updated_by'];\r\n\r\n        fields.forEach(function(field) {\r\n            if (!skipFields.includes(field)) {\r\n                grNew.setValue(field, data && data[field] ? data[field] : sourceGR.getValue(field));\r\n            }\r\n        });\r\n\r\n        // Insert the new record and return\r\n        return grNew.insert();\r\n    },\r\n    type: 'APIUtilsMS'\r\n};",
    "formatted_script": {
      "line_count": 319,
      "char_count": 9933,
      "preview": "var APIUtilsMS = Class.create();\r\nAPIUtilsMS.prototype = {\r\n    initialize: function() {\r\n        this.defaultFields = {\r\n            \"x_cadso_automate_content_template\": ['json_content']\r\n        };\r...",
      "full_script": "var APIUtilsMS = Class.create();\r\nAPIUtilsMS.prototype = {\r\n    initialize: function() {\r\n        this.defaultFields = {\r\n            \"x_cadso_automate_content_template\": ['json_content']\r\n        };\r\n    },\r\n\r\n    get: function({\r\n        table,\r\n        sysID,\r\n        returnFields,\r\n        includeDisplay\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        // if(table.indexOf('x_cadso_') !== 0){\r\n        // \tthrow new Error('API is not configured to get records for ' + table);\r\n        // }\r\n        if (!sysID) {\r\n            throw new Error('Missing sys_id');\r\n        }\r\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\r\n        let recordGQ = new global.GlideQuery(table)\r\n            .get(sysID, returnFields)\r\n            .orElse(null);\r\n        return recordGQ;\r\n    },\r\n\r\n    delete: function({\r\n        table,\r\n        sysID\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to delete records for ' + table);\r\n        }\r\n        const recordGR = new GlideRecord(table);\r\n        if (!recordGR.get(sysID)) {\r\n            return false;\r\n        }\r\n        return recordGR.deleteRecord();\r\n    },\r\n\r\n    queryFirstOrLast({\r\n        table,\r\n        query,\r\n        returnFields,\r\n        orderBy,\r\n        order\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to get records for ' + table);\r\n        }\r\n        if (!orderBy) {\r\n            throw new Error('Must provide a field to order by');\r\n        }\r\n\r\n        order = order || 'orderBy';\r\n        returnFields = returnFields || this._getTableSchema(table);\r\n\r\n        const recordGQ = new global.GlideQuery.parse(table, query)[order](orderBy)\r\n            .selectOne(returnFields)\r\n        try {\r\n            return recordGQ.get()\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    query: function({\r\n        table,\r\n        query,\r\n        returnFields,\r\n        includeDisplay\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        // if(table.indexOf('x_cadso_') !== 0){\r\n        // \tthrow new Error('API is not configured to get records for ' + table);\r\n        // }\r\n        if (!query) {\r\n            throw new Error('Must provide a query');\r\n        }\r\n\r\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\r\n        let records = [];\r\n\r\n        let tableGQ = new global.GlideQuery.parse(table, query)\r\n            .select(returnFields)\r\n            .forEach(record => records.push(record));\r\n\r\n        return records;\r\n    },\r\n\r\n    insertOrUpdate: function({\r\n        table,\r\n        data\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to update records for ' + table);\r\n        }\r\n        if (!data.sys_id) {\r\n            throw new Error('Must provide sys_id');\r\n        }\r\n        if (!data || Object.getOwnPropertyNames(data).length === 0) {\r\n            throw new Error('Must include field values');\r\n        }\r\n\r\n        // let invalidFields = this._checkFields(table, updates);\r\n        // invalidFields.forEach(key => delete updates[key]);\r\n        data = this._checkFields(table, data);\r\n\r\n\r\n        let recordGQ = new global.GlideQuery(table)\r\n            .insertOrUpdate(data)\r\n            .get();\r\n\r\n        return recordGQ;\r\n    },\r\n\r\n    update: function({\r\n        table,\r\n        sysID,\r\n        updates\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to update records for ' + table);\r\n        }\r\n        if (!sysID) {\r\n            throw new Error('Must provide sys_id');\r\n        }\r\n        if (!updates || Object.getOwnPropertyNames(updates).length === 0) {\r\n            throw new Error('Must include field values');\r\n        }\r\n\r\n        // let invalidFields = this._checkFields(table, updates);\r\n        // invalidFields.forEach(key => delete updates[key]);\r\n        updates = this._checkFields(table, updates);\r\n\r\n        let recordGQ = new global.GlideQuery(table)\r\n            .where('sys_id', sysID)\r\n            .update(updates)\r\n            .get();\r\n\r\n        return recordGQ;\r\n    },\r\n\r\n    insert: function({\r\n        table,\r\n        data,\r\n        returnFields,\r\n        includeDisplay\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to create records for ' + table);\r\n        }\r\n        if (!data || Object.getOwnPropertyNames(data).length === 0) {\r\n            throw new Error('Must include field values');\r\n        }\r\n\r\n        returnFields = returnFields || this._getTableSchema(table, includeDisplay);\r\n\r\n        // let invalidFields = this._checkFields(table, updates);\r\n        // invalidFields.forEach(key => delete updates[key]);\r\n        data = this._checkFields(table, data);\r\n\r\n        const recordGQ = new global.GlideQuery(table)\r\n            .insert(data)\r\n            .get(returnFields);\r\n        return recordGQ;\r\n    },\r\n\r\n    count: function({\r\n        table,\r\n        query,\r\n        groupBy,\r\n        distinctField\r\n    }) {\r\n        // if(table.indexOf('x_cadso') === -1){\r\n        // \tthrow new Error('API is not configured to get counts for ' + table);\r\n        // }\r\n        let recordGQ = new global.GlideQuery.parse(table, query);\r\n        if (groupBy && distinctField) {\r\n            var ga = new GlideAggregate(table);\r\n            ga.addEncodedQuery(query);\r\n            ga.groupBy(groupBy);\r\n            ga.addAggregate('COUNT(DISTINCT', distinctField);\r\n            ga.query();\r\n\r\n            var result = {};\r\n            while (ga.next()) {\r\n                result[ga.getValue(groupBy)] = ga.getAggregate('COUNT(DISTINCT', distinctField);\r\n            }\r\n            return result;\r\n        } else if (groupBy) {\r\n            let counts = {};\r\n            recordGQ\r\n                .groupBy(groupBy)\r\n                .aggregate('COUNT')\r\n                .select()\r\n                .forEach(result => counts[result.group[groupBy]] = result.count);\r\n            return counts;\r\n        } else {\r\n            return recordGQ.count();\r\n        }\r\n    },\r\n\r\n    getRequiredParameters(schemaID) {\r\n        const requiredParameters = [];\r\n        const propertyGQ = new global.GlideQuery('x_cadso_api_docs_schema_properties')\r\n            .where('parent_schema', schemaID)\r\n            .where('required', true)\r\n            .select('name')\r\n            .forEach(parameter >= requiredParameters.push(parameter));\r\n        return requiredParameters;\r\n    },\r\n\r\n    _getTableSchema: function(table, includeDisplay) {\r\n        const schema = global.Schema.of(table, ['*']);\r\n        let fields = Object.keys(schema[table]);\r\n        fields = fields.filter(field => !field.includes('sys_') || field == 'sys_id' || field == 'sys_class_name');\r\n\r\n        fields = includeDisplay ? fields.flatMap(field => [field, `${field}$DISPLAY`]) : fields;\r\n        return fields.sort();\r\n    },\r\n\r\n    // _checkFields(table, fields){\r\n    // \tlet updates = {};\r\n    // \tlet invalidFields = [];\r\n    // \tlet tableGR = new GlideRecord(table);\r\n    // \tfor(field in fields){\r\n    // \t\tif(!tableGR.isValidField(field)){\r\n    // \t\t\tinvalidFields.push(field);\r\n    // \t\t}\r\n    // \t}\r\n    // \treturn invalidFields;\r\n    // },\r\n\r\n    _checkFields(table, fields) {\r\n        let updates = {};\r\n        let invalidFields = [];\r\n        let tableGR = new GlideRecord(table);\r\n        for (field in fields) {\r\n            if (!tableGR.isValidField(field)) {\r\n                continue;\r\n            }\r\n            let fieldType = tableGR.getElement(field).getED().getInternalType();\r\n            if (fieldType === 'glide_date_time') {\r\n                let gdt = new GlideDateTime();\r\n                gdt.setDisplayValue(fields[field]);\r\n                updates[field] = gdt;\r\n            } else if (fieldType === 'glide_date') {\r\n                let gd = new GlideDate();\r\n                gd.setDisplayValue(fields[field]);\r\n                updates[field] = gd;\r\n            } else {\r\n                updates[field] = fields[field]\r\n            }\r\n        }\r\n        return updates;\r\n    },\r\n\r\n\r\n    duplicate: function({\r\n        table,\r\n        sysID,\r\n        data\r\n    }) {\r\n        if (!table) {\r\n            throw new Error('Must provide a table');\r\n        }\r\n        if (table.indexOf('x_cadso_') !== 0) {\r\n            throw new Error('API is not configured to dupplicate records for ' + table);\r\n        }\r\n        var sourceGR = new GlideRecord(table);\r\n        if (!sourceGR.get(sysID)) {\r\n            response.setStatus(404);\r\n            response.setBody({\r\n                error: \"Record not found\"\r\n            });\r\n            return;\r\n        }\r\n\r\n        // Create a new record in the same table\r\n        var grNew = new GlideRecord(table);\r\n        grNew.initialize();\r\n\r\n        var fields = Object.keys(sourceGR);\r\n\r\n        var skipFields = ['sys_id', 'sys_created_on', 'sys_updated_on', 'sys_created_by', 'sys_updated_by'];\r\n\r\n        fields.forEach(function(field) {\r\n            if (!skipFields.includes(field)) {\r\n                grNew.setValue(field, data && data[field] ? data[field] : sourceGR.getValue(field));\r\n            }\r\n        });\r\n\r\n        // Insert the new record and return\r\n        return grNew.insert();\r\n    },\r\n    type: 'APIUtilsMS'\r\n};"
    }
  },
  "sys_class_name": {
    "value": "sys_script_include",
    "display_value": "Script Include"
  },
  "sys_package": {
    "value": "5e9f5f8b87420250369f33373cbb3559",
    "display_value": "Tenon Marketing Automation"
  },
  "sys_update_name": {
    "value": "sys_script_include_e316635cc3aa425085b196c4e40131f3",
    "display_value": "sys_script_include_e316635cc3aa425085b196c4e40131f3"
  },
  "sys_updated_by": {
    "value": "admin",
    "display_value": "admin"
  },
  "api_name": {
    "value": "x_cadso_automate.APIUtilsMS",
    "display_value": "x_cadso_automate.APIUtilsMS"
  },
  "sys_created_on": {
    "value": "2024-05-29 23:05:15",
    "display_value": "2024-05-29 04:05:15 PM"
  },
  "caller_access": {
    "value": "",
    "display_value": null
  },
  "name": {
    "value": "APIUtilsMS",
    "display_value": "APIUtilsMS"
  },
  "sys_name": {
    "value": "APIUtilsMS",
    "display_value": "APIUtilsMS"
  },
  "sys_scope": {
    "value": "5e9f5f8b87420250369f33373cbb3559",
    "display_value": "Tenon Marketing Automation"
  },
  "sys_created_by": {
    "value": "rob.medved",
    "display_value": "rob.medved"
  },
  "sys_policy": {
    "value": "read",
    "display_value": "Read-only"
  }
}
