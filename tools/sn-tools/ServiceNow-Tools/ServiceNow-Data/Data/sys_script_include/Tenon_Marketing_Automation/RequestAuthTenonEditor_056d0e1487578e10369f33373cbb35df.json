{
  "_metadata": {
    "table": "sys_script_include",
    "sys_id": "056d0e1487578e10369f33373cbb35df",
    "extracted_at": "2025-09-19T21:48:29.448Z",
    "display_value": "RequestAuthTenonEditor",
    "application": "Tenon_Marketing_Automation",
    "scope": {
      "display_value": "Tenon Marketing Automation",
      "link": "https://tenonworkstudio.service-now.com/api/now/table/sys_scope/5e9f5f8b87420250369f33373cbb3559",
      "value": "5e9f5f8b87420250369f33373cbb3559"
    }
  },
  "client_callable": {
    "value": "false",
    "display_value": "false"
  },
  "access": {
    "value": "package_private",
    "display_value": "This application scope only"
  },
  "mobile_callable": {
    "value": "false",
    "display_value": "false"
  },
  "sys_mod_count": {
    "value": "0",
    "display_value": "0"
  },
  "active": {
    "value": "true",
    "display_value": "true"
  },
  "description": {
    "value": "",
    "display_value": ""
  },
  "sys_updated_on": {
    "value": "2024-07-05 22:50:32",
    "display_value": "2024-07-05 03:50:32 PM"
  },
  "sys_tags": {
    "value": "",
    "display_value": ""
  },
  "sandbox_callable": {
    "value": "false",
    "display_value": "false"
  },
  "script": {
    "value": "var RequestAuthTenonEditor = Class.create();\r\nRequestAuthTenonEditor.prototype = Object.extend(new RequestAuthInternal(), {\r\n    initialize: function() {\r\n        RequestAuthInternal.prototype.initialize.call(this);\r\n    },\r\n\r\n    generateAuth: function(authAPI) {\r\n        var requestData = authAPI.getHttpRequestData();\r\n        var endpoint = requestData.getEndpoint();\r\n        var method = requestData.getHttpMethod().toUpperCase();\r\n        var timeStampMillis = requestData.getDate();\r\n        if (timeStampMillis == 0) {\r\n            timeStampMillis = new GlideDateTime().getNumericValue();\r\n        }\r\n        // This value should be the number of seconds since the Unix epoch at the point the request is generated\r\n        // As the default timestamp returned from getDate is milliseconds trim it to seconds\r\n        var timeStamp = Math.round(timeStampMillis / 1000);\r\n\r\n        // get all query params\r\n        var queryParamMap = requestData.getQueryParamMap();\r\n        var opt_params = {};\r\n        var keys = this.getKeys(queryParamMap);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            opt_params[key] = queryParamMap[key];\r\n        }\r\n\r\n        // get payload\r\n        var payload = requestData.getContent();\r\n        if (!gs.nil(payload)) {\r\n            // the form url encoded string content needs to be parsed into json key value pairs to be used in\r\n            // signing\r\n            var contentType = authAPI.getHttpRequestData().getHeader(\"Content-Type\");\r\n            if (contentType == \"application/x-www-form-urlencoded\") {\r\n                var formEncodedPayload = payload.split(\"&\").reduce(function(prev, curr, i, arr) {\r\n                    var p = curr.split(\"=\");\r\n                    prev[decodeURIComponent(p[0])] = decodeURIComponent(p[1]);\r\n                    return prev;\r\n                }, {});\r\n            } else {\r\n                gs.debug(\"content type \" + contentType + \" not used in calculating signature\");\r\n            }\r\n        }\r\n\r\n        // get credentials\r\n        // all four fields are mandatory in the table\r\n        var credential = authAPI.getAuthCredential();\r\n        var consumer_secret = credential.getAttribute(\"consumer_secret\");\r\n        var consumer_key = credential.getAttribute(\"consumer_key\");\r\n        var access_token = credential.getAttribute(\"access_token\");\r\n        var access_token_secret = credential.getAttribute(\"access_token_secret\");\r\n\r\n        var httpRequestSignedData = new sn_auth.HttpRequestAuthedData();\r\n\r\n        if (gs.nil(consumer_secret) || gs.nil(consumer_key) || gs.nil(access_token) || gs.nil(access_token_secret)) {\r\n            httpRequestSignedData.setStatus(\"SKIPPED\");\r\n            httpRequestSignedData.setStatusMessage(\"Missing Required credentials\");\r\n            return httpRequestSignedData;\r\n        }\r\n\r\n        // create all required oauth params\r\n        var oauthParams = {\r\n            'oauth_consumer_key': consumer_key,\r\n            'oauth_timestamp': timeStamp,\r\n            // oauth_nonce is a unique token your application should generate for each unique request\r\n            // Twitter will use this value to determine whether a request has been submitted multiple times\r\n            // using timeStamp value with milliseconds as a unique token\r\n            'oauth_nonce': timeStampMillis,\r\n            'oauth_version': '1.0',\r\n            'oauth_token': access_token,\r\n            'oauth_signature_method': 'HMAC-SHA1'\r\n        };\r\n\r\n        var requestString = this.generateRequestString(oauthParams, opt_params, formEncodedPayload);\r\n        var signatureBaseString = this.generateSignatureBaseString(method, endpoint, requestString);\r\n        var signature = new GlideCertificateEncryption().generateMac(GlideStringUtil.base64Encode(this.getSigningKey(consumer_secret, access_token_secret)), \"HmacSHA1\", signatureBaseString);\r\n        oauthParams['oauth_signature'] = this.percentEncode(signature);\r\n\r\n        var authHeader = this.generateAuthorizationHeader(oauthParams);\r\n\r\n        // create HttpRequestAuthedData response\r\n        httpRequestSignedData.addHeader(\"authorization\", authHeader);\r\n        httpRequestSignedData.setStatus(\"SUCCESS\");\r\n        httpRequestSignedData.setDirective(\"HEADER\");\r\n        return httpRequestSignedData;\r\n    },\r\n\r\n    percentEncode: function(str) {\r\n        return encodeURIComponent(str)\r\n            .replace(/!/g, '%21')\r\n            .replace(/\\*/g, '%2A')\r\n            .replace(/\\(/g, '%28')\r\n            .replace(/\\)/g, '%29')\r\n            .replace(/'/g, '%27');\r\n    },\r\n\r\n    generateAuthorizationHeader: function(\r\n        oauthParams) {\r\n        var params = [];\r\n        var keys = this.getKeys(oauthParams);\r\n        keys.sort();\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            params.push(key + '=\"' + oauthParams[key] + '\"');\r\n        }\r\n        return 'OAuth ' + params.join(', ');\r\n    },\r\n\r\n    generateSignatureBaseString: function(\r\n        method, url, requestString) {\r\n        return [method, this.percentEncode(url), this.percentEncode(requestString)].join('&');\r\n    },\r\n\r\n    getSigningKey: function(consumer_secret, access_token_secret) {\r\n        return this.percentEncode(consumer_secret) + '&' +\r\n            this.percentEncode(access_token_secret);\r\n    },\r\n\r\n    generateRequestString: function(\r\n        oauthParams, opt_params, opt_formPayload) {\r\n        var requestParams = {};\r\n        var requestPath = [];\r\n        for (var i = 0; i < arguments.length; i++) {\r\n            var mapping = arguments[i];\r\n            if (mapping) {\r\n                var paramKeys = this.getKeys(mapping);\r\n                for (var j = 0; j < paramKeys.length; j++) {\r\n                    var paramKey = paramKeys[j];\r\n                    requestParams[paramKey] = mapping[paramKey];\r\n                }\r\n            }\r\n        }\r\n        var requestKeys = this.getKeys(requestParams);\r\n\r\n        var payloadKeys = [];\r\n        if (!gs.nil(opt_formPayload)) {\r\n            payloadKeys = this.getKeys(opt_formPayload);\r\n        }\r\n\r\n        requestKeys.sort();\r\n        for (var m = 0; m < requestKeys.length; m++) {\r\n            var requestKey = requestKeys[m];\r\n            if (payloadKeys.includes(requestKey)) {\r\n                // Skip percent encoding for form url encoded payload key/values as they will have to be\r\n                // percent encoded before using in rest step in flow designer. They can be encoded in a \r\n                // script step before REST step by using method like this.percentEncode\r\n                requestPath.push([requestKey, requestParams[requestKey]].join('='));\r\n            } else {\r\n                requestPath.push([\r\n                    this.percentEncode(requestKey), this.percentEncode(requestParams[requestKey])\r\n                ].join('='));\r\n            }\r\n        }\r\n        return requestPath.join('&');\r\n    },\r\n\r\n    // get keys from an object\r\n    getKeys: function(object1) {\r\n        return Object.keys(object1);\r\n    },\r\n    type: 'RequestAuthTenonEditor'\r\n});",
    "display_value": "var RequestAuthTenonEditor = Class.create();\r\nRequestAuthTenonEditor.prototype = Object.extend(new RequestAuthInternal(), {\r\n    initialize: function() {\r\n        RequestAuthInternal.prototype.initialize.call(this);\r\n    },\r\n\r\n    generateAuth: function(authAPI) {\r\n        var requestData = authAPI.getHttpRequestData();\r\n        var endpoint = requestData.getEndpoint();\r\n        var method = requestData.getHttpMethod().toUpperCase();\r\n        var timeStampMillis = requestData.getDate();\r\n        if (timeStampMillis == 0) {\r\n            timeStampMillis = new GlideDateTime().getNumericValue();\r\n        }\r\n        // This value should be the number of seconds since the Unix epoch at the point the request is generated\r\n        // As the default timestamp returned from getDate is milliseconds trim it to seconds\r\n        var timeStamp = Math.round(timeStampMillis / 1000);\r\n\r\n        // get all query params\r\n        var queryParamMap = requestData.getQueryParamMap();\r\n        var opt_params = {};\r\n        var keys = this.getKeys(queryParamMap);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            opt_params[key] = queryParamMap[key];\r\n        }\r\n\r\n        // get payload\r\n        var payload = requestData.getContent();\r\n        if (!gs.nil(payload)) {\r\n            // the form url encoded string content needs to be parsed into json key value pairs to be used in\r\n            // signing\r\n            var contentType = authAPI.getHttpRequestData().getHeader(\"Content-Type\");\r\n            if (contentType == \"application/x-www-form-urlencoded\") {\r\n                var formEncodedPayload = payload.split(\"&\").reduce(function(prev, curr, i, arr) {\r\n                    var p = curr.split(\"=\");\r\n                    prev[decodeURIComponent(p[0])] = decodeURIComponent(p[1]);\r\n                    return prev;\r\n                }, {});\r\n            } else {\r\n                gs.debug(\"content type \" + contentType + \" not used in calculating signature\");\r\n            }\r\n        }\r\n\r\n        // get credentials\r\n        // all four fields are mandatory in the table\r\n        var credential = authAPI.getAuthCredential();\r\n        var consumer_secret = credential.getAttribute(\"consumer_secret\");\r\n        var consumer_key = credential.getAttribute(\"consumer_key\");\r\n        var access_token = credential.getAttribute(\"access_token\");\r\n        var access_token_secret = credential.getAttribute(\"access_token_secret\");\r\n\r\n        var httpRequestSignedData = new sn_auth.HttpRequestAuthedData();\r\n\r\n        if (gs.nil(consumer_secret) || gs.nil(consumer_key) || gs.nil(access_token) || gs.nil(access_token_secret)) {\r\n            httpRequestSignedData.setStatus(\"SKIPPED\");\r\n            httpRequestSignedData.setStatusMessage(\"Missing Required credentials\");\r\n            return httpRequestSignedData;\r\n        }\r\n\r\n        // create all required oauth params\r\n        var oauthParams = {\r\n            'oauth_consumer_key': consumer_key,\r\n            'oauth_timestamp': timeStamp,\r\n            // oauth_nonce is a unique token your application should generate for each unique request\r\n            // Twitter will use this value to determine whether a request has been submitted multiple times\r\n            // using timeStamp value with milliseconds as a unique token\r\n            'oauth_nonce': timeStampMillis,\r\n            'oauth_version': '1.0',\r\n            'oauth_token': access_token,\r\n            'oauth_signature_method': 'HMAC-SHA1'\r\n        };\r\n\r\n        var requestString = this.generateRequestString(oauthParams, opt_params, formEncodedPayload);\r\n        var signatureBaseString = this.generateSignatureBaseString(method, endpoint, requestString);\r\n        var signature = new GlideCertificateEncryption().generateMac(GlideStringUtil.base64Encode(this.getSigningKey(consumer_secret, access_token_secret)), \"HmacSHA1\", signatureBaseString);\r\n        oauthParams['oauth_signature'] = this.percentEncode(signature);\r\n\r\n        var authHeader = this.generateAuthorizationHeader(oauthParams);\r\n\r\n        // create HttpRequestAuthedData response\r\n        httpRequestSignedData.addHeader(\"authorization\", authHeader);\r\n        httpRequestSignedData.setStatus(\"SUCCESS\");\r\n        httpRequestSignedData.setDirective(\"HEADER\");\r\n        return httpRequestSignedData;\r\n    },\r\n\r\n    percentEncode: function(str) {\r\n        return encodeURIComponent(str)\r\n            .replace(/!/g, '%21')\r\n            .replace(/\\*/g, '%2A')\r\n            .replace(/\\(/g, '%28')\r\n            .replace(/\\)/g, '%29')\r\n            .replace(/'/g, '%27');\r\n    },\r\n\r\n    generateAuthorizationHeader: function(\r\n        oauthParams) {\r\n        var params = [];\r\n        var keys = this.getKeys(oauthParams);\r\n        keys.sort();\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            params.push(key + '=\"' + oauthParams[key] + '\"');\r\n        }\r\n        return 'OAuth ' + params.join(', ');\r\n    },\r\n\r\n    generateSignatureBaseString: function(\r\n        method, url, requestString) {\r\n        return [method, this.percentEncode(url), this.percentEncode(requestString)].join('&');\r\n    },\r\n\r\n    getSigningKey: function(consumer_secret, access_token_secret) {\r\n        return this.percentEncode(consumer_secret) + '&' +\r\n            this.percentEncode(access_token_secret);\r\n    },\r\n\r\n    generateRequestString: function(\r\n        oauthParams, opt_params, opt_formPayload) {\r\n        var requestParams = {};\r\n        var requestPath = [];\r\n        for (var i = 0; i < arguments.length; i++) {\r\n            var mapping = arguments[i];\r\n            if (mapping) {\r\n                var paramKeys = this.getKeys(mapping);\r\n                for (var j = 0; j < paramKeys.length; j++) {\r\n                    var paramKey = paramKeys[j];\r\n                    requestParams[paramKey] = mapping[paramKey];\r\n                }\r\n            }\r\n        }\r\n        var requestKeys = this.getKeys(requestParams);\r\n\r\n        var payloadKeys = [];\r\n        if (!gs.nil(opt_formPayload)) {\r\n            payloadKeys = this.getKeys(opt_formPayload);\r\n        }\r\n\r\n        requestKeys.sort();\r\n        for (var m = 0; m < requestKeys.length; m++) {\r\n            var requestKey = requestKeys[m];\r\n            if (payloadKeys.includes(requestKey)) {\r\n                // Skip percent encoding for form url encoded payload key/values as they will have to be\r\n                // percent encoded before using in rest step in flow designer. They can be encoded in a \r\n                // script step before REST step by using method like this.percentEncode\r\n                requestPath.push([requestKey, requestParams[requestKey]].join('='));\r\n            } else {\r\n                requestPath.push([\r\n                    this.percentEncode(requestKey), this.percentEncode(requestParams[requestKey])\r\n                ].join('='));\r\n            }\r\n        }\r\n        return requestPath.join('&');\r\n    },\r\n\r\n    // get keys from an object\r\n    getKeys: function(object1) {\r\n        return Object.keys(object1);\r\n    },\r\n    type: 'RequestAuthTenonEditor'\r\n});",
    "formatted_script": {
      "line_count": 162,
      "char_count": 7088,
      "preview": "var RequestAuthTenonEditor = Class.create();\r\nRequestAuthTenonEditor.prototype = Object.extend(new RequestAuthInternal(), {\r\n    initialize: function() {\r\n        RequestAuthInternal.prototype.initial...",
      "full_script": "var RequestAuthTenonEditor = Class.create();\r\nRequestAuthTenonEditor.prototype = Object.extend(new RequestAuthInternal(), {\r\n    initialize: function() {\r\n        RequestAuthInternal.prototype.initialize.call(this);\r\n    },\r\n\r\n    generateAuth: function(authAPI) {\r\n        var requestData = authAPI.getHttpRequestData();\r\n        var endpoint = requestData.getEndpoint();\r\n        var method = requestData.getHttpMethod().toUpperCase();\r\n        var timeStampMillis = requestData.getDate();\r\n        if (timeStampMillis == 0) {\r\n            timeStampMillis = new GlideDateTime().getNumericValue();\r\n        }\r\n        // This value should be the number of seconds since the Unix epoch at the point the request is generated\r\n        // As the default timestamp returned from getDate is milliseconds trim it to seconds\r\n        var timeStamp = Math.round(timeStampMillis / 1000);\r\n\r\n        // get all query params\r\n        var queryParamMap = requestData.getQueryParamMap();\r\n        var opt_params = {};\r\n        var keys = this.getKeys(queryParamMap);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            opt_params[key] = queryParamMap[key];\r\n        }\r\n\r\n        // get payload\r\n        var payload = requestData.getContent();\r\n        if (!gs.nil(payload)) {\r\n            // the form url encoded string content needs to be parsed into json key value pairs to be used in\r\n            // signing\r\n            var contentType = authAPI.getHttpRequestData().getHeader(\"Content-Type\");\r\n            if (contentType == \"application/x-www-form-urlencoded\") {\r\n                var formEncodedPayload = payload.split(\"&\").reduce(function(prev, curr, i, arr) {\r\n                    var p = curr.split(\"=\");\r\n                    prev[decodeURIComponent(p[0])] = decodeURIComponent(p[1]);\r\n                    return prev;\r\n                }, {});\r\n            } else {\r\n                gs.debug(\"content type \" + contentType + \" not used in calculating signature\");\r\n            }\r\n        }\r\n\r\n        // get credentials\r\n        // all four fields are mandatory in the table\r\n        var credential = authAPI.getAuthCredential();\r\n        var consumer_secret = credential.getAttribute(\"consumer_secret\");\r\n        var consumer_key = credential.getAttribute(\"consumer_key\");\r\n        var access_token = credential.getAttribute(\"access_token\");\r\n        var access_token_secret = credential.getAttribute(\"access_token_secret\");\r\n\r\n        var httpRequestSignedData = new sn_auth.HttpRequestAuthedData();\r\n\r\n        if (gs.nil(consumer_secret) || gs.nil(consumer_key) || gs.nil(access_token) || gs.nil(access_token_secret)) {\r\n            httpRequestSignedData.setStatus(\"SKIPPED\");\r\n            httpRequestSignedData.setStatusMessage(\"Missing Required credentials\");\r\n            return httpRequestSignedData;\r\n        }\r\n\r\n        // create all required oauth params\r\n        var oauthParams = {\r\n            'oauth_consumer_key': consumer_key,\r\n            'oauth_timestamp': timeStamp,\r\n            // oauth_nonce is a unique token your application should generate for each unique request\r\n            // Twitter will use this value to determine whether a request has been submitted multiple times\r\n            // using timeStamp value with milliseconds as a unique token\r\n            'oauth_nonce': timeStampMillis,\r\n            'oauth_version': '1.0',\r\n            'oauth_token': access_token,\r\n            'oauth_signature_method': 'HMAC-SHA1'\r\n        };\r\n\r\n        var requestString = this.generateRequestString(oauthParams, opt_params, formEncodedPayload);\r\n        var signatureBaseString = this.generateSignatureBaseString(method, endpoint, requestString);\r\n        var signature = new GlideCertificateEncryption().generateMac(GlideStringUtil.base64Encode(this.getSigningKey(consumer_secret, access_token_secret)), \"HmacSHA1\", signatureBaseString);\r\n        oauthParams['oauth_signature'] = this.percentEncode(signature);\r\n\r\n        var authHeader = this.generateAuthorizationHeader(oauthParams);\r\n\r\n        // create HttpRequestAuthedData response\r\n        httpRequestSignedData.addHeader(\"authorization\", authHeader);\r\n        httpRequestSignedData.setStatus(\"SUCCESS\");\r\n        httpRequestSignedData.setDirective(\"HEADER\");\r\n        return httpRequestSignedData;\r\n    },\r\n\r\n    percentEncode: function(str) {\r\n        return encodeURIComponent(str)\r\n            .replace(/!/g, '%21')\r\n            .replace(/\\*/g, '%2A')\r\n            .replace(/\\(/g, '%28')\r\n            .replace(/\\)/g, '%29')\r\n            .replace(/'/g, '%27');\r\n    },\r\n\r\n    generateAuthorizationHeader: function(\r\n        oauthParams) {\r\n        var params = [];\r\n        var keys = this.getKeys(oauthParams);\r\n        keys.sort();\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            params.push(key + '=\"' + oauthParams[key] + '\"');\r\n        }\r\n        return 'OAuth ' + params.join(', ');\r\n    },\r\n\r\n    generateSignatureBaseString: function(\r\n        method, url, requestString) {\r\n        return [method, this.percentEncode(url), this.percentEncode(requestString)].join('&');\r\n    },\r\n\r\n    getSigningKey: function(consumer_secret, access_token_secret) {\r\n        return this.percentEncode(consumer_secret) + '&' +\r\n            this.percentEncode(access_token_secret);\r\n    },\r\n\r\n    generateRequestString: function(\r\n        oauthParams, opt_params, opt_formPayload) {\r\n        var requestParams = {};\r\n        var requestPath = [];\r\n        for (var i = 0; i < arguments.length; i++) {\r\n            var mapping = arguments[i];\r\n            if (mapping) {\r\n                var paramKeys = this.getKeys(mapping);\r\n                for (var j = 0; j < paramKeys.length; j++) {\r\n                    var paramKey = paramKeys[j];\r\n                    requestParams[paramKey] = mapping[paramKey];\r\n                }\r\n            }\r\n        }\r\n        var requestKeys = this.getKeys(requestParams);\r\n\r\n        var payloadKeys = [];\r\n        if (!gs.nil(opt_formPayload)) {\r\n            payloadKeys = this.getKeys(opt_formPayload);\r\n        }\r\n\r\n        requestKeys.sort();\r\n        for (var m = 0; m < requestKeys.length; m++) {\r\n            var requestKey = requestKeys[m];\r\n            if (payloadKeys.includes(requestKey)) {\r\n                // Skip percent encoding for form url encoded payload key/values as they will have to be\r\n                // percent encoded before using in rest step in flow designer. They can be encoded in a \r\n                // script step before REST step by using method like this.percentEncode\r\n                requestPath.push([requestKey, requestParams[requestKey]].join('='));\r\n            } else {\r\n                requestPath.push([\r\n                    this.percentEncode(requestKey), this.percentEncode(requestParams[requestKey])\r\n                ].join('='));\r\n            }\r\n        }\r\n        return requestPath.join('&');\r\n    },\r\n\r\n    // get keys from an object\r\n    getKeys: function(object1) {\r\n        return Object.keys(object1);\r\n    },\r\n    type: 'RequestAuthTenonEditor'\r\n});"
    }
  },
  "sys_class_name": {
    "value": "sys_script_include",
    "display_value": "Script Include"
  },
  "sys_package": {
    "value": "5e9f5f8b87420250369f33373cbb3559",
    "display_value": "Tenon Marketing Automation"
  },
  "sys_update_name": {
    "value": "sys_script_include_056d0e1487578e10369f33373cbb35df",
    "display_value": "sys_script_include_056d0e1487578e10369f33373cbb35df"
  },
  "sys_updated_by": {
    "value": "nathan.long",
    "display_value": "nathan.long"
  },
  "api_name": {
    "value": "x_cadso_automate.RequestAuthTenonEditor",
    "display_value": "x_cadso_automate.RequestAuthTenonEditor"
  },
  "sys_created_on": {
    "value": "2024-07-05 22:50:32",
    "display_value": "2024-07-05 03:50:32 PM"
  },
  "caller_access": {
    "value": "",
    "display_value": null
  },
  "name": {
    "value": "RequestAuthTenonEditor",
    "display_value": "RequestAuthTenonEditor"
  },
  "sys_name": {
    "value": "RequestAuthTenonEditor",
    "display_value": "RequestAuthTenonEditor"
  },
  "sys_scope": {
    "value": "5e9f5f8b87420250369f33373cbb3559",
    "display_value": "Tenon Marketing Automation"
  },
  "sys_created_by": {
    "value": "nathan.long",
    "display_value": "nathan.long"
  },
  "sys_policy": {
    "value": "read",
    "display_value": "Read-only"
  }
}
