{
  "_metadata": {
    "table": "sys_script_include",
    "sys_id": "d26204a7871ba510b656fe66cebb3506",
    "extracted_at": "2025-09-19T21:48:31.551Z",
    "display_value": "workMainUtilsMS",
    "application": "Tenon_Marketing_Work_Management",
    "scope": {
      "display_value": "Tenon Marketing Work Management",
      "link": "https://tenonworkstudio.service-now.com/api/now/table/sys_scope/4e4449a5475c255085d19fd8036d43a0",
      "value": "4e4449a5475c255085d19fd8036d43a0"
    }
  },
  "client_callable": {
    "value": "false",
    "display_value": "false"
  },
  "access": {
    "value": "public",
    "display_value": "All application scopes"
  },
  "mobile_callable": {
    "value": "false",
    "display_value": "false"
  },
  "sys_mod_count": {
    "value": "141",
    "display_value": "141"
  },
  "active": {
    "value": "true",
    "display_value": "true"
  },
  "description": {
    "value": "",
    "display_value": ""
  },
  "sys_updated_on": {
    "value": "2024-10-11 02:45:55",
    "display_value": "2024-10-10 07:45:55 PM"
  },
  "sys_tags": {
    "value": "",
    "display_value": ""
  },
  "sandbox_callable": {
    "value": "false",
    "display_value": "false"
  },
  "script": {
    "value": "/* eslint-disable max-lines */\nconst workMainUtilsMS = Class.create();\nworkMainUtilsMS.prototype = {\n\tinitialize: function () {\n\t\tthis.refRecordObj = {};\n\t\tthis.months = [\n\t\t\t\"\",\n\t\t\t\"January\",\n\t\t\t\"February\",\n\t\t\t\"March\",\n\t\t\t\"April\",\n\t\t\t\"May\",\n\t\t\t\"June\",\n\t\t\t\"July\",\n\t\t\t\"August\",\n\t\t\t\"September\",\n\t\t\t\"October\",\n\t\t\t\"November\",\n\t\t\t\"December\",\n\t\t];\n\t\tthis.monthsAbr = [\n\t\t\t\"\",\n\t\t\t\"Jan\",\n\t\t\t\"Feb\",\n\t\t\t\"Mar\",\n\t\t\t\"Apr\",\n\t\t\t\"May\",\n\t\t\t\"Jun\",\n\t\t\t\"Jul\",\n\t\t\t\"Aug\",\n\t\t\t\"Sept\",\n\t\t\t\"Oct\",\n\t\t\t\"Nov\",\n\t\t\t\"Dec\",\n\t\t];\n\t\tthis.index = {};\n\t},\n\n\tfindTemplate: function(type) {\n\t\tvar ans = {found: false, template: {}};\n\t\tvar projTempGr = new GlideRecord('x_cadso_work_project_template');\n\t\tprojTempGr.addQuery('type', type);\n\t\tprojTempGr.setLimit(1);\n\t\tprojTempGr.query();\n\n\t\twhile (projTempGr.next()) {\n\t\t\tvar calcDates = (projTempGr.getValue('calculate_dates') + '');\n\t\t\tans.found = true;\n\t\t\tans.template = {\n\t\t\t\tgr: projTempGr,\n\t\t\t\tsysId: projTempGr.getUniqueValue(),\n\t\t\t\tcalcType: calcDates\n\t\t\t};\n\t\t}\n\n\t\treturn ans;\n\t},\n\n\tconvertSprintDates: function ({ fieldsObj }) {\n\t\tconst fieldsToConvert = \"expected_start,expected_end,actual_start,actual_end,due_date\";\n\t\tfieldsToConvert.split(\",\").forEach(function (field) {\n\t\t\tif (fieldsObj[field] && fieldsObj[field].value) {\n\t\t\t\tfieldsObj[field].displayValue = this.getDateDisplay({ date: fieldsObj[field].value });\n\t\t\t}\n\t\t}, this);\n\t},\n\n\tgetDateDisplay: function ({ date }) {\n\t\tconst dt = new GlideDateTime(date);\n\t\tconst month = dt.getMonthLocalTime();\n\t\tconst day = dt.getDayOfMonthLocalTime();\n\t\treturn `${this.months[month]} ${day}`;\n\t},\n\n\tgetRecords: function ({\n\t\ttype,\n\t\ttable,\n\t\tqueries,\n\t\tfields,\n\t\tsortBys,\n\t\tsortAsc,\n\t\tsortByDisplayField,\n\t\tsortAscDisplayField,\n\t\tgetItems,\n\t\titemObj,\n\t\tparentField,\n\t\tparentFieldValue,\n\t\tparentQuery,\n\t\tparentFieldQuery,\n\t\taddParentQuery,\n\t\tshow,\n\t}) {\n\t\tconst typeTable = type + table;\n\t\tconst records = [];\n\t\tlet parentQueries = addParentQuery && parentQuery && parentQuery.length ? parentQuery : [];\n\t\tlet isSprintTable = false;\n\t\tlet isProjectTable = false;\n\t\tlet isTaskTable = false;\n\t\tif (table === \"x_cadso_work_sprint\") {\n\t\t\tisSprintTable = true;\n\t\t} else if (table === \"x_cadso_work_project\") {\n\t\t\tisProjectTable = true;\n\t\t} else if (table === \"x_cadso_work_task\") {\n\t\t\tisTaskTable = true;\n\t\t}\n\n\t\tconst tableGr = new GlideRecord(table);\n\n\t\tif (queries && queries.length) {\n\t\t\tqueries.forEach((query) => {\n\t\t\t\ttableGr.addEncodedQuery(query);\n\t\t\t});\n\t\t}\n\n\t\tif (parentField && parentFieldValue) {\n\t\t\tconst querySymbol = parentFieldQuery || \"=\";\n\t\t\tparentQueries.push(`${parentField}${querySymbol}${parentFieldValue}`);\n\t\t}\n\n\t\tif (parentQueries && parentQueries.length) {\n\t\t\tif (isTaskTable) {\n\t\t\t\tparentQueries = parentQueries.map((query) => query.replace(\"sprintsLIKE\", \"sprint=\"));\n\t\t\t}\n\t\t\tparentQueries.forEach((query) => {\n\t\t\t\ttableGr.addEncodedQuery(query);\n\t\t\t});\n\t\t}\n\n\t\tconst direction = sortAsc ? \"orderBy\" : \"orderByDesc\";\n\t\tconst displayFieldSortDirection = sortAscDisplayField ? \"orderBy\" : \"orderByDesc\";\n\t\tconst displayField = tableGr.getDisplayName();\n\n\t\tthis.setOrderBy({ tableGr, sortBys, direction });\n\n\t\tif (sortByDisplayField && displayField) {\n\t\t\tthis.setOrderBy({ tableGr, sortBys: [displayField], direction: displayFieldSortDirection });\n\t\t}\n\n\t\ttableGr.query();\n\n\t\tthis.index[typeTable] = 0;\n\t\twhile (tableGr.next()) {\n\t\t\tconst completed = \"40,50,60,70\".indexOf(tableGr.getValue(\"state\")) > -1;\n\t\t\tconst sysId = tableGr.getUniqueValue();\n\t\t\tconst fieldsObj = this.getFields({ fields, tableGr, isSprintTable });\n\t\t\tconst record = {\n\t\t\t\t...fieldsObj,\n\t\t\t\tdisplayValue: tableGr.getDisplayValue(),\n\t\t\t\tvalue: sysId,\n\t\t\t\tsysId,\n\t\t\t\tsys_id: sysId,\n\t\t\t\tcompleted,\n\t\t\t};\n\n\t\t\tif (isProjectTable) {\n\t\t\t\trecord.index = this.getProjectIndex({\n\t\t\t\t\tproject: sysId,\n\t\t\t\t\tsprint: type === \"backlog\" ? false : parentFieldValue,\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\tif (isProjectTable || isTaskTable) {\n\t\t\t\tconst field = isProjectTable ? 'expected_end' : 'due_date';\n\t\t\t\tif (tableGr.getValue(field)) {\n\t\t\t\t\tconst gdt = new GlideDateTime();\n\t\t\t\t\tgdt.setValue(tableGr.getValue(field));\n\t\t\t\t\tconst month = parseInt(gdt.getMonthLocalTime());\n\t\t\t\t\trecord.dueDate = `${this.monthsAbr[month]} ${gdt.getDayOfMonthLocalTime()}`;\n\t\t\t\t} else {\n\t\t\t\t\trecord.dueDate = '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getItems) {\n\t\t\t\tconst itemsRecords = this.getRecords({\n\t\t\t\t\t...itemObj,\n\t\t\t\t\tparentFieldValue: tableGr.getUniqueValue(),\n\t\t\t\t\tparentQuery:\n\t\t\t\t\titemObj.addParentQuery && parentQueries && parentQueries.length\n\t\t\t\t\t? [...parentQueries]\n\t\t\t\t\t: [],\n\t\t\t\t});\n\n\t\t\t\tif (isProjectTable) {\n\t\t\t\t\tconst sprint = type === \"backlog\" ? false : parentFieldValue;\n\t\t\t\t\trecord.index = this.getProjectIndex({ project: sysId, sprint });\n\t\t\t\t}\n\t\t\t\trecord.items = itemsRecords;\n\t\t\t}\n\n\t\t\trecords.push(record);\n\t\t}\n\n\t\tif (isProjectTable) {\n\t\t\trecords.sort((a, b) => {\n\t\t\t\treturn (\n\t\t\t\t\ta.index.value.localeCompare(b.index.value) || a.displayValue.localeCompare(b.displayValue)\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\treturn records;\n\t},\n\n\tgetFields: function ({ fields, tableGr, isSprintTable }) {\n\t\tconst fieldsObj = {};\n\n\t\tif (fields && fields.length) {\n\t\t\tfields.forEach((field) => {\n\t\t\t\tfieldsObj[field] = this.getField({ tableGr, field }) || { displayValue: \"\", value: \"\" };\n\t\t\t});\n\n\t\t\tif (isSprintTable) {\n\t\t\t\tthis.convertSprintDates({ fieldsObj });\n\t\t\t}\n\n\t\t\tif (fields.includes(\"assigned_to\") && fieldsObj.assigned_to && fieldsObj.assigned_to.value) {\n\t\t\t\tthis.getRefValue({\n\t\t\t\t\ttableGr,\n\t\t\t\t\tfield: \"assigned_to\",\n\t\t\t\t\tvalue: fieldsObj.assigned_to.value,\n\t\t\t\t\tfieldName: \"photo\",\n\t\t\t\t\tkeyName: \"avatar\",\n\t\t\t\t\trecord: fieldsObj,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn fieldsObj;\n\t},\n\n\tgetField: function ({ tableGr, field }) {\n\t\treturn {\n\t\t\tdisplayValue: tableGr.getDisplayValue(field) || \"\",\n\t\t\tvalue: tableGr.getValue(field) || \"\",\n\t\t};\n\t},\n\n\tgetRefValue: function ({ tableGr, field, value, fieldName, keyName, record }) {\n\t\tif (!this.refRecordObj[value] && value) {\n\t\t\tconst refRecordGr = tableGr[field].getRefRecord();\n\t\t\tif (refRecordGr.isValidRecord()) {\n\t\t\t\tthis.refRecordObj[value] = {\n\t\t\t\t\tdisplayValue: refRecordGr.getDisplayValue(fieldName),\n\t\t\t\t\tvalue: refRecordGr.getValue(fieldName),\n\t\t\t\t};\n\n\t\t\t\tif (keyName === 'avatar') {\n\t\t\t\t\tlet avatar = refRecordGr.getValue('avatar');\n\t\t\t\t\tavatar = avatar == null ? '' : avatar;\n\t\t\t\t\tlet photo = refRecordGr.getValue('photo');\n\t\t\t\t\tphoto = photo == null ? '' : photo;\n\t\t\t\t\tconst userAvatar = avatar || photo;\n\t\t\t\t\tthis.refRecordObj[value] = {\n\t\t\t\t\t\tdisplayValue: userAvatar ? userAvatar + '.iix' : '',\n\t\t\t\t\t\tvalue: userAvatar,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trecord[field][keyName] = this.refRecordObj[value] || { displayValue: \"\", value: \"\" };\n\t},\n\n\tsetOrderBy: function ({ tableGr, sortBys, direction }) {\n\t\tif (sortBys && sortBys.length) {\n\t\t\tsortBys.map((sortBy) => tableGr[direction](sortBy));\n\t\t}\n\t},\n\n\tgetProjectIndex: function ({ project, sprint }) {\n\t\tconst workSprintProjectM2MGr = new GlideRecord(\"x_cadso_work_sprint_project_m2m\");\n\t\tworkSprintProjectM2MGr.addQuery(\"project\", project);\n\n\t\tif (sprint) {\n\t\t\tworkSprintProjectM2MGr.addQuery(\"sprint\", sprint);\n\t\t} else {\n\t\t\tworkSprintProjectM2MGr.addEncodedQuery(\"sprintISEMPTY\");\n\t\t}\n\n\t\tworkSprintProjectM2MGr.query();\n\n\t\tif (workSprintProjectM2MGr.next()) {\n\t\t\treturn {\n\t\t\t\tdisplayValue: workSprintProjectM2MGr.getDisplayValue(\"index\"),\n\t\t\t\tvalue: workSprintProjectM2MGr.getValue(\"index\"),\n\t\t\t};\n\t\t}\n\n\t\treturn { displayValue: \"\", value: \"\" };\n\t},\n\n\tgetColumns: function (configGr) {\n\t\tconst table = configGr.getValue(\"table\");\n\t\tconst element = configGr.getValue(\"group_by\");\n\t\tconst tableGr = new GlideRecord(table);\n\t\tconst elementGE = tableGr.getElement(element);\n\t\tconst elementED = elementGE.getED();\n\t\tconst type = elementED.getInternalType();\n\t\tconst choices = elementGE.getChoices();\n\n\t\tif (type === \"reference\") {\n\t\t\tconst refTable = elementGE.getReferenceTable();\n\t\t\treturn this.getReferenceColumns({ table: refTable });\n\t\t} else if (choices.length) {\n\t\t\treturn this.getChoiceColumns(configGr);\n\t\t}\n\n\t\treturn { columns: [], columnsMap: {}, order: 0 };\n\t},\n\n\tgetReferenceColumns: function ({ table }) {\n\t\tconst refTableGr = new GlideRecord(table);\n\t\tif (refTableGr.isValidField(\"active\")) {\n\t\t\trefTableGr.addActiveQuery();\n\t\t}\n\t\tif (refTableGr.isValidField(\"sequence\")) {\n\t\t\trefTableGr.orderBy('sequence');\n\t\t} else {\n\t\t\trefTableGr.orderBy(refTableGr.getDisplayName());\n\t\t}\n\t\trefTableGr.query();\n\n\t\tconst columns = [];\n\t\tconst columnsMap = {};\n\t\tlet order = 0;\n\n\t\twhile (refTableGr.next()) {\n\t\t\tcolumns.push({\n\t\t\t\tdisplayValue: refTableGr.getDisplayValue(),\n\t\t\t\torder,\n\t\t\t\tvalue: refTableGr.getUniqueValue(),\n\t\t\t\titems: [],\n\t\t\t});\n\n\t\t\tcolumnsMap[refTableGr.getUniqueValue()] = order;\n\n\t\t\torder++;\n\t\t}\n\n\t\treturn { columns, columnsMap, order };\n\t},\n\n\tgetChoiceColumns: function (configGr) {\n\t\tconst sysChoiceGr = new GlideRecord(\"sys_choice\");\n\t\tsysChoiceGr.addQuery(\"name\", configGr.getValue(\"table\"));\n\t\tsysChoiceGr.addQuery(\"element\", configGr.getValue(\"group_by\"));\n\t\tsysChoiceGr.addQuery(\"inactive\", false);\n\t\tsysChoiceGr.orderBy(\"sequence\");\n\t\tsysChoiceGr.query();\n\n\t\tconst columns = [];\n\t\tconst columnsMap = {};\n\t\tlet order = 0;\n\n\t\twhile (sysChoiceGr.next()) {\n\t\t\tcolumns.push({\n\t\t\t\tdisplayValue: sysChoiceGr.getDisplayValue(\"label\"),\n\t\t\t\torder,\n\t\t\t\tvalue: sysChoiceGr.getValue(\"value\"),\n\t\t\t\titems: [],\n\t\t\t});\n\n\t\t\tcolumnsMap[sysChoiceGr.getValue(\"value\")] = order;\n\n\t\t\torder++;\n\t\t}\n\n\t\treturn { columns, columnsMap, order };\n\t},\n\n\tgetParentSegment: function (tableGr, field, property) {\n\t\tlet segments = \"\";\n\t\tif (tableGr.isValidField(field) && tableGr.getValue(field)) {\n\t\t\tconst fieldGr = tableGr[field].getRefRecord();\n\t\t\tsegments = fieldGr.getValue(\"segment\");\n\t\t}\n\t\tif (!segments && property) {\n\t\t\tsegments = gs.getProperty(property);\n\t\t}\n\t\tif (!segments) {\n\t\t\tsegments = \"\";\n\t\t}\n\t\treturn segments;\n\t},\n\n\t/**\n   * @function increaseIndex\n   * @description increase the index value of a record\n   * @param table - the table name\n   * @param query - the query to find the record\n   * @param amount - the amount to increase the index value by\n   * @param indexField - the name of the index field\n   * @return index - the new index value\n   * @example\n   * new workMainUtils().increaseIndex({table, query, amount, indexField});\n   */\n\tincreaseIndex: function ({ table, query, amount, indexField }) {\n\t\tconst tableGr = new GlideRecord(table);\n\t\ttableGr.addEncodedQuery(query);\n\t\ttableGr.orderByDesc(indexField);\n\t\ttableGr.setLimit(1);\n\t\ttableGr.query();\n\t\tif (tableGr.next()) {\n\t\t\tconst index = parseInt(tableGr.getValue(indexField)) + amount;\n\t\t\treturn index;\n\t\t} else {\n\t\t\treturn amount;\n\t\t}\n\t},\n\n\ttype: \"workMainUtilsMS\",\n};\n",
    "display_value": "/* eslint-disable max-lines */\nconst workMainUtilsMS = Class.create();\nworkMainUtilsMS.prototype = {\n\tinitialize: function () {\n\t\tthis.refRecordObj = {};\n\t\tthis.months = [\n\t\t\t\"\",\n\t\t\t\"January\",\n\t\t\t\"February\",\n\t\t\t\"March\",\n\t\t\t\"April\",\n\t\t\t\"May\",\n\t\t\t\"June\",\n\t\t\t\"July\",\n\t\t\t\"August\",\n\t\t\t\"September\",\n\t\t\t\"October\",\n\t\t\t\"November\",\n\t\t\t\"December\",\n\t\t];\n\t\tthis.monthsAbr = [\n\t\t\t\"\",\n\t\t\t\"Jan\",\n\t\t\t\"Feb\",\n\t\t\t\"Mar\",\n\t\t\t\"Apr\",\n\t\t\t\"May\",\n\t\t\t\"Jun\",\n\t\t\t\"Jul\",\n\t\t\t\"Aug\",\n\t\t\t\"Sept\",\n\t\t\t\"Oct\",\n\t\t\t\"Nov\",\n\t\t\t\"Dec\",\n\t\t];\n\t\tthis.index = {};\n\t},\n\n\tfindTemplate: function(type) {\n\t\tvar ans = {found: false, template: {}};\n\t\tvar projTempGr = new GlideRecord('x_cadso_work_project_template');\n\t\tprojTempGr.addQuery('type', type);\n\t\tprojTempGr.setLimit(1);\n\t\tprojTempGr.query();\n\n\t\twhile (projTempGr.next()) {\n\t\t\tvar calcDates = (projTempGr.getValue('calculate_dates') + '');\n\t\t\tans.found = true;\n\t\t\tans.template = {\n\t\t\t\tgr: projTempGr,\n\t\t\t\tsysId: projTempGr.getUniqueValue(),\n\t\t\t\tcalcType: calcDates\n\t\t\t};\n\t\t}\n\n\t\treturn ans;\n\t},\n\n\tconvertSprintDates: function ({ fieldsObj }) {\n\t\tconst fieldsToConvert = \"expected_start,expected_end,actual_start,actual_end,due_date\";\n\t\tfieldsToConvert.split(\",\").forEach(function (field) {\n\t\t\tif (fieldsObj[field] && fieldsObj[field].value) {\n\t\t\t\tfieldsObj[field].displayValue = this.getDateDisplay({ date: fieldsObj[field].value });\n\t\t\t}\n\t\t}, this);\n\t},\n\n\tgetDateDisplay: function ({ date }) {\n\t\tconst dt = new GlideDateTime(date);\n\t\tconst month = dt.getMonthLocalTime();\n\t\tconst day = dt.getDayOfMonthLocalTime();\n\t\treturn `${this.months[month]} ${day}`;\n\t},\n\n\tgetRecords: function ({\n\t\ttype,\n\t\ttable,\n\t\tqueries,\n\t\tfields,\n\t\tsortBys,\n\t\tsortAsc,\n\t\tsortByDisplayField,\n\t\tsortAscDisplayField,\n\t\tgetItems,\n\t\titemObj,\n\t\tparentField,\n\t\tparentFieldValue,\n\t\tparentQuery,\n\t\tparentFieldQuery,\n\t\taddParentQuery,\n\t\tshow,\n\t}) {\n\t\tconst typeTable = type + table;\n\t\tconst records = [];\n\t\tlet parentQueries = addParentQuery && parentQuery && parentQuery.length ? parentQuery : [];\n\t\tlet isSprintTable = false;\n\t\tlet isProjectTable = false;\n\t\tlet isTaskTable = false;\n\t\tif (table === \"x_cadso_work_sprint\") {\n\t\t\tisSprintTable = true;\n\t\t} else if (table === \"x_cadso_work_project\") {\n\t\t\tisProjectTable = true;\n\t\t} else if (table === \"x_cadso_work_task\") {\n\t\t\tisTaskTable = true;\n\t\t}\n\n\t\tconst tableGr = new GlideRecord(table);\n\n\t\tif (queries && queries.length) {\n\t\t\tqueries.forEach((query) => {\n\t\t\t\ttableGr.addEncodedQuery(query);\n\t\t\t});\n\t\t}\n\n\t\tif (parentField && parentFieldValue) {\n\t\t\tconst querySymbol = parentFieldQuery || \"=\";\n\t\t\tparentQueries.push(`${parentField}${querySymbol}${parentFieldValue}`);\n\t\t}\n\n\t\tif (parentQueries && parentQueries.length) {\n\t\t\tif (isTaskTable) {\n\t\t\t\tparentQueries = parentQueries.map((query) => query.replace(\"sprintsLIKE\", \"sprint=\"));\n\t\t\t}\n\t\t\tparentQueries.forEach((query) => {\n\t\t\t\ttableGr.addEncodedQuery(query);\n\t\t\t});\n\t\t}\n\n\t\tconst direction = sortAsc ? \"orderBy\" : \"orderByDesc\";\n\t\tconst displayFieldSortDirection = sortAscDisplayField ? \"orderBy\" : \"orderByDesc\";\n\t\tconst displayField = tableGr.getDisplayName();\n\n\t\tthis.setOrderBy({ tableGr, sortBys, direction });\n\n\t\tif (sortByDisplayField && displayField) {\n\t\t\tthis.setOrderBy({ tableGr, sortBys: [displayField], direction: displayFieldSortDirection });\n\t\t}\n\n\t\ttableGr.query();\n\n\t\tthis.index[typeTable] = 0;\n\t\twhile (tableGr.next()) {\n\t\t\tconst completed = \"40,50,60,70\".indexOf(tableGr.getValue(\"state\")) > -1;\n\t\t\tconst sysId = tableGr.getUniqueValue();\n\t\t\tconst fieldsObj = this.getFields({ fields, tableGr, isSprintTable });\n\t\t\tconst record = {\n\t\t\t\t...fieldsObj,\n\t\t\t\tdisplayValue: tableGr.getDisplayValue(),\n\t\t\t\tvalue: sysId,\n\t\t\t\tsysId,\n\t\t\t\tsys_id: sysId,\n\t\t\t\tcompleted,\n\t\t\t};\n\n\t\t\tif (isProjectTable) {\n\t\t\t\trecord.index = this.getProjectIndex({\n\t\t\t\t\tproject: sysId,\n\t\t\t\t\tsprint: type === \"backlog\" ? false : parentFieldValue,\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\tif (isProjectTable || isTaskTable) {\n\t\t\t\tconst field = isProjectTable ? 'expected_end' : 'due_date';\n\t\t\t\tif (tableGr.getValue(field)) {\n\t\t\t\t\tconst gdt = new GlideDateTime();\n\t\t\t\t\tgdt.setValue(tableGr.getValue(field));\n\t\t\t\t\tconst month = parseInt(gdt.getMonthLocalTime());\n\t\t\t\t\trecord.dueDate = `${this.monthsAbr[month]} ${gdt.getDayOfMonthLocalTime()}`;\n\t\t\t\t} else {\n\t\t\t\t\trecord.dueDate = '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getItems) {\n\t\t\t\tconst itemsRecords = this.getRecords({\n\t\t\t\t\t...itemObj,\n\t\t\t\t\tparentFieldValue: tableGr.getUniqueValue(),\n\t\t\t\t\tparentQuery:\n\t\t\t\t\titemObj.addParentQuery && parentQueries && parentQueries.length\n\t\t\t\t\t? [...parentQueries]\n\t\t\t\t\t: [],\n\t\t\t\t});\n\n\t\t\t\tif (isProjectTable) {\n\t\t\t\t\tconst sprint = type === \"backlog\" ? false : parentFieldValue;\n\t\t\t\t\trecord.index = this.getProjectIndex({ project: sysId, sprint });\n\t\t\t\t}\n\t\t\t\trecord.items = itemsRecords;\n\t\t\t}\n\n\t\t\trecords.push(record);\n\t\t}\n\n\t\tif (isProjectTable) {\n\t\t\trecords.sort((a, b) => {\n\t\t\t\treturn (\n\t\t\t\t\ta.index.value.localeCompare(b.index.value) || a.displayValue.localeCompare(b.displayValue)\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\treturn records;\n\t},\n\n\tgetFields: function ({ fields, tableGr, isSprintTable }) {\n\t\tconst fieldsObj = {};\n\n\t\tif (fields && fields.length) {\n\t\t\tfields.forEach((field) => {\n\t\t\t\tfieldsObj[field] = this.getField({ tableGr, field }) || { displayValue: \"\", value: \"\" };\n\t\t\t});\n\n\t\t\tif (isSprintTable) {\n\t\t\t\tthis.convertSprintDates({ fieldsObj });\n\t\t\t}\n\n\t\t\tif (fields.includes(\"assigned_to\") && fieldsObj.assigned_to && fieldsObj.assigned_to.value) {\n\t\t\t\tthis.getRefValue({\n\t\t\t\t\ttableGr,\n\t\t\t\t\tfield: \"assigned_to\",\n\t\t\t\t\tvalue: fieldsObj.assigned_to.value,\n\t\t\t\t\tfieldName: \"photo\",\n\t\t\t\t\tkeyName: \"avatar\",\n\t\t\t\t\trecord: fieldsObj,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn fieldsObj;\n\t},\n\n\tgetField: function ({ tableGr, field }) {\n\t\treturn {\n\t\t\tdisplayValue: tableGr.getDisplayValue(field) || \"\",\n\t\t\tvalue: tableGr.getValue(field) || \"\",\n\t\t};\n\t},\n\n\tgetRefValue: function ({ tableGr, field, value, fieldName, keyName, record }) {\n\t\tif (!this.refRecordObj[value] && value) {\n\t\t\tconst refRecordGr = tableGr[field].getRefRecord();\n\t\t\tif (refRecordGr.isValidRecord()) {\n\t\t\t\tthis.refRecordObj[value] = {\n\t\t\t\t\tdisplayValue: refRecordGr.getDisplayValue(fieldName),\n\t\t\t\t\tvalue: refRecordGr.getValue(fieldName),\n\t\t\t\t};\n\n\t\t\t\tif (keyName === 'avatar') {\n\t\t\t\t\tlet avatar = refRecordGr.getValue('avatar');\n\t\t\t\t\tavatar = avatar == null ? '' : avatar;\n\t\t\t\t\tlet photo = refRecordGr.getValue('photo');\n\t\t\t\t\tphoto = photo == null ? '' : photo;\n\t\t\t\t\tconst userAvatar = avatar || photo;\n\t\t\t\t\tthis.refRecordObj[value] = {\n\t\t\t\t\t\tdisplayValue: userAvatar ? userAvatar + '.iix' : '',\n\t\t\t\t\t\tvalue: userAvatar,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trecord[field][keyName] = this.refRecordObj[value] || { displayValue: \"\", value: \"\" };\n\t},\n\n\tsetOrderBy: function ({ tableGr, sortBys, direction }) {\n\t\tif (sortBys && sortBys.length) {\n\t\t\tsortBys.map((sortBy) => tableGr[direction](sortBy));\n\t\t}\n\t},\n\n\tgetProjectIndex: function ({ project, sprint }) {\n\t\tconst workSprintProjectM2MGr = new GlideRecord(\"x_cadso_work_sprint_project_m2m\");\n\t\tworkSprintProjectM2MGr.addQuery(\"project\", project);\n\n\t\tif (sprint) {\n\t\t\tworkSprintProjectM2MGr.addQuery(\"sprint\", sprint);\n\t\t} else {\n\t\t\tworkSprintProjectM2MGr.addEncodedQuery(\"sprintISEMPTY\");\n\t\t}\n\n\t\tworkSprintProjectM2MGr.query();\n\n\t\tif (workSprintProjectM2MGr.next()) {\n\t\t\treturn {\n\t\t\t\tdisplayValue: workSprintProjectM2MGr.getDisplayValue(\"index\"),\n\t\t\t\tvalue: workSprintProjectM2MGr.getValue(\"index\"),\n\t\t\t};\n\t\t}\n\n\t\treturn { displayValue: \"\", value: \"\" };\n\t},\n\n\tgetColumns: function (configGr) {\n\t\tconst table = configGr.getValue(\"table\");\n\t\tconst element = configGr.getValue(\"group_by\");\n\t\tconst tableGr = new GlideRecord(table);\n\t\tconst elementGE = tableGr.getElement(element);\n\t\tconst elementED = elementGE.getED();\n\t\tconst type = elementED.getInternalType();\n\t\tconst choices = elementGE.getChoices();\n\n\t\tif (type === \"reference\") {\n\t\t\tconst refTable = elementGE.getReferenceTable();\n\t\t\treturn this.getReferenceColumns({ table: refTable });\n\t\t} else if (choices.length) {\n\t\t\treturn this.getChoiceColumns(configGr);\n\t\t}\n\n\t\treturn { columns: [], columnsMap: {}, order: 0 };\n\t},\n\n\tgetReferenceColumns: function ({ table }) {\n\t\tconst refTableGr = new GlideRecord(table);\n\t\tif (refTableGr.isValidField(\"active\")) {\n\t\t\trefTableGr.addActiveQuery();\n\t\t}\n\t\tif (refTableGr.isValidField(\"sequence\")) {\n\t\t\trefTableGr.orderBy('sequence');\n\t\t} else {\n\t\t\trefTableGr.orderBy(refTableGr.getDisplayName());\n\t\t}\n\t\trefTableGr.query();\n\n\t\tconst columns = [];\n\t\tconst columnsMap = {};\n\t\tlet order = 0;\n\n\t\twhile (refTableGr.next()) {\n\t\t\tcolumns.push({\n\t\t\t\tdisplayValue: refTableGr.getDisplayValue(),\n\t\t\t\torder,\n\t\t\t\tvalue: refTableGr.getUniqueValue(),\n\t\t\t\titems: [],\n\t\t\t});\n\n\t\t\tcolumnsMap[refTableGr.getUniqueValue()] = order;\n\n\t\t\torder++;\n\t\t}\n\n\t\treturn { columns, columnsMap, order };\n\t},\n\n\tgetChoiceColumns: function (configGr) {\n\t\tconst sysChoiceGr = new GlideRecord(\"sys_choice\");\n\t\tsysChoiceGr.addQuery(\"name\", configGr.getValue(\"table\"));\n\t\tsysChoiceGr.addQuery(\"element\", configGr.getValue(\"group_by\"));\n\t\tsysChoiceGr.addQuery(\"inactive\", false);\n\t\tsysChoiceGr.orderBy(\"sequence\");\n\t\tsysChoiceGr.query();\n\n\t\tconst columns = [];\n\t\tconst columnsMap = {};\n\t\tlet order = 0;\n\n\t\twhile (sysChoiceGr.next()) {\n\t\t\tcolumns.push({\n\t\t\t\tdisplayValue: sysChoiceGr.getDisplayValue(\"label\"),\n\t\t\t\torder,\n\t\t\t\tvalue: sysChoiceGr.getValue(\"value\"),\n\t\t\t\titems: [],\n\t\t\t});\n\n\t\t\tcolumnsMap[sysChoiceGr.getValue(\"value\")] = order;\n\n\t\t\torder++;\n\t\t}\n\n\t\treturn { columns, columnsMap, order };\n\t},\n\n\tgetParentSegment: function (tableGr, field, property) {\n\t\tlet segments = \"\";\n\t\tif (tableGr.isValidField(field) && tableGr.getValue(field)) {\n\t\t\tconst fieldGr = tableGr[field].getRefRecord();\n\t\t\tsegments = fieldGr.getValue(\"segment\");\n\t\t}\n\t\tif (!segments && property) {\n\t\t\tsegments = gs.getProperty(property);\n\t\t}\n\t\tif (!segments) {\n\t\t\tsegments = \"\";\n\t\t}\n\t\treturn segments;\n\t},\n\n\t/**\n   * @function increaseIndex\n   * @description increase the index value of a record\n   * @param table - the table name\n   * @param query - the query to find the record\n   * @param amount - the amount to increase the index value by\n   * @param indexField - the name of the index field\n   * @return index - the new index value\n   * @example\n   * new workMainUtils().increaseIndex({table, query, amount, indexField});\n   */\n\tincreaseIndex: function ({ table, query, amount, indexField }) {\n\t\tconst tableGr = new GlideRecord(table);\n\t\ttableGr.addEncodedQuery(query);\n\t\ttableGr.orderByDesc(indexField);\n\t\ttableGr.setLimit(1);\n\t\ttableGr.query();\n\t\tif (tableGr.next()) {\n\t\t\tconst index = parseInt(tableGr.getValue(indexField)) + amount;\n\t\t\treturn index;\n\t\t} else {\n\t\t\treturn amount;\n\t\t}\n\t},\n\n\ttype: \"workMainUtilsMS\",\n};\n",
    "formatted_script": {
      "line_count": 414,
      "char_count": 10540,
      "preview": "/* eslint-disable max-lines */\nconst workMainUtilsMS = Class.create();\nworkMainUtilsMS.prototype = {\n\tinitialize: function () {\n\t\tthis.refRecordObj = {};\n\t\tthis.months = [\n\t\t\t\"\",\n\t\t\t\"January\",\n\t\t\t\"Feb...",
      "full_script": "/* eslint-disable max-lines */\nconst workMainUtilsMS = Class.create();\nworkMainUtilsMS.prototype = {\n\tinitialize: function () {\n\t\tthis.refRecordObj = {};\n\t\tthis.months = [\n\t\t\t\"\",\n\t\t\t\"January\",\n\t\t\t\"February\",\n\t\t\t\"March\",\n\t\t\t\"April\",\n\t\t\t\"May\",\n\t\t\t\"June\",\n\t\t\t\"July\",\n\t\t\t\"August\",\n\t\t\t\"September\",\n\t\t\t\"October\",\n\t\t\t\"November\",\n\t\t\t\"December\",\n\t\t];\n\t\tthis.monthsAbr = [\n\t\t\t\"\",\n\t\t\t\"Jan\",\n\t\t\t\"Feb\",\n\t\t\t\"Mar\",\n\t\t\t\"Apr\",\n\t\t\t\"May\",\n\t\t\t\"Jun\",\n\t\t\t\"Jul\",\n\t\t\t\"Aug\",\n\t\t\t\"Sept\",\n\t\t\t\"Oct\",\n\t\t\t\"Nov\",\n\t\t\t\"Dec\",\n\t\t];\n\t\tthis.index = {};\n\t},\n\n\tfindTemplate: function(type) {\n\t\tvar ans = {found: false, template: {}};\n\t\tvar projTempGr = new GlideRecord('x_cadso_work_project_template');\n\t\tprojTempGr.addQuery('type', type);\n\t\tprojTempGr.setLimit(1);\n\t\tprojTempGr.query();\n\n\t\twhile (projTempGr.next()) {\n\t\t\tvar calcDates = (projTempGr.getValue('calculate_dates') + '');\n\t\t\tans.found = true;\n\t\t\tans.template = {\n\t\t\t\tgr: projTempGr,\n\t\t\t\tsysId: projTempGr.getUniqueValue(),\n\t\t\t\tcalcType: calcDates\n\t\t\t};\n\t\t}\n\n\t\treturn ans;\n\t},\n\n\tconvertSprintDates: function ({ fieldsObj }) {\n\t\tconst fieldsToConvert = \"expected_start,expected_end,actual_start,actual_end,due_date\";\n\t\tfieldsToConvert.split(\",\").forEach(function (field) {\n\t\t\tif (fieldsObj[field] && fieldsObj[field].value) {\n\t\t\t\tfieldsObj[field].displayValue = this.getDateDisplay({ date: fieldsObj[field].value });\n\t\t\t}\n\t\t}, this);\n\t},\n\n\tgetDateDisplay: function ({ date }) {\n\t\tconst dt = new GlideDateTime(date);\n\t\tconst month = dt.getMonthLocalTime();\n\t\tconst day = dt.getDayOfMonthLocalTime();\n\t\treturn `${this.months[month]} ${day}`;\n\t},\n\n\tgetRecords: function ({\n\t\ttype,\n\t\ttable,\n\t\tqueries,\n\t\tfields,\n\t\tsortBys,\n\t\tsortAsc,\n\t\tsortByDisplayField,\n\t\tsortAscDisplayField,\n\t\tgetItems,\n\t\titemObj,\n\t\tparentField,\n\t\tparentFieldValue,\n\t\tparentQuery,\n\t\tparentFieldQuery,\n\t\taddParentQuery,\n\t\tshow,\n\t}) {\n\t\tconst typeTable = type + table;\n\t\tconst records = [];\n\t\tlet parentQueries = addParentQuery && parentQuery && parentQuery.length ? parentQuery : [];\n\t\tlet isSprintTable = false;\n\t\tlet isProjectTable = false;\n\t\tlet isTaskTable = false;\n\t\tif (table === \"x_cadso_work_sprint\") {\n\t\t\tisSprintTable = true;\n\t\t} else if (table === \"x_cadso_work_project\") {\n\t\t\tisProjectTable = true;\n\t\t} else if (table === \"x_cadso_work_task\") {\n\t\t\tisTaskTable = true;\n\t\t}\n\n\t\tconst tableGr = new GlideRecord(table);\n\n\t\tif (queries && queries.length) {\n\t\t\tqueries.forEach((query) => {\n\t\t\t\ttableGr.addEncodedQuery(query);\n\t\t\t});\n\t\t}\n\n\t\tif (parentField && parentFieldValue) {\n\t\t\tconst querySymbol = parentFieldQuery || \"=\";\n\t\t\tparentQueries.push(`${parentField}${querySymbol}${parentFieldValue}`);\n\t\t}\n\n\t\tif (parentQueries && parentQueries.length) {\n\t\t\tif (isTaskTable) {\n\t\t\t\tparentQueries = parentQueries.map((query) => query.replace(\"sprintsLIKE\", \"sprint=\"));\n\t\t\t}\n\t\t\tparentQueries.forEach((query) => {\n\t\t\t\ttableGr.addEncodedQuery(query);\n\t\t\t});\n\t\t}\n\n\t\tconst direction = sortAsc ? \"orderBy\" : \"orderByDesc\";\n\t\tconst displayFieldSortDirection = sortAscDisplayField ? \"orderBy\" : \"orderByDesc\";\n\t\tconst displayField = tableGr.getDisplayName();\n\n\t\tthis.setOrderBy({ tableGr, sortBys, direction });\n\n\t\tif (sortByDisplayField && displayField) {\n\t\t\tthis.setOrderBy({ tableGr, sortBys: [displayField], direction: displayFieldSortDirection });\n\t\t}\n\n\t\ttableGr.query();\n\n\t\tthis.index[typeTable] = 0;\n\t\twhile (tableGr.next()) {\n\t\t\tconst completed = \"40,50,60,70\".indexOf(tableGr.getValue(\"state\")) > -1;\n\t\t\tconst sysId = tableGr.getUniqueValue();\n\t\t\tconst fieldsObj = this.getFields({ fields, tableGr, isSprintTable });\n\t\t\tconst record = {\n\t\t\t\t...fieldsObj,\n\t\t\t\tdisplayValue: tableGr.getDisplayValue(),\n\t\t\t\tvalue: sysId,\n\t\t\t\tsysId,\n\t\t\t\tsys_id: sysId,\n\t\t\t\tcompleted,\n\t\t\t};\n\n\t\t\tif (isProjectTable) {\n\t\t\t\trecord.index = this.getProjectIndex({\n\t\t\t\t\tproject: sysId,\n\t\t\t\t\tsprint: type === \"backlog\" ? false : parentFieldValue,\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\tif (isProjectTable || isTaskTable) {\n\t\t\t\tconst field = isProjectTable ? 'expected_end' : 'due_date';\n\t\t\t\tif (tableGr.getValue(field)) {\n\t\t\t\t\tconst gdt = new GlideDateTime();\n\t\t\t\t\tgdt.setValue(tableGr.getValue(field));\n\t\t\t\t\tconst month = parseInt(gdt.getMonthLocalTime());\n\t\t\t\t\trecord.dueDate = `${this.monthsAbr[month]} ${gdt.getDayOfMonthLocalTime()}`;\n\t\t\t\t} else {\n\t\t\t\t\trecord.dueDate = '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getItems) {\n\t\t\t\tconst itemsRecords = this.getRecords({\n\t\t\t\t\t...itemObj,\n\t\t\t\t\tparentFieldValue: tableGr.getUniqueValue(),\n\t\t\t\t\tparentQuery:\n\t\t\t\t\titemObj.addParentQuery && parentQueries && parentQueries.length\n\t\t\t\t\t? [...parentQueries]\n\t\t\t\t\t: [],\n\t\t\t\t});\n\n\t\t\t\tif (isProjectTable) {\n\t\t\t\t\tconst sprint = type === \"backlog\" ? false : parentFieldValue;\n\t\t\t\t\trecord.index = this.getProjectIndex({ project: sysId, sprint });\n\t\t\t\t}\n\t\t\t\trecord.items = itemsRecords;\n\t\t\t}\n\n\t\t\trecords.push(record);\n\t\t}\n\n\t\tif (isProjectTable) {\n\t\t\trecords.sort((a, b) => {\n\t\t\t\treturn (\n\t\t\t\t\ta.index.value.localeCompare(b.index.value) || a.displayValue.localeCompare(b.displayValue)\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\treturn records;\n\t},\n\n\tgetFields: function ({ fields, tableGr, isSprintTable }) {\n\t\tconst fieldsObj = {};\n\n\t\tif (fields && fields.length) {\n\t\t\tfields.forEach((field) => {\n\t\t\t\tfieldsObj[field] = this.getField({ tableGr, field }) || { displayValue: \"\", value: \"\" };\n\t\t\t});\n\n\t\t\tif (isSprintTable) {\n\t\t\t\tthis.convertSprintDates({ fieldsObj });\n\t\t\t}\n\n\t\t\tif (fields.includes(\"assigned_to\") && fieldsObj.assigned_to && fieldsObj.assigned_to.value) {\n\t\t\t\tthis.getRefValue({\n\t\t\t\t\ttableGr,\n\t\t\t\t\tfield: \"assigned_to\",\n\t\t\t\t\tvalue: fieldsObj.assigned_to.value,\n\t\t\t\t\tfieldName: \"photo\",\n\t\t\t\t\tkeyName: \"avatar\",\n\t\t\t\t\trecord: fieldsObj,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn fieldsObj;\n\t},\n\n\tgetField: function ({ tableGr, field }) {\n\t\treturn {\n\t\t\tdisplayValue: tableGr.getDisplayValue(field) || \"\",\n\t\t\tvalue: tableGr.getValue(field) || \"\",\n\t\t};\n\t},\n\n\tgetRefValue: function ({ tableGr, field, value, fieldName, keyName, record }) {\n\t\tif (!this.refRecordObj[value] && value) {\n\t\t\tconst refRecordGr = tableGr[field].getRefRecord();\n\t\t\tif (refRecordGr.isValidRecord()) {\n\t\t\t\tthis.refRecordObj[value] = {\n\t\t\t\t\tdisplayValue: refRecordGr.getDisplayValue(fieldName),\n\t\t\t\t\tvalue: refRecordGr.getValue(fieldName),\n\t\t\t\t};\n\n\t\t\t\tif (keyName === 'avatar') {\n\t\t\t\t\tlet avatar = refRecordGr.getValue('avatar');\n\t\t\t\t\tavatar = avatar == null ? '' : avatar;\n\t\t\t\t\tlet photo = refRecordGr.getValue('photo');\n\t\t\t\t\tphoto = photo == null ? '' : photo;\n\t\t\t\t\tconst userAvatar = avatar || photo;\n\t\t\t\t\tthis.refRecordObj[value] = {\n\t\t\t\t\t\tdisplayValue: userAvatar ? userAvatar + '.iix' : '',\n\t\t\t\t\t\tvalue: userAvatar,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trecord[field][keyName] = this.refRecordObj[value] || { displayValue: \"\", value: \"\" };\n\t},\n\n\tsetOrderBy: function ({ tableGr, sortBys, direction }) {\n\t\tif (sortBys && sortBys.length) {\n\t\t\tsortBys.map((sortBy) => tableGr[direction](sortBy));\n\t\t}\n\t},\n\n\tgetProjectIndex: function ({ project, sprint }) {\n\t\tconst workSprintProjectM2MGr = new GlideRecord(\"x_cadso_work_sprint_project_m2m\");\n\t\tworkSprintProjectM2MGr.addQuery(\"project\", project);\n\n\t\tif (sprint) {\n\t\t\tworkSprintProjectM2MGr.addQuery(\"sprint\", sprint);\n\t\t} else {\n\t\t\tworkSprintProjectM2MGr.addEncodedQuery(\"sprintISEMPTY\");\n\t\t}\n\n\t\tworkSprintProjectM2MGr.query();\n\n\t\tif (workSprintProjectM2MGr.next()) {\n\t\t\treturn {\n\t\t\t\tdisplayValue: workSprintProjectM2MGr.getDisplayValue(\"index\"),\n\t\t\t\tvalue: workSprintProjectM2MGr.getValue(\"index\"),\n\t\t\t};\n\t\t}\n\n\t\treturn { displayValue: \"\", value: \"\" };\n\t},\n\n\tgetColumns: function (configGr) {\n\t\tconst table = configGr.getValue(\"table\");\n\t\tconst element = configGr.getValue(\"group_by\");\n\t\tconst tableGr = new GlideRecord(table);\n\t\tconst elementGE = tableGr.getElement(element);\n\t\tconst elementED = elementGE.getED();\n\t\tconst type = elementED.getInternalType();\n\t\tconst choices = elementGE.getChoices();\n\n\t\tif (type === \"reference\") {\n\t\t\tconst refTable = elementGE.getReferenceTable();\n\t\t\treturn this.getReferenceColumns({ table: refTable });\n\t\t} else if (choices.length) {\n\t\t\treturn this.getChoiceColumns(configGr);\n\t\t}\n\n\t\treturn { columns: [], columnsMap: {}, order: 0 };\n\t},\n\n\tgetReferenceColumns: function ({ table }) {\n\t\tconst refTableGr = new GlideRecord(table);\n\t\tif (refTableGr.isValidField(\"active\")) {\n\t\t\trefTableGr.addActiveQuery();\n\t\t}\n\t\tif (refTableGr.isValidField(\"sequence\")) {\n\t\t\trefTableGr.orderBy('sequence');\n\t\t} else {\n\t\t\trefTableGr.orderBy(refTableGr.getDisplayName());\n\t\t}\n\t\trefTableGr.query();\n\n\t\tconst columns = [];\n\t\tconst columnsMap = {};\n\t\tlet order = 0;\n\n\t\twhile (refTableGr.next()) {\n\t\t\tcolumns.push({\n\t\t\t\tdisplayValue: refTableGr.getDisplayValue(),\n\t\t\t\torder,\n\t\t\t\tvalue: refTableGr.getUniqueValue(),\n\t\t\t\titems: [],\n\t\t\t});\n\n\t\t\tcolumnsMap[refTableGr.getUniqueValue()] = order;\n\n\t\t\torder++;\n\t\t}\n\n\t\treturn { columns, columnsMap, order };\n\t},\n\n\tgetChoiceColumns: function (configGr) {\n\t\tconst sysChoiceGr = new GlideRecord(\"sys_choice\");\n\t\tsysChoiceGr.addQuery(\"name\", configGr.getValue(\"table\"));\n\t\tsysChoiceGr.addQuery(\"element\", configGr.getValue(\"group_by\"));\n\t\tsysChoiceGr.addQuery(\"inactive\", false);\n\t\tsysChoiceGr.orderBy(\"sequence\");\n\t\tsysChoiceGr.query();\n\n\t\tconst columns = [];\n\t\tconst columnsMap = {};\n\t\tlet order = 0;\n\n\t\twhile (sysChoiceGr.next()) {\n\t\t\tcolumns.push({\n\t\t\t\tdisplayValue: sysChoiceGr.getDisplayValue(\"label\"),\n\t\t\t\torder,\n\t\t\t\tvalue: sysChoiceGr.getValue(\"value\"),\n\t\t\t\titems: [],\n\t\t\t});\n\n\t\t\tcolumnsMap[sysChoiceGr.getValue(\"value\")] = order;\n\n\t\t\torder++;\n\t\t}\n\n\t\treturn { columns, columnsMap, order };\n\t},\n\n\tgetParentSegment: function (tableGr, field, property) {\n\t\tlet segments = \"\";\n\t\tif (tableGr.isValidField(field) && tableGr.getValue(field)) {\n\t\t\tconst fieldGr = tableGr[field].getRefRecord();\n\t\t\tsegments = fieldGr.getValue(\"segment\");\n\t\t}\n\t\tif (!segments && property) {\n\t\t\tsegments = gs.getProperty(property);\n\t\t}\n\t\tif (!segments) {\n\t\t\tsegments = \"\";\n\t\t}\n\t\treturn segments;\n\t},\n\n\t/**\n   * @function increaseIndex\n   * @description increase the index value of a record\n   * @param table - the table name\n   * @param query - the query to find the record\n   * @param amount - the amount to increase the index value by\n   * @param indexField - the name of the index field\n   * @return index - the new index value\n   * @example\n   * new workMainUtils().increaseIndex({table, query, amount, indexField});\n   */\n\tincreaseIndex: function ({ table, query, amount, indexField }) {\n\t\tconst tableGr = new GlideRecord(table);\n\t\ttableGr.addEncodedQuery(query);\n\t\ttableGr.orderByDesc(indexField);\n\t\ttableGr.setLimit(1);\n\t\ttableGr.query();\n\t\tif (tableGr.next()) {\n\t\t\tconst index = parseInt(tableGr.getValue(indexField)) + amount;\n\t\t\treturn index;\n\t\t} else {\n\t\t\treturn amount;\n\t\t}\n\t},\n\n\ttype: \"workMainUtilsMS\",\n};\n"
    }
  },
  "sys_class_name": {
    "value": "sys_script_include",
    "display_value": "Script Include"
  },
  "sys_package": {
    "value": "4e4449a5475c255085d19fd8036d43a0",
    "display_value": "Tenon Marketing Work Management"
  },
  "sys_update_name": {
    "value": "sys_script_include_d26204a7871ba510b656fe66cebb3506",
    "display_value": "sys_script_include_d26204a7871ba510b656fe66cebb3506"
  },
  "sys_updated_by": {
    "value": "trevor.offen",
    "display_value": "trevor.offen"
  },
  "api_name": {
    "value": "x_cadso_work.workMainUtilsMS",
    "display_value": "x_cadso_work.workMainUtilsMS"
  },
  "sys_created_on": {
    "value": "2023-06-13 22:39:45",
    "display_value": "2023-06-13 03:39:45 PM"
  },
  "caller_access": {
    "value": "",
    "display_value": null
  },
  "name": {
    "value": "workMainUtilsMS",
    "display_value": "workMainUtilsMS"
  },
  "sys_name": {
    "value": "workMainUtilsMS",
    "display_value": "workMainUtilsMS"
  },
  "sys_scope": {
    "value": "4e4449a5475c255085d19fd8036d43a0",
    "display_value": "Tenon Marketing Work Management"
  },
  "sys_created_by": {
    "value": "daniel.cudney",
    "display_value": "daniel.cudney"
  },
  "sys_policy": {
    "value": "read",
    "display_value": "Read-only"
  }
}
