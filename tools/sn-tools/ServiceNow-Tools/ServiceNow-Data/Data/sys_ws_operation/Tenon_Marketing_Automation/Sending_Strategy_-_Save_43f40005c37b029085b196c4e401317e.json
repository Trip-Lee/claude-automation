{
  "_metadata": {
    "table": "sys_ws_operation",
    "sys_id": "43f40005c37b029085b196c4e401317e",
    "extracted_at": "2025-09-19T21:48:33.405Z",
    "display_value": "Sending Strategy - Save",
    "application": "Tenon_Marketing_Automation",
    "scope": {
      "display_value": "Tenon Marketing Automation",
      "link": "https://tenonworkstudio.service-now.com/api/now/table/sys_scope/5e9f5f8b87420250369f33373cbb3559",
      "value": "5e9f5f8b87420250369f33373cbb3559"
    }
  },
  "short_description": {
    "value": "",
    "display_value": ""
  },
  "operation_script": {
    "value": "(function process( /*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {\r\n\r\n    const {\r\n        strats,\r\n        draft = false,\r\n        canSend = false,\r\n        messageType,\r\n        sinchJson,\r\n        richText,\r\n        type = ''\r\n    } = request.body.data;\r\n\r\n    const successful = [];\r\n    const canSends = [];\r\n    let messages = [];\r\n    let inQueueMessageAdded = false;\r\n\t// gs.info(\"dh strats \" + JSON.stringify(strats));\r\n    // When single email send strat is saved, clean up abandoned B sends.\r\n    if (messageType === 'email' && strats.length === 1) {\r\n        removeBEmailSends(strats[0]);\r\n    }\r\n\r\n    for (var x = 0; x < strats.length; x++) {\r\n        if (inQueueMessageAdded) {\r\n            successful.push(false);\r\n            canSends.push(false);\r\n            continue;\r\n        }\r\n        const {\r\n            success,\r\n            canSend\r\n        } = messageType === 'sms' ?\r\n            createOrUpdateMessageSends({\r\n                strat: strats[x],\r\n                sinchJson,\r\n                draft,\r\n                richText,\r\n\t\t\t\ttype\r\n            }) :\r\n            createOrUpdateEmailSends({\r\n                strat: strats[x],\r\n                draft,\r\n                type\r\n            });\r\n        if (success && success.length === 32) {\r\n            strats[x].sysId = success;\r\n            successful.push(true);\r\n        } else if (success) { // this is a weird bug if you try to save from the email now/schedule option, success comes back as nothing, so checking to see if success is populated first\r\n            successful.push(success);\r\n        }\r\n        canSends.push(canSend);\r\n    }\r\n    const _successful = successful.filter(res => res === true).length === strats.length;\r\n\r\n    if (successful && successful.length > 0) {\r\n        messages.push({\r\n            message: \"Update Successful\",\r\n            description: '',\r\n            type: 'success'\r\n        });\r\n    }\r\n\r\n    const responseBody = {\r\n        successful: _successful,\r\n        canSend: canSends.filter(res => res === true).length === strats.length,\r\n        strats,\r\n        draft,\r\n        messages\r\n    };\r\n\r\n    response.setBody(responseBody);\r\n\r\n    function removeBEmailSends(strat_a) {\r\n        const bEmailSendGr = new GlideRecord('x_cadso_automate_email_send');\r\n        bEmailSendGr.addQuery('email', strat_a.emailId);\r\n        bEmailSendGr.addQuery(\"sys_id\", \"!=\", strat_a.sysId);\r\n        bEmailSendGr.query();\r\n        if (bEmailSendGr.next()) {\r\n            bEmailSendGr.deleteRecord();\r\n        }\r\n    }\r\n\r\n    function createOrUpdateEmailSends({\r\n        strat,\r\n        draft,\r\n        type\r\n    }) {\r\n        const {\r\n            optimized,\r\n            optimizedBy = {},\r\n            sendingStrategy,\r\n            sendOn,\r\n            audience,\r\n            excludedAudience,\r\n            subject,\r\n            defaultSubject,\r\n            previewText,\r\n            emailId,\r\n            sysId,\r\n            showDefaultOption,\r\n            profile\r\n        } = strat;\r\n        const table = 'x_cadso_automate_email_send';\r\n        const emailGr = new GlideRecord(table);\r\n\t\tconst emailTableGr = new GlideRecord('x_cadso_automate_email');\r\n        if (sysId === '-1' || sysId === -1) {\r\n            emailGr.initialize();\r\n            emailGr.newRecord();\r\n            emailGr.setValue('email', emailId);\r\n            emailGr.update(); // update to get all the expected values from existing BRs.\r\n        } else if (!emailGr.get(sysId)) {\r\n            return {\r\n                success: false,\r\n                canSend: false\r\n            };\r\n        }\r\n\r\n        const status = emailGr.getValue('status');\r\n        const inQueue = ['ready_to_process', 'processing', 'sending'];\r\n        if (inQueue.includes(status) && !inQueueMessageAdded) {\r\n            inQueueMessageAdded = true;\r\n            messages.push({\r\n                message: \"Email Already In Queue\",\r\n                description: 'This email is already being process by the system and cannot be updated at this time.',\r\n                type: 'danger'\r\n            });\r\n            return {\r\n                success: false,\r\n                canSend: false\r\n            };\r\n        }\r\n\r\n        let staticSubjectLine = showDefaultOption ? defaultSubject : '';\r\n        const sendNow = sendingStrategy === 'now';\r\n        const schedule = sendingStrategy === 'sendingStrategy';\r\n        let deliveryTime = sendOn.displayValue;\r\n        let sendTimeOpt = optimized || false;\r\n        let timeZoneOpt = false;\r\n\r\n        if (sendNow) {\r\n            deliveryTime = '';\r\n        } else {\r\n            const optimizedByValue = optimizedBy.value;\r\n            if (optimizedByValue === 'sendTime') {\r\n                sendTimeOpt = true;\r\n                timeZoneOpt = false;\r\n                deliveryTime += ' 08:00:00';\r\n            } else if (optimizedByValue === 'timeZone') {\r\n                sendTimeOpt = false;\r\n                timeZoneOpt = true;\r\n            } else {\r\n                sendTimeOpt = false;\r\n            }\r\n        }\r\n\r\n        if (deliveryTime) {\r\n            var gdt = new GlideDateTime();\r\n            gdt.setDisplayValue(deliveryTime);\r\n            deliveryTime = gdt.getValue();\r\n        }\r\n\r\n        emailGr.setValue('from_address', profile.value);\r\n        emailGr.setValue('send_now', sendNow);\r\n        emailGr.setValue('send_time_optimization', sendTimeOpt);\r\n        emailGr.setValue('time_zone_optimization', timeZoneOpt);\r\n        emailGr.setValue('delivery_time', deliveryTime);\r\n        emailGr.setValue('dynamic_subject_line', subject);\r\n        emailGr.setValue('static_subject_line', staticSubjectLine);\r\n        emailGr.setValue('preview_text', previewText);\r\n        emailGr.setValue('includes', JSON.stringify(audience || []));\r\n        emailGr.setValue('excludes', JSON.stringify(excludedAudience || []));\r\n\r\n        if (audience && audience.selected && audience.selected.x_cadso_automate_audience) {\r\n            const audiences = Object.keys(audience.selected.x_cadso_automate_audience);\r\n            emailGr.setValue('audiences', audiences.join(','));\r\n        }\r\n\r\n        if (excludedAudience && excludedAudience.selected && excludedAudience.selected.x_cadso_automate_audience) {\r\n            const excludedAudiences = Object.keys(excludedAudience.selected.x_cadso_automate_audience);\r\n            emailGr.setValue('excluded_audiences', excludedAudiences.join(','));\r\n        }\r\n\r\n        if (draft === true || draft === 'true') {\r\n            emailGr.setValue('status', 'draft');\r\n        } else if (type === 'automated') {\r\n\t\t\temailGr.setValue('status', 'published');\r\n\r\n\t\t\tif (emailTableGr.get(emailId)) {\r\n\t\t\t\temailTableGr.setValue('published', Date.now());\r\n\t\t\t\temailTableGr.update();\r\n\t\t\t}\r\n        } else if (sendNow === true || sendNow === 'true') {\r\n            emailGr.setValue('status', 'ready_to_process');\r\n        } else {\r\n            emailGr.setValue('status', 'scheduled');\r\n        }\r\n\r\n\r\n        const success = emailGr.update(); // This seems to come back as nothing..?\r\n        const canSend = emailGr.getValue('can_send') === '1' || emailGr.getValue('can_send') === 'true';\r\n\r\n        return {\r\n            success,\r\n            canSend\r\n        };\r\n    }\r\n\r\n    function createOrUpdateMessageSends({\r\n        strat,\r\n        sinchJson,\r\n        draft,\r\n        richText,\r\n\t\ttype\r\n    }) {\r\n\r\n        const {\r\n            optimized,\r\n            optimizedBy = {},\r\n            sendingStrategy,\r\n            sendOn,\r\n            audience,\r\n            excludedAudience,\r\n            text,\r\n            optOut,\r\n            unsubscribeText = \"\",\r\n            messageId,\r\n            sysId,\r\n            profile,\r\n            // richText\r\n        } = strat;\r\n\t\t\r\n        var dynInputs = richText.dynamicInputs || [];\r\n        var success = false;\r\n        const table = 'x_cadso_automate_message_send';\r\n        const messageGR = new GlideRecord(table);\r\n        messageGR.addQuery(\"sys_id\", sysId);\r\n        messageGR.query();\r\n\r\n        if (messageGR.next()) {\r\n\r\n            var updateMessageTypeGR = new GlideRecord(\"x_cadso_automate_message\");\r\n            updateMessageTypeGR.addQuery(\"sys_id\", messageGR.message);\r\n            updateMessageTypeGR.query();\r\n            if (updateMessageTypeGR.next()) {\r\n                //if the message send contains attachments update message to MMS\r\n                if (richText.attachments && richText.attachments.length > 0) {\r\n                    updateMessageTypeGR.type = 'mms';\r\n                } else {\r\n                    updateMessageTypeGR.type = 'sms';\r\n                }\r\n                updateMessageTypeGR.update();\r\n            }\r\n            //messageGR.rich_text_object = '';\r\n            //messageGR.send_strategy_json_object = '';\r\n            //messageGR.update();\r\n            const sendNow = sendingStrategy === 'now';\r\n            const schedule = sendingStrategy === 'sendingStrategy';\r\n            let deliveryTime = sendOn.displayValue;\r\n            let sendTimeOpt = optimized || false;\r\n            let timeZoneOpt = false;\r\n\r\n            if (sendNow) {\r\n                deliveryTime = '';\r\n            } else {\r\n                const optimizedByValue = optimizedBy.value;\r\n                if (optimizedByValue === 'sendTime') {\r\n                    sendTimeOpt = true;\r\n                    timeZoneOpt = false;\r\n                    deliveryTime += ' 08:00:00';\r\n                } else if (optimizedByValue === 'timeZone') {\r\n                    sendTimeOpt = false;\r\n                    timeZoneOpt = true;\r\n                } else {\r\n                    sendTimeOpt = false;\r\n                }\r\n            }\r\n\r\n            if (deliveryTime) {\r\n                var gdt = new GlideDateTime();\r\n                gdt.setDisplayValue(deliveryTime);\r\n                deliveryTime = gdt.getValue();\r\n            }\r\n\r\n\r\n            var oldLabelMapping = {};\r\n            var sinchObj = {\r\n                parameters: {}\r\n            };\r\n            var newText = richText.stringMessage;\r\n            var combinedText = \"\";\r\n            dynInputs.forEach(input => {\r\n                //var label = input.label.replace(/[{}]/g, \"\");\r\n\r\n                var formattedLabel = input.value.toLowerCase();\r\n                if (formattedLabel.includes(\" \")) {\r\n                    formattedLabel = formattedLabel.replace(/\\s+/g, '_');\r\n                }\r\n\r\n\r\n                oldLabelMapping[input.label] = `${formattedLabel}`;\r\n                sinchObj.parameters[formattedLabel] = {\r\n                    default: input.defaultValue\r\n                };\r\n\r\n            });\r\n\r\n            Object.keys(oldLabelMapping).forEach(oldLabel => {\r\n                var newLabel = oldLabelMapping[oldLabel];\r\n                newText = newText.replace(new RegExp(oldLabel, 'g'), newLabel);\r\n\r\n            });\r\n\r\n            newText = newText.replace(/<a[^>]*href=[\"']([^\"']*)[\"'][^>]*>(.*?)<\\/a>/gi, (match, url, text) => {\r\n                return url || text;\r\n            });\r\n            newText = newText.replace(/<([^<>]+)>/g, '$1');\r\n            //escape new line characters\r\n            newText = newText.replaceAll('\\n', '\\\\n');\r\n            newText = newText.replace(/\"/g, \"'\");\r\n\r\n            if (optOut && unsubscribeText) {\r\n                combinedText = newText + '\\\\n\\\\n' + unsubscribeText;\r\n            } else {\r\n                combinedText = newText;\r\n            }\r\n\r\n            messageGR.setValue('message_number', profile.value);\r\n            messageGR.setValue('send_now', sendNow);\r\n            messageGR.setValue('send_time_optimization', sendTimeOpt);\r\n            messageGR.setValue('time_zone_optimization', timeZoneOpt);\r\n            messageGR.setValue('delivery_time', deliveryTime);\r\n            messageGR.setValue('body_text', newText);\r\n            messageGR.setValue('unsubscribe_text', unsubscribeText);\r\n            messageGR.setValue('includes', JSON.stringify(audience || []));\r\n            messageGR.setValue('excludes', JSON.stringify(excludedAudience || []));\r\n            messageGR.setValue('send_strategy_json_object', JSON.stringify(strat));\r\n            messageGR.setValue('rich_text_object', JSON.stringify(richText));\r\n            messageGR.setValue('include_opt_out_text', optOut);\r\n            messageGR.setValue('text', combinedText);\r\n            // messageGR.setValue('json', sinchJson);\r\n            if (audience && audience.selected && audience.selected.x_cadso_automate_audience) {\r\n                const audiences = Object.keys(audience.selected.x_cadso_automate_audience);\r\n                messageGR.setValue('audiences', audiences.join(','));\r\n            }\r\n\r\n            if (excludedAudience && excludedAudience.selected && excludedAudience.selected.x_cadso_automate_audience) {\r\n                const excludedAudiences = Object.keys(excludedAudience.selected.x_cadso_automate_audience);\r\n                messageGR.setValue('excluded_audiences', excludedAudiences.join(','));\r\n            }\r\n\r\n            //messageGR.setValue('include_opt_out', includeOptOut ? 'true' : 'false');\r\n            if (sinchObj) {\r\n                messageGR.setValue('json', JSON.stringify(sinchObj));\r\n            }\r\n            //Updating All fields before state to see if can send is true\r\n            messageGR.update();\r\n            success = true;\r\n            var canSendCheck = messageGR.message.can_send;\r\n\r\n\r\n\r\n            //Update Message Send States\r\n            if (draft === true) {\r\n                const status = messageGR.getValue('status');\r\n                const inQueue = ['ready_to_process', 'processing', 'sending'];\r\n\r\n                if (inQueue.includes(status) && !inQueueMessageAdded) {\r\n                    inQueueMessageAdded = true;\r\n                    messages.push({\r\n                        message: \"SMS Already In Queue\",\r\n                        description: 'This SMS is already being processed by the system and cannot be updated at this time.',\r\n                        type: 'danger',\r\n                    });\r\n                    success = false;\r\n                } else {\r\n                    messageGR.setValue('status', 'draft');\r\n                    messageGR.update();\r\n                    success = true;\r\n                }\r\n\r\n            } else {\r\n                if (canSendCheck) {\r\n                    if (sendNow === true) {\r\n                        messageGR.setValue('status', 'ready_to_process');\r\n\r\n                    } else {\r\n                        messageGR.setValue('status', 'scheduled');\r\n                    }\r\n\r\n\t\t\t\t\tif(type === 'automated'){\r\n\t\t\t\t\t\tmessageGR.setValue('status', 'published');\r\n\t\t\t\t\t\tmessageGR.setValue('send_now', false);\r\n\t\t\t\t\t}\r\n                    messageGR.update();\r\n                    success = true;\r\n                } else {\r\n                    var missingFields = smsMandatoryFields(sysId, sendingStrategy);\r\n                    messages.push({\r\n                        message: \"SMS cannot be sent\",\r\n                        description: \"The following fields are missing : \" + missingFields,\r\n                        type: 'danger',\r\n                    });\r\n                    success = false;\r\n                }\r\n\r\n            }\r\n            //const canSend = messageGR.getValue('can_send') === '1' || messageGR.getValue('can_send') === 'true';\r\n\r\n\r\n\r\n            // if (sysId === '-1' || sysId === -1) {\r\n            // \tmessageGR.initialize();\r\n            // \tmessageGR.newRecord();\r\n            // \tmessageGR.setValue('message', messageId);\r\n            // } else if (!messageGR.get(sysId)) {\r\n            // \treturn { success: false, canSend: false };\r\n            // }\r\n\r\n            // messageGR.setValue('text', richText?.stringMessage || '');\r\n            // messageGR.setValue('media', JSON.stringify(attachments || []));\r\n            // messageGR.setValue('strats', JSON.stringify(strats || []));\r\n            // messageGR.setValue('includes', JSON.stringify(includedAudience || []));\r\n            // messageGR.setValue('excludes', JSON.stringify(excludedAudience || []));\r\n            // messageGR.setValue('sender_profile', JSON.stringify(senderProfile || {}));\r\n            // messageGR.setValue('send_now', sendNow ? 'true' : 'false');\r\n            // messageGR.setValue('delivery_time', deliveryTime);\r\n            // messageGR.setValue('include_opt_out', includeOptOut ? 'true' : 'false');\r\n            // messageGR.setValue('opt_out_text', includeOptOutText || '');\r\n            // messageGR.setValue('send_strategy_json_object', JSON.stringify(strat));\r\n        }\r\n        return {\r\n            success,\r\n            canSend\r\n        };\r\n    }\r\n\r\n    function smsMandatoryFields(sysId, strategy) {\r\n        var missingFields = [];\r\n        var mandatoryFields = ['text', 'audiences'];\r\n        var messageSendGR = new GlideRecord(\"x_cadso_automate_message_send\");\r\n        messageSendGR.addQuery(\"sys_id\", sysId);\r\n        messageSendGR.query();\r\n        if (messageSendGR.next()) {\r\n            for (var i = 0; i < mandatoryFields.length; i++) {\r\n                if (!messageSendGR.getValue(mandatoryFields[i])) {\r\n                    missingFields.push(messageSendGR.getElement(mandatoryFields[i]).getLabel());\r\n                }\r\n                if (strategy === \"schedule\") {\r\n                    if (!messageSendGR.getValue(\"delivery_time\")) {\r\n                        missingFields.push(\"Send On\");\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return missingFields.join(\", \");\r\n\r\n    }\r\n\r\n})(request, response);",
    "display_value": "(function process( /*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {\r\n\r\n    const {\r\n        strats,\r\n        draft = false,\r\n        canSend = false,\r\n        messageType,\r\n        sinchJson,\r\n        richText,\r\n        type = ''\r\n    } = request.body.data;\r\n\r\n    const successful = [];\r\n    const canSends = [];\r\n    let messages = [];\r\n    let inQueueMessageAdded = false;\r\n\t// gs.info(\"dh strats \" + JSON.stringify(strats));\r\n    // When single email send strat is saved, clean up abandoned B sends.\r\n    if (messageType === 'email' && strats.length === 1) {\r\n        removeBEmailSends(strats[0]);\r\n    }\r\n\r\n    for (var x = 0; x < strats.length; x++) {\r\n        if (inQueueMessageAdded) {\r\n            successful.push(false);\r\n            canSends.push(false);\r\n            continue;\r\n        }\r\n        const {\r\n            success,\r\n            canSend\r\n        } = messageType === 'sms' ?\r\n            createOrUpdateMessageSends({\r\n                strat: strats[x],\r\n                sinchJson,\r\n                draft,\r\n                richText,\r\n\t\t\t\ttype\r\n            }) :\r\n            createOrUpdateEmailSends({\r\n                strat: strats[x],\r\n                draft,\r\n                type\r\n            });\r\n        if (success && success.length === 32) {\r\n            strats[x].sysId = success;\r\n            successful.push(true);\r\n        } else if (success) { // this is a weird bug if you try to save from the email now/schedule option, success comes back as nothing, so checking to see if success is populated first\r\n            successful.push(success);\r\n        }\r\n        canSends.push(canSend);\r\n    }\r\n    const _successful = successful.filter(res => res === true).length === strats.length;\r\n\r\n    if (successful && successful.length > 0) {\r\n        messages.push({\r\n            message: \"Update Successful\",\r\n            description: '',\r\n            type: 'success'\r\n        });\r\n    }\r\n\r\n    const responseBody = {\r\n        successful: _successful,\r\n        canSend: canSends.filter(res => res === true).length === strats.length,\r\n        strats,\r\n        draft,\r\n        messages\r\n    };\r\n\r\n    response.setBody(responseBody);\r\n\r\n    function removeBEmailSends(strat_a) {\r\n        const bEmailSendGr = new GlideRecord('x_cadso_automate_email_send');\r\n        bEmailSendGr.addQuery('email', strat_a.emailId);\r\n        bEmailSendGr.addQuery(\"sys_id\", \"!=\", strat_a.sysId);\r\n        bEmailSendGr.query();\r\n        if (bEmailSendGr.next()) {\r\n            bEmailSendGr.deleteRecord();\r\n        }\r\n    }\r\n\r\n    function createOrUpdateEmailSends({\r\n        strat,\r\n        draft,\r\n        type\r\n    }) {\r\n        const {\r\n            optimized,\r\n            optimizedBy = {},\r\n            sendingStrategy,\r\n            sendOn,\r\n            audience,\r\n            excludedAudience,\r\n            subject,\r\n            defaultSubject,\r\n            previewText,\r\n            emailId,\r\n            sysId,\r\n            showDefaultOption,\r\n            profile\r\n        } = strat;\r\n        const table = 'x_cadso_automate_email_send';\r\n        const emailGr = new GlideRecord(table);\r\n\t\tconst emailTableGr = new GlideRecord('x_cadso_automate_email');\r\n        if (sysId === '-1' || sysId === -1) {\r\n            emailGr.initialize();\r\n            emailGr.newRecord();\r\n            emailGr.setValue('email', emailId);\r\n            emailGr.update(); // update to get all the expected values from existing BRs.\r\n        } else if (!emailGr.get(sysId)) {\r\n            return {\r\n                success: false,\r\n                canSend: false\r\n            };\r\n        }\r\n\r\n        const status = emailGr.getValue('status');\r\n        const inQueue = ['ready_to_process', 'processing', 'sending'];\r\n        if (inQueue.includes(status) && !inQueueMessageAdded) {\r\n            inQueueMessageAdded = true;\r\n            messages.push({\r\n                message: \"Email Already In Queue\",\r\n                description: 'This email is already being process by the system and cannot be updated at this time.',\r\n                type: 'danger'\r\n            });\r\n            return {\r\n                success: false,\r\n                canSend: false\r\n            };\r\n        }\r\n\r\n        let staticSubjectLine = showDefaultOption ? defaultSubject : '';\r\n        const sendNow = sendingStrategy === 'now';\r\n        const schedule = sendingStrategy === 'sendingStrategy';\r\n        let deliveryTime = sendOn.displayValue;\r\n        let sendTimeOpt = optimized || false;\r\n        let timeZoneOpt = false;\r\n\r\n        if (sendNow) {\r\n            deliveryTime = '';\r\n        } else {\r\n            const optimizedByValue = optimizedBy.value;\r\n            if (optimizedByValue === 'sendTime') {\r\n                sendTimeOpt = true;\r\n                timeZoneOpt = false;\r\n                deliveryTime += ' 08:00:00';\r\n            } else if (optimizedByValue === 'timeZone') {\r\n                sendTimeOpt = false;\r\n                timeZoneOpt = true;\r\n            } else {\r\n                sendTimeOpt = false;\r\n            }\r\n        }\r\n\r\n        if (deliveryTime) {\r\n            var gdt = new GlideDateTime();\r\n            gdt.setDisplayValue(deliveryTime);\r\n            deliveryTime = gdt.getValue();\r\n        }\r\n\r\n        emailGr.setValue('from_address', profile.value);\r\n        emailGr.setValue('send_now', sendNow);\r\n        emailGr.setValue('send_time_optimization', sendTimeOpt);\r\n        emailGr.setValue('time_zone_optimization', timeZoneOpt);\r\n        emailGr.setValue('delivery_time', deliveryTime);\r\n        emailGr.setValue('dynamic_subject_line', subject);\r\n        emailGr.setValue('static_subject_line', staticSubjectLine);\r\n        emailGr.setValue('preview_text', previewText);\r\n        emailGr.setValue('includes', JSON.stringify(audience || []));\r\n        emailGr.setValue('excludes', JSON.stringify(excludedAudience || []));\r\n\r\n        if (audience && audience.selected && audience.selected.x_cadso_automate_audience) {\r\n            const audiences = Object.keys(audience.selected.x_cadso_automate_audience);\r\n            emailGr.setValue('audiences', audiences.join(','));\r\n        }\r\n\r\n        if (excludedAudience && excludedAudience.selected && excludedAudience.selected.x_cadso_automate_audience) {\r\n            const excludedAudiences = Object.keys(excludedAudience.selected.x_cadso_automate_audience);\r\n            emailGr.setValue('excluded_audiences', excludedAudiences.join(','));\r\n        }\r\n\r\n        if (draft === true || draft === 'true') {\r\n            emailGr.setValue('status', 'draft');\r\n        } else if (type === 'automated') {\r\n\t\t\temailGr.setValue('status', 'published');\r\n\r\n\t\t\tif (emailTableGr.get(emailId)) {\r\n\t\t\t\temailTableGr.setValue('published', Date.now());\r\n\t\t\t\temailTableGr.update();\r\n\t\t\t}\r\n        } else if (sendNow === true || sendNow === 'true') {\r\n            emailGr.setValue('status', 'ready_to_process');\r\n        } else {\r\n            emailGr.setValue('status', 'scheduled');\r\n        }\r\n\r\n\r\n        const success = emailGr.update(); // This seems to come back as nothing..?\r\n        const canSend = emailGr.getValue('can_send') === '1' || emailGr.getValue('can_send') === 'true';\r\n\r\n        return {\r\n            success,\r\n            canSend\r\n        };\r\n    }\r\n\r\n    function createOrUpdateMessageSends({\r\n        strat,\r\n        sinchJson,\r\n        draft,\r\n        richText,\r\n\t\ttype\r\n    }) {\r\n\r\n        const {\r\n            optimized,\r\n            optimizedBy = {},\r\n            sendingStrategy,\r\n            sendOn,\r\n            audience,\r\n            excludedAudience,\r\n            text,\r\n            optOut,\r\n            unsubscribeText = \"\",\r\n            messageId,\r\n            sysId,\r\n            profile,\r\n            // richText\r\n        } = strat;\r\n\t\t\r\n        var dynInputs = richText.dynamicInputs || [];\r\n        var success = false;\r\n        const table = 'x_cadso_automate_message_send';\r\n        const messageGR = new GlideRecord(table);\r\n        messageGR.addQuery(\"sys_id\", sysId);\r\n        messageGR.query();\r\n\r\n        if (messageGR.next()) {\r\n\r\n            var updateMessageTypeGR = new GlideRecord(\"x_cadso_automate_message\");\r\n            updateMessageTypeGR.addQuery(\"sys_id\", messageGR.message);\r\n            updateMessageTypeGR.query();\r\n            if (updateMessageTypeGR.next()) {\r\n                //if the message send contains attachments update message to MMS\r\n                if (richText.attachments && richText.attachments.length > 0) {\r\n                    updateMessageTypeGR.type = 'mms';\r\n                } else {\r\n                    updateMessageTypeGR.type = 'sms';\r\n                }\r\n                updateMessageTypeGR.update();\r\n            }\r\n            //messageGR.rich_text_object = '';\r\n            //messageGR.send_strategy_json_object = '';\r\n            //messageGR.update();\r\n            const sendNow = sendingStrategy === 'now';\r\n            const schedule = sendingStrategy === 'sendingStrategy';\r\n            let deliveryTime = sendOn.displayValue;\r\n            let sendTimeOpt = optimized || false;\r\n            let timeZoneOpt = false;\r\n\r\n            if (sendNow) {\r\n                deliveryTime = '';\r\n            } else {\r\n                const optimizedByValue = optimizedBy.value;\r\n                if (optimizedByValue === 'sendTime') {\r\n                    sendTimeOpt = true;\r\n                    timeZoneOpt = false;\r\n                    deliveryTime += ' 08:00:00';\r\n                } else if (optimizedByValue === 'timeZone') {\r\n                    sendTimeOpt = false;\r\n                    timeZoneOpt = true;\r\n                } else {\r\n                    sendTimeOpt = false;\r\n                }\r\n            }\r\n\r\n            if (deliveryTime) {\r\n                var gdt = new GlideDateTime();\r\n                gdt.setDisplayValue(deliveryTime);\r\n                deliveryTime = gdt.getValue();\r\n            }\r\n\r\n\r\n            var oldLabelMapping = {};\r\n            var sinchObj = {\r\n                parameters: {}\r\n            };\r\n            var newText = richText.stringMessage;\r\n            var combinedText = \"\";\r\n            dynInputs.forEach(input => {\r\n                //var label = input.label.replace(/[{}]/g, \"\");\r\n\r\n                var formattedLabel = input.value.toLowerCase();\r\n                if (formattedLabel.includes(\" \")) {\r\n                    formattedLabel = formattedLabel.replace(/\\s+/g, '_');\r\n                }\r\n\r\n\r\n                oldLabelMapping[input.label] = `${formattedLabel}`;\r\n                sinchObj.parameters[formattedLabel] = {\r\n                    default: input.defaultValue\r\n                };\r\n\r\n            });\r\n\r\n            Object.keys(oldLabelMapping).forEach(oldLabel => {\r\n                var newLabel = oldLabelMapping[oldLabel];\r\n                newText = newText.replace(new RegExp(oldLabel, 'g'), newLabel);\r\n\r\n            });\r\n\r\n            newText = newText.replace(/<a[^>]*href=[\"']([^\"']*)[\"'][^>]*>(.*?)<\\/a>/gi, (match, url, text) => {\r\n                return url || text;\r\n            });\r\n            newText = newText.replace(/<([^<>]+)>/g, '$1');\r\n            //escape new line characters\r\n            newText = newText.replaceAll('\\n', '\\\\n');\r\n            newText = newText.replace(/\"/g, \"'\");\r\n\r\n            if (optOut && unsubscribeText) {\r\n                combinedText = newText + '\\\\n\\\\n' + unsubscribeText;\r\n            } else {\r\n                combinedText = newText;\r\n            }\r\n\r\n            messageGR.setValue('message_number', profile.value);\r\n            messageGR.setValue('send_now', sendNow);\r\n            messageGR.setValue('send_time_optimization', sendTimeOpt);\r\n            messageGR.setValue('time_zone_optimization', timeZoneOpt);\r\n            messageGR.setValue('delivery_time', deliveryTime);\r\n            messageGR.setValue('body_text', newText);\r\n            messageGR.setValue('unsubscribe_text', unsubscribeText);\r\n            messageGR.setValue('includes', JSON.stringify(audience || []));\r\n            messageGR.setValue('excludes', JSON.stringify(excludedAudience || []));\r\n            messageGR.setValue('send_strategy_json_object', JSON.stringify(strat));\r\n            messageGR.setValue('rich_text_object', JSON.stringify(richText));\r\n            messageGR.setValue('include_opt_out_text', optOut);\r\n            messageGR.setValue('text', combinedText);\r\n            // messageGR.setValue('json', sinchJson);\r\n            if (audience && audience.selected && audience.selected.x_cadso_automate_audience) {\r\n                const audiences = Object.keys(audience.selected.x_cadso_automate_audience);\r\n                messageGR.setValue('audiences', audiences.join(','));\r\n            }\r\n\r\n            if (excludedAudience && excludedAudience.selected && excludedAudience.selected.x_cadso_automate_audience) {\r\n                const excludedAudiences = Object.keys(excludedAudience.selected.x_cadso_automate_audience);\r\n                messageGR.setValue('excluded_audiences', excludedAudiences.join(','));\r\n            }\r\n\r\n            //messageGR.setValue('include_opt_out', includeOptOut ? 'true' : 'false');\r\n            if (sinchObj) {\r\n                messageGR.setValue('json', JSON.stringify(sinchObj));\r\n            }\r\n            //Updating All fields before state to see if can send is true\r\n            messageGR.update();\r\n            success = true;\r\n            var canSendCheck = messageGR.message.can_send;\r\n\r\n\r\n\r\n            //Update Message Send States\r\n            if (draft === true) {\r\n                const status = messageGR.getValue('status');\r\n                const inQueue = ['ready_to_process', 'processing', 'sending'];\r\n\r\n                if (inQueue.includes(status) && !inQueueMessageAdded) {\r\n                    inQueueMessageAdded = true;\r\n                    messages.push({\r\n                        message: \"SMS Already In Queue\",\r\n                        description: 'This SMS is already being processed by the system and cannot be updated at this time.',\r\n                        type: 'danger',\r\n                    });\r\n                    success = false;\r\n                } else {\r\n                    messageGR.setValue('status', 'draft');\r\n                    messageGR.update();\r\n                    success = true;\r\n                }\r\n\r\n            } else {\r\n                if (canSendCheck) {\r\n                    if (sendNow === true) {\r\n                        messageGR.setValue('status', 'ready_to_process');\r\n\r\n                    } else {\r\n                        messageGR.setValue('status', 'scheduled');\r\n                    }\r\n\r\n\t\t\t\t\tif(type === 'automated'){\r\n\t\t\t\t\t\tmessageGR.setValue('status', 'published');\r\n\t\t\t\t\t\tmessageGR.setValue('send_now', false);\r\n\t\t\t\t\t}\r\n                    messageGR.update();\r\n                    success = true;\r\n                } else {\r\n                    var missingFields = smsMandatoryFields(sysId, sendingStrategy);\r\n                    messages.push({\r\n                        message: \"SMS cannot be sent\",\r\n                        description: \"The following fields are missing : \" + missingFields,\r\n                        type: 'danger',\r\n                    });\r\n                    success = false;\r\n                }\r\n\r\n            }\r\n            //const canSend = messageGR.getValue('can_send') === '1' || messageGR.getValue('can_send') === 'true';\r\n\r\n\r\n\r\n            // if (sysId === '-1' || sysId === -1) {\r\n            // \tmessageGR.initialize();\r\n            // \tmessageGR.newRecord();\r\n            // \tmessageGR.setValue('message', messageId);\r\n            // } else if (!messageGR.get(sysId)) {\r\n            // \treturn { success: false, canSend: false };\r\n            // }\r\n\r\n            // messageGR.setValue('text', richText?.stringMessage || '');\r\n            // messageGR.setValue('media', JSON.stringify(attachments || []));\r\n            // messageGR.setValue('strats', JSON.stringify(strats || []));\r\n            // messageGR.setValue('includes', JSON.stringify(includedAudience || []));\r\n            // messageGR.setValue('excludes', JSON.stringify(excludedAudience || []));\r\n            // messageGR.setValue('sender_profile', JSON.stringify(senderProfile || {}));\r\n            // messageGR.setValue('send_now', sendNow ? 'true' : 'false');\r\n            // messageGR.setValue('delivery_time', deliveryTime);\r\n            // messageGR.setValue('include_opt_out', includeOptOut ? 'true' : 'false');\r\n            // messageGR.setValue('opt_out_text', includeOptOutText || '');\r\n            // messageGR.setValue('send_strategy_json_object', JSON.stringify(strat));\r\n        }\r\n        return {\r\n            success,\r\n            canSend\r\n        };\r\n    }\r\n\r\n    function smsMandatoryFields(sysId, strategy) {\r\n        var missingFields = [];\r\n        var mandatoryFields = ['text', 'audiences'];\r\n        var messageSendGR = new GlideRecord(\"x_cadso_automate_message_send\");\r\n        messageSendGR.addQuery(\"sys_id\", sysId);\r\n        messageSendGR.query();\r\n        if (messageSendGR.next()) {\r\n            for (var i = 0; i < mandatoryFields.length; i++) {\r\n                if (!messageSendGR.getValue(mandatoryFields[i])) {\r\n                    missingFields.push(messageSendGR.getElement(mandatoryFields[i]).getLabel());\r\n                }\r\n                if (strategy === \"schedule\") {\r\n                    if (!messageSendGR.getValue(\"delivery_time\")) {\r\n                        missingFields.push(\"Send On\");\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return missingFields.join(\", \");\r\n\r\n    }\r\n\r\n})(request, response);"
  },
  "sys_updated_on": {
    "value": "2025-09-10 19:32:10",
    "display_value": "2025-09-10 12:32:10 PM"
  },
  "enforce_acl": {
    "value": "003a5109c3ee021085b196c4e40131ab",
    "display_value": "Tenon Automate UI API Access"
  },
  "web_service_version": {
    "value": "",
    "display_value": ""
  },
  "sys_class_name": {
    "value": "sys_ws_operation",
    "display_value": "Scripted REST Resource"
  },
  "requires_acl_authorization": {
    "value": "true",
    "display_value": "true"
  },
  "request_example": {
    "value": "",
    "display_value": ""
  },
  "http_method": {
    "value": "POST",
    "display_value": "POST"
  },
  "sys_updated_by": {
    "value": "will.mcgill",
    "display_value": "will.mcgill"
  },
  "operation_uri": {
    "value": "/api/x_cadso_automate/ui/sendingStrategy/save",
    "display_value": "/api/x_cadso_automate/ui/sendingStrategy/save"
  },
  "sys_created_on": {
    "value": "2024-08-01 17:18:51",
    "display_value": "2024-08-01 10:18:51 AM"
  },
  "sys_name": {
    "value": "Sending Strategy - Save",
    "display_value": "Sending Strategy - Save"
  },
  "sys_scope": {
    "value": "5e9f5f8b87420250369f33373cbb3559",
    "display_value": "Tenon Marketing Automation"
  },
  "sys_created_by": {
    "value": "admin",
    "display_value": "admin"
  },
  "web_service_definition": {
    "value": "4a222358c3aa425085b196c4e401318e",
    "display_value": "Tenon Automate UI API"
  },
  "consumes": {
    "value": "application/json,application/xml,text/xml",
    "display_value": "application/json,application/xml,text/xml"
  },
  "x_cadso_api_docs_request_body_schema": {
    "value": "",
    "display_value": ""
  },
  "requires_snc_internal_role": {
    "value": "true",
    "display_value": "true"
  },
  "requires_authentication": {
    "value": "true",
    "display_value": "true"
  },
  "sys_mod_count": {
    "value": "265",
    "display_value": "265"
  },
  "active": {
    "value": "true",
    "display_value": "true"
  },
  "x_cadso_api_docs_tags": {
    "value": "Sending Strategies",
    "display_value": "Sending Strategies"
  },
  "sys_tags": {
    "value": "",
    "display_value": ""
  },
  "sys_package": {
    "value": "5e9f5f8b87420250369f33373cbb3559",
    "display_value": "Tenon Marketing Automation"
  },
  "sys_update_name": {
    "value": "sys_ws_operation_43f40005c37b029085b196c4e401317e",
    "display_value": "sys_ws_operation_43f40005c37b029085b196c4e401317e"
  },
  "consumes_customized": {
    "value": "false",
    "display_value": "false"
  },
  "name": {
    "value": "Sending Strategy - Save",
    "display_value": "Sending Strategy - Save"
  },
  "produces": {
    "value": "application/json,application/xml,text/xml",
    "display_value": "application/json,application/xml,text/xml"
  },
  "relative_path": {
    "value": "/sendingStrategy/save",
    "display_value": "/sendingStrategy/save"
  },
  "produces_customized": {
    "value": "false",
    "display_value": "false"
  },
  "default_operation_uri": {
    "value": "",
    "display_value": ""
  },
  "sys_policy": {
    "value": "",
    "display_value": null
  }
}
