{
  "_metadata": {
    "table": "sys_ws_operation",
    "sys_id": "9dad67fb33379e107b18bc534d5c7bdf",
    "extracted_at": "2025-09-19T21:48:32.969Z",
    "display_value": "Summary",
    "application": "Tenon_Internal_Agile",
    "scope": {
      "display_value": "Tenon Internal Agile",
      "link": "https://tenonworkstudio.service-now.com/api/now/table/sys_scope/463f78c0ebde82d0f5a7f746cad0cdd2",
      "value": "463f78c0ebde82d0f5a7f746cad0cdd2"
    }
  },
  "short_description": {
    "value": "",
    "display_value": ""
  },
  "operation_script": {
    "value": "(function process(/*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {\r\n  // Goal: Overview of current status, previous errors, or without errors\r\n  // Sent Back filter stage\r\n  // By Sprint\r\n  // By Release\r\n  // By Epic\r\n  // By Time Frame\r\n  // Duration\r\n\r\n  /*\r\n    \tExample:\r\n    \t1. I want to know\r\n            a. how many stories are completed this Release, Sprint, or Time Frame\r\n                i. By Epics\r\n                    a. type = 'story'\r\n                    b. aggBy = { field: 'epic', fn: 'COUNT' }\r\n                    c. orderBys = [{ field: 'epic', direction: 'asc' }]\r\n                    d. groupBys = ['epic']\r\n                ii. By Release\r\n                    a. type = 'story'\r\n                    b. aggBy = { field: 'release', fn: 'COUNT' }\r\n                    c. orderBys = [{ field: 'release', direction: 'asc' }]\r\n                    d. groupBys = ['release']\r\n                iii. By Sprint\r\n                    a. type = 'story'\r\n                    b. aggBy = { field: 'sprint', fn: 'COUNT' }\r\n                    c. orderBys = [{ field: 'sprint', direction: 'asc' }]\r\n                    d. groupBys = ['sprint']\r\n\t\t\tb. Also with Points\r\n                i. type = 'story'\r\n                ii. aggBy = { field: 'story_points', fn: 'SUM' }\r\n                iii. orderBys = [{ field: 'epic', direction: 'asc' }]\r\n                iv. groupBys = ['epic']\r\n    \t2. I want to know how many points are completed per day\r\n    \t3. I want to know where the items are being sent back so I can spot an error\r\n    \t4. I want to know what stage is costing us the most time\r\n    \t5. I want to know highest performer\r\n            a. Figure out what send backs are valid for the developer\r\n                i. Dev stories sent back\r\n                ii. Peer Review stories sent back\r\n                iii. QA stories sent back\r\n                iv. UAT stories sent back\r\n            b. Stories not sent back and completed\r\n                i. Points\r\n                ii. Time\r\n            c. Average time per state\r\n                i. Successful Stories\r\n                ii. Stories sent back\r\n                iii. Total\r\n            d. Average story points\r\n                i. Successful Stories\r\n                ii. Stories sent back\r\n                iii. Total\r\n            e. Average time per story\r\n                i. Successful Stories\r\n                ii. Stories sent back\r\n                iii. Total\r\n            f. Average time per story point\r\n                i. Successful Stories\r\n                ii. Stories sent back\r\n                iii. Total\r\n            g. Average time per state\r\n                i. Successful Stories\r\n                ii. Stories sent back\r\n                iii. Total\r\n\r\n\t*/\r\n  let items = [];\r\n  if (type === \"story\") {\r\n    items = generalAggBy({ data: request.body.data || {} });\r\n  }\r\n\r\n  function generalAggBy({ data }) {\r\n    const { filters = [], type = \"\", orderBys = [], aggBy = {}, groupBys = [] } = data;\r\n    let table = \"\";\r\n    if (type === \"story\") {\r\n      table = \"rm_story\";\r\n    }\r\n    if (!table) return response;\r\n    const tableGr = new GlideAggregate(table);\r\n    if (aggBy && aggBy.field) {\r\n      const { field, fn = \"COUNT\" } = aggBy;\r\n      tableGr.addAggregate(fn, field);\r\n    } else {\r\n      tableGr.addAggregate(\"COUNT\");\r\n    }\r\n\r\n    if (filters && filters.length) {\r\n      for (let x = 0; x < filters.length; x++) {\r\n        const filter = filters[x];\r\n        const { field, value } = filter;\r\n        tableGr.addQuery(field, value);\r\n      }\r\n    }\r\n\r\n    if (groupBys && groupBys.length) {\r\n      for (let x = 0; x < groupBys.length; x++) {\r\n        const groupBy = groupBys[x];\r\n        tableGr.groupBy(groupBy);\r\n      }\r\n    }\r\n\r\n    if (orderBys && orderBys.length) {\r\n      for (let y = 0; y < orderBys.length; y++) {\r\n        const orderBy = orderBys[y];\r\n        const { field, direction } = orderBy;\r\n        if (\"desc\" === direction) {\r\n          tableGr.orderByDesc(field);\r\n        } else {\r\n          tableGr.orderBy(field);\r\n        }\r\n      }\r\n    }\r\n\r\n    tableGr.query();\r\n\r\n    const results = [];\r\n    while (tableGr.next()) {\r\n      if (type === \"story\") {\r\n        let count = 0;\r\n\r\n        const obj = {\r\n          sysId: tableGr.getUniqueValue(),\r\n          value: tableGr.getUniqueValue(),\r\n          groupBys: [],\r\n        };\r\n\r\n        const { field, fn = \"COUNT\" } = aggBy;\r\n        if (field) {\r\n          count = tableGr.getAggregate(fn, field);\r\n          obj.displayValue = tableGr.getElement(field).getLabel();\r\n        } else {\r\n          count = tableGr.getAggregate(\"COUNT\");\r\n          obj.displayValue = \"Total\";\r\n        }\r\n\r\n        if (groupBys && groupBys.length) {\r\n          for (let z = 0; z < groupBys.length; z++) {\r\n            const groupBy = groupBys[z];\r\n            obj.groupBys.push({\r\n              displayValue: tableGr.getDisplayValue(groupBy),\r\n              value: tableGr.getValue(groupBy),\r\n              sysId: tableGr.getValue(groupBy),\r\n            });\r\n          }\r\n        }\r\n\r\n        obj.count = count;\r\n        results.push(obj);\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  response.setBody({ items: results });\r\n  return response;\r\n})(request, response);",
    "display_value": "(function process(/*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {\r\n  // Goal: Overview of current status, previous errors, or without errors\r\n  // Sent Back filter stage\r\n  // By Sprint\r\n  // By Release\r\n  // By Epic\r\n  // By Time Frame\r\n  // Duration\r\n\r\n  /*\r\n    \tExample:\r\n    \t1. I want to know\r\n            a. how many stories are completed this Release, Sprint, or Time Frame\r\n                i. By Epics\r\n                    a. type = 'story'\r\n                    b. aggBy = { field: 'epic', fn: 'COUNT' }\r\n                    c. orderBys = [{ field: 'epic', direction: 'asc' }]\r\n                    d. groupBys = ['epic']\r\n                ii. By Release\r\n                    a. type = 'story'\r\n                    b. aggBy = { field: 'release', fn: 'COUNT' }\r\n                    c. orderBys = [{ field: 'release', direction: 'asc' }]\r\n                    d. groupBys = ['release']\r\n                iii. By Sprint\r\n                    a. type = 'story'\r\n                    b. aggBy = { field: 'sprint', fn: 'COUNT' }\r\n                    c. orderBys = [{ field: 'sprint', direction: 'asc' }]\r\n                    d. groupBys = ['sprint']\r\n\t\t\tb. Also with Points\r\n                i. type = 'story'\r\n                ii. aggBy = { field: 'story_points', fn: 'SUM' }\r\n                iii. orderBys = [{ field: 'epic', direction: 'asc' }]\r\n                iv. groupBys = ['epic']\r\n    \t2. I want to know how many points are completed per day\r\n    \t3. I want to know where the items are being sent back so I can spot an error\r\n    \t4. I want to know what stage is costing us the most time\r\n    \t5. I want to know highest performer\r\n            a. Figure out what send backs are valid for the developer\r\n                i. Dev stories sent back\r\n                ii. Peer Review stories sent back\r\n                iii. QA stories sent back\r\n                iv. UAT stories sent back\r\n            b. Stories not sent back and completed\r\n                i. Points\r\n                ii. Time\r\n            c. Average time per state\r\n                i. Successful Stories\r\n                ii. Stories sent back\r\n                iii. Total\r\n            d. Average story points\r\n                i. Successful Stories\r\n                ii. Stories sent back\r\n                iii. Total\r\n            e. Average time per story\r\n                i. Successful Stories\r\n                ii. Stories sent back\r\n                iii. Total\r\n            f. Average time per story point\r\n                i. Successful Stories\r\n                ii. Stories sent back\r\n                iii. Total\r\n            g. Average time per state\r\n                i. Successful Stories\r\n                ii. Stories sent back\r\n                iii. Total\r\n\r\n\t*/\r\n  let items = [];\r\n  if (type === \"story\") {\r\n    items = generalAggBy({ data: request.body.data || {} });\r\n  }\r\n\r\n  function generalAggBy({ data }) {\r\n    const { filters = [], type = \"\", orderBys = [], aggBy = {}, groupBys = [] } = data;\r\n    let table = \"\";\r\n    if (type === \"story\") {\r\n      table = \"rm_story\";\r\n    }\r\n    if (!table) return response;\r\n    const tableGr = new GlideAggregate(table);\r\n    if (aggBy && aggBy.field) {\r\n      const { field, fn = \"COUNT\" } = aggBy;\r\n      tableGr.addAggregate(fn, field);\r\n    } else {\r\n      tableGr.addAggregate(\"COUNT\");\r\n    }\r\n\r\n    if (filters && filters.length) {\r\n      for (let x = 0; x < filters.length; x++) {\r\n        const filter = filters[x];\r\n        const { field, value } = filter;\r\n        tableGr.addQuery(field, value);\r\n      }\r\n    }\r\n\r\n    if (groupBys && groupBys.length) {\r\n      for (let x = 0; x < groupBys.length; x++) {\r\n        const groupBy = groupBys[x];\r\n        tableGr.groupBy(groupBy);\r\n      }\r\n    }\r\n\r\n    if (orderBys && orderBys.length) {\r\n      for (let y = 0; y < orderBys.length; y++) {\r\n        const orderBy = orderBys[y];\r\n        const { field, direction } = orderBy;\r\n        if (\"desc\" === direction) {\r\n          tableGr.orderByDesc(field);\r\n        } else {\r\n          tableGr.orderBy(field);\r\n        }\r\n      }\r\n    }\r\n\r\n    tableGr.query();\r\n\r\n    const results = [];\r\n    while (tableGr.next()) {\r\n      if (type === \"story\") {\r\n        let count = 0;\r\n\r\n        const obj = {\r\n          sysId: tableGr.getUniqueValue(),\r\n          value: tableGr.getUniqueValue(),\r\n          groupBys: [],\r\n        };\r\n\r\n        const { field, fn = \"COUNT\" } = aggBy;\r\n        if (field) {\r\n          count = tableGr.getAggregate(fn, field);\r\n          obj.displayValue = tableGr.getElement(field).getLabel();\r\n        } else {\r\n          count = tableGr.getAggregate(\"COUNT\");\r\n          obj.displayValue = \"Total\";\r\n        }\r\n\r\n        if (groupBys && groupBys.length) {\r\n          for (let z = 0; z < groupBys.length; z++) {\r\n            const groupBy = groupBys[z];\r\n            obj.groupBys.push({\r\n              displayValue: tableGr.getDisplayValue(groupBy),\r\n              value: tableGr.getValue(groupBy),\r\n              sysId: tableGr.getValue(groupBy),\r\n            });\r\n          }\r\n        }\r\n\r\n        obj.count = count;\r\n        results.push(obj);\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  response.setBody({ items: results });\r\n  return response;\r\n})(request, response);"
  },
  "sys_updated_on": {
    "value": "2025-02-25 20:58:34",
    "display_value": "2025-02-25 12:58:34 PM"
  },
  "enforce_acl": {
    "value": "cf9d01d3e73003009d6247e603f6a990",
    "display_value": "Scripted REST External Default"
  },
  "web_service_version": {
    "value": "",
    "display_value": ""
  },
  "sys_class_name": {
    "value": "sys_ws_operation",
    "display_value": "Scripted REST Resource"
  },
  "requires_acl_authorization": {
    "value": "true",
    "display_value": "true"
  },
  "request_example": {
    "value": "",
    "display_value": ""
  },
  "http_method": {
    "value": "POST",
    "display_value": "POST"
  },
  "sys_updated_by": {
    "value": "admin",
    "display_value": "admin"
  },
  "operation_uri": {
    "value": "/api/x_cadso_ti_agile/ui/summary",
    "display_value": "/api/x_cadso_ti_agile/ui/summary"
  },
  "sys_created_on": {
    "value": "2025-02-25 19:30:38",
    "display_value": "2025-02-25 11:30:38 AM"
  },
  "sys_name": {
    "value": "Summary",
    "display_value": "Summary"
  },
  "sys_scope": {
    "value": "463f78c0ebde82d0f5a7f746cad0cdd2",
    "display_value": "Tenon Internal Agile"
  },
  "sys_created_by": {
    "value": "admin",
    "display_value": "admin"
  },
  "web_service_definition": {
    "value": "2c9da3fb33379e107b18bc534d5c7b3b",
    "display_value": "UI"
  },
  "consumes": {
    "value": "application/json,application/xml,text/xml",
    "display_value": "application/json,application/xml,text/xml"
  },
  "x_cadso_api_docs_request_body_schema": {
    "value": "",
    "display_value": ""
  },
  "requires_snc_internal_role": {
    "value": "true",
    "display_value": "true"
  },
  "requires_authentication": {
    "value": "true",
    "display_value": "true"
  },
  "sys_mod_count": {
    "value": "1",
    "display_value": "1"
  },
  "active": {
    "value": "true",
    "display_value": "true"
  },
  "x_cadso_api_docs_tags": {
    "value": "",
    "display_value": ""
  },
  "sys_tags": {
    "value": "",
    "display_value": ""
  },
  "sys_package": {
    "value": "463f78c0ebde82d0f5a7f746cad0cdd2",
    "display_value": "Tenon Internal Agile"
  },
  "sys_update_name": {
    "value": "sys_ws_operation_9dad67fb33379e107b18bc534d5c7bdf",
    "display_value": "sys_ws_operation_9dad67fb33379e107b18bc534d5c7bdf"
  },
  "consumes_customized": {
    "value": "false",
    "display_value": "false"
  },
  "name": {
    "value": "Summary",
    "display_value": "Summary"
  },
  "produces": {
    "value": "application/json,application/xml,text/xml",
    "display_value": "application/json,application/xml,text/xml"
  },
  "relative_path": {
    "value": "/summary",
    "display_value": "/summary"
  },
  "produces_customized": {
    "value": "false",
    "display_value": "false"
  },
  "default_operation_uri": {
    "value": "",
    "display_value": ""
  },
  "sys_policy": {
    "value": "",
    "display_value": null
  }
}
